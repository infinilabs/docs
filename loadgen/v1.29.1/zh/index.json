[{"category":null,"content":"性能测试 #  INFINI Loadgen 是一款专为 Easysearch、Elasticsearch、OpenSearch 设计的轻量级性能测试工具。\nLoadgen 的特点：\n 性能强劲 轻量级无依赖 支持模板化参数随机 支持高并发 支持压测端均衡流量控制 支持服务端返回值校验   下载地址：https://release.infinilabs.com/loadgen/\n Loadgen #  Loadgen 使用非常简单，下载解压之后会得到三个文件，一个可执行程序、一个配置文件 loadgen.yml 以及用于运行测试的 loadgen.dsl，配置文件样例如下：\nenv: ES_USERNAME: elastic ES_PASSWORD: elastic ES_ENDPOINT: http://localhost:8000 测试文件样例如下：\n# runner: { # // total_rounds: 1 # no_warm: false, # // Whether to log all requests # log_requests: false, # // Whether to log all requests with the specified response status # log_status_codes: [0, 500], # assert_invalid: false, # assert_error: false, # }, # variables: [ # { # name: \u0026#34;ip\u0026#34;, # type: \u0026#34;file\u0026#34;, # path: \u0026#34;dict/ip.txt\u0026#34;, # // Replace special characters in the value # replace: { # \u0026#39;\u0026#34;\u0026#39;: \u0026#39;\\\\\u0026#34;\u0026#39;, # \u0026#39;\\\\\u0026#39;: \u0026#39;\\\\\\\\\u0026#39;, # }, # }, # { # name: \u0026#34;id\u0026#34;, # type: \u0026#34;sequence\u0026#34;, # }, # { # name: \u0026#34;id64\u0026#34;, # type: \u0026#34;sequence64\u0026#34;, # }, # { # name: \u0026#34;uuid\u0026#34;, # type: \u0026#34;uuid\u0026#34;, # }, # { # name: \u0026#34;now_local\u0026#34;, # type: \u0026#34;now_local\u0026#34;, # }, # { # name: \u0026#34;now_utc\u0026#34;, # type: \u0026#34;now_utc\u0026#34;, # }, # { # name: \u0026#34;now_utc_lite\u0026#34;, # type: \u0026#34;now_utc_lite\u0026#34;, # }, # { # name: \u0026#34;now_unix\u0026#34;, # type: \u0026#34;now_unix\u0026#34;, # }, # { # name: \u0026#34;now_with_format\u0026#34;, # type: \u0026#34;now_with_format\u0026#34;, # // https://programming.guide/go/format-parse-string-time-date-example.html # format: \u0026#34;2006-01-02T15:04:05-0700\u0026#34;, # }, # { # name: \u0026#34;suffix\u0026#34;, # type: \u0026#34;range\u0026#34;, # from: 10, # to: 1000, # }, # { # name: \u0026#34;bool\u0026#34;, # type: \u0026#34;range\u0026#34;, # from: 0, # to: 1, # }, # { # name: \u0026#34;list\u0026#34;, # type: \u0026#34;list\u0026#34;, # data: [\u0026#34;medcl\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;efg\u0026#34;, \u0026#34;xyz\u0026#34;], # }, # { # name: \u0026#34;id_list\u0026#34;, # type: \u0026#34;random_array\u0026#34;, # variable_type: \u0026#34;number\u0026#34;, // number/string # variable_key: \u0026#34;suffix\u0026#34;, // variable key to get array items # square_bracket: false, # size: 10, // how many items for array # }, # { # name: \u0026#34;str_list\u0026#34;, # type: \u0026#34;random_array\u0026#34;, # variable_type: \u0026#34;number\u0026#34;, // number/string # variable_key: \u0026#34;suffix\u0026#34;, // variable key to get array items # square_bracket: true, # size: 10, // how many items for array # replace: { # // Use \u0026#39; instead of \u0026#34; for string quotes # \u0026#39;\u0026#34;\u0026#39;: \u0026#34;\u0026#39;\u0026#34;, # // Use {} instead of [] as array brackets # \u0026#34;[\u0026#34;: \u0026#34;{\u0026#34;, # \u0026#34;]\u0026#34;: \u0026#34;}\u0026#34;, # }, # }, # ], POST $[[env.ES_ENDPOINT]]/medcl/_search { \u0026quot;track_total_hits\u0026quot;: true, \u0026quot;size\u0026quot;: 0, \u0026quot;query\u0026quot;: { \u0026quot;terms\u0026quot;: { \u0026quot;patent_id\u0026quot;: [ $[[id_list]] ] } } }\nrequest: { runtime_variables: {batch_no: \u0026quot;uuid\u0026quot;}, runtime_body_line_variables: {routing_no: \u0026quot;uuid\u0026quot;}, basic_auth: { username: \u0026quot;$[[env.ES_USERNAME]]\u0026quot;, password: \u0026quot;$[[env.ES_PASSWORD]]\u0026quot;, }, }, 运行模式设置 #\n 默认配置下，Loadgen 会以性能测试模式运行，在指定时间（-d）内重复执行 requests 里的所有请求。如果只需要检查一次测试结果，可以通过 runner.total_rounds 来设置 requests 的执行次数。\nHTTP 响应头处理 #  默认配置下，Loadgen 会自动格式化 HTTP 的响应头（user-agent: xxx -\u0026gt; User-Agent: xxx），如果需要精确判断服务器返回的响应头，可以通过 runner.disable_header_names_normalizing 来禁用这个行为。\n变量的使用 #  上面的配置中，variables 用来定义变量参数，根据 name 来设置变量标识，在构造请求的使用 $[[变量名]] 即可访问该变量的值，变量目前支持的类型有：\n   类型 说明 变量参数     file 文件型外部变量参数 path: 数据文件路径\ndata: 数据列表，会被附加到path文件内容后读取   list 自定义枚举变量参数 data: 字符数组类型的枚举数据列表   sequence 32 位自增数字类型的变量 from: 初始值\nto: 最大值   sequence64 64 位自增数字类型的变量 from: 初始值\nto: 最大值   range 数字范围类型的变量，支持参数 from 和 to 来限制范围 from: 初始值\nto: 最大值   random_array 生成一个随机数组，数据元素来自variable_key指定的变量 variable_key: 数据源变量\nsize: 输出数组的长度\nsquare_bracket: true/false，输出值是否需要[和]\nstring_bracket: 字符串，输出元素前后会附加指定的字符串   uuid UUID 字符类型的变量    now_local 当前时间、本地时区    now_utc 当前时间、UTC 时区。输出格式:2006-01-02 15:04:05.999999999 -0700 MST    now_utc_lite 当前时间、UTC 时区。输出格式:2006-01-02T15:04:05.000    now_unix 当前时间、Unix 时间戳    now_with_format 当前时间，支持自定义 format 参数来格式化时间字符串，如：2006-01-02T15:04:05-0700 format: 输出的时间格式 ( 示例)    变量使用示例 #  file 类型变量参数加载自外部文本文件，每行一个变量参数，访问该变量时每次随机取其中一个，变量里面的定义格式举例如下：\n# test/user.txt medcl elastic 附生成固定长度的随机字符串，如 1024 个字符每行：\nLC_CTYPE=C tr -dc A-Za-z0-9_\\!\\@\\#\\$\\%\\^\\\u0026amp;\\*\\(\\)-+= \u0026lt; /dev/random | head -c 1024 \u0026gt;\u0026gt; 1k.txt 环境变量 #  Loadgen 支持自动读取环境变量，环境变量可以在运行 Loadgen 时通过命令行传入，也可以在 loadgen.dsl 里指定默认的环境变量值，Loadgen 运行时会使用命令行传入的环境变量覆盖 loadgen.dsl 里的默认值。\n配置的环境变量可以通过 $[[env.环境变量]] 来使用：\n#// 配置环境变量默认值 # env: { # ES_USERNAME: \u0026#34;elastic\u0026#34;, # ES_PASSWORD: \u0026#34;elastic\u0026#34;, # ES_ENDPOINT: \u0026#34;http://localhost:8000\u0026#34;, # }, #// 使用运行时变量 GET $[[env.ES_ENDPOINT]]/medcl/_search {\u0026quot;query\u0026quot;: {\u0026quot;match\u0026quot;: {\u0026quot;name\u0026quot;: \u0026quot;$[[user]]\u0026quot;}}}\nrequest: { // 使用运行时变量 basic_auth: { username: \u0026quot;$[[env.ES_USERNAME]]\u0026quot;, password: \u0026quot;$[[env.ES_PASSWORD]]\u0026quot;, }, }, 请求的定义 #\n 配置节点 requests 用来设置 Loadgen 将依次执行的请求，支持固定参数的请求，也可支持模板变量参数化构造请求，以下是一个普通的查询请求：\nGET http://localhost:8000/medcl/_search?q=name:$[[user]] # request: { # username: elastic, # password: pass, # }, 上面的查询对 medcl 索引进行了查询，并对 name 字段执行一个查询，每次请求的值来自随机变量 user。\n模拟批量写入 #  使用 Loadgen 来模拟 bulk 批量写入也非常简单，在请求体里面配置一条索引操作，然后使用 body_repeat_times 参数来随机参数化复制若干条请求即可完成一批请求的准备，如下：\nPOST http://localhost:8000/_bulk {\u0026#34;index\u0026#34;: {\u0026#34;_index\u0026#34;: \u0026#34;medcl-y4\u0026#34;, \u0026#34;_type\u0026#34;: \u0026#34;doc\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;$[[uuid]]\u0026#34;}} {\u0026#34;id\u0026#34;: \u0026#34;$[[id]]\u0026#34;, \u0026#34;field1\u0026#34;: \u0026#34;$[[user]]\u0026#34;, \u0026#34;ip\u0026#34;: \u0026#34;$[[ip]]\u0026#34;, \u0026#34;now_local\u0026#34;: \u0026#34;$[[now_local]]\u0026#34;, \u0026#34;now_unix\u0026#34;: \u0026#34;$[[now_unix]]\u0026#34;} # request: { # basic_auth: { # username: \u0026#34;test\u0026#34;, # password: \u0026#34;testtest\u0026#34;, # }, # body_repeat_times: 1000, # }, 返回值判断 #  每个 requests 配置可以通过 assert 来设置是否需要检查返回值。assert 功能支持 INFINI Gateway 的大部分 条件判断功能。\n 请阅读 《借助 DSL 来简化 Loadgen 配置》来了解更多细节。\n GET http://localhost:8000/medcl/_search?q=name:$[[user]] # request: { # basic_auth: { # username: \u0026#34;test\u0026#34;, # password: \u0026#34;testtest\u0026#34;, # }, # }, # assert: { # _ctx.response.status: 201, # }, 请求返回值可以通过 _ctx 获取，_ctx 目前包含以下信息：\n   参数 说明     _ctx.response.status HTTP 返回状态码   _ctx.response.header HTTP 返回响应头   _ctx.response.body HTTP 返回响应体   _ctx.response.body_json 如果 HTTP 返回响应体是一个有效的 JSON 字符串，可以通过 body_json 来访问 JSON 内容字段   _ctx.elapsed 当前请求发送到返回消耗的时间（毫秒）    如果请求失败（请求地址无法访问等），Loadgen 无法获取 HTTP 请求返回值，Loadgen 会在输出日志里记录 Number of Errors。如果配置了 runner.assert_error 且存在请求失败的请求，Loadgen 会返回 exit(2) 错误码。\n如果返回值不符合判断条件，Loadgen 会停止执行当前轮次后续请求，并在输出日志里记录 Number of Invalid。如果配置了 runner.assert_invalid 且存在判断失败的请求，Loadgen 会返回 exit(1) 错误码。\n动态变量注册 #  每个 requests 配置可以通过 register 来动态添加运行时参数，一个常见的使用场景是根据前序请求的返回值来动态设置后序请求的参数。\n这个示例调用 $[[env.ES_ENDPOINT]]/test 接口获取索引的 UUID，并注册到 index_id 变量。后续的请求定义可以通过 $[[index_id]] 来获取这个值。\nGET $[[env.ES_ENDPOINT]]/test # register: [ # {index_id: \u0026#34;_ctx.response.body_json.test.settings.index.uuid\u0026#34;}, # ], # assert: (200, {}), 执行压测 #  执行 Loadgen 程序即可执行压测，如下:\n$ loadgen -d 30 -c 100 -compress -run loadgen.dsl __ ___ _ ___ ___ __ __ / / /___\\/_\\ / \\/ _ \\ /__\\/\\ \\ \\ / / // ///_\\\\ / /\\ / /_\\//_\\ / \\/ / / /__/ \\_// _ \\/ /_// /_\\\\//__/ /\\ / \\____|___/\\_/ \\_/___,\u0026#39;\\____/\\__/\\_\\ \\/ [LOADGEN] A http load generator and testing suit. [LOADGEN] 1.0.0_SNAPSHOT, 83f2cb9, Sun Jul 4 13:52:42 2021 +0800, medcl, support single item in dict files [07-19 16:15:00] [INF] [instance.go:24] workspace: data/loadgen/nodes/0 [07-19 16:15:00] [INF] [loader.go:312] warmup started [07-19 16:15:00] [INF] [app.go:306] loadgen now started. [07-19 16:15:00] [INF] [loader.go:316] [GET] http://localhost:8000/medcl/_search [07-19 16:15:00] [INF] [loader.go:317] status: 200,\u0026lt;nil\u0026gt;,{\u0026quot;took\u0026quot;:1,\u0026quot;timed_out\u0026quot;:false,\u0026quot;_shards\u0026quot;:{\u0026quot;total\u0026quot;:1,\u0026quot;successful\u0026quot;:1,\u0026quot;skipped\u0026quot;:0,\u0026quot;failed\u0026quot;:0},\u0026quot;hits\u0026quot;:{\u0026quot;total\u0026quot;:{\u0026quot;value\u0026quot;:0,\u0026quot;relation\u0026quot;:\u0026quot;eq\u0026quot;},\u0026quot;max_score\u0026quot;:null,\u0026quot;hits\u0026quot;:[]}} [07-19 16:15:00] [INF] [loader.go:316] [GET] http://localhost:8000/medcl/_search?q=name:medcl [07-19 16:15:00] [INF] [loader.go:317] status: 200,\u0026lt;nil\u0026gt;,{\u0026quot;took\u0026quot;:1,\u0026quot;timed_out\u0026quot;:false,\u0026quot;_shards\u0026quot;:{\u0026quot;total\u0026quot;:1,\u0026quot;successful\u0026quot;:1,\u0026quot;skipped\u0026quot;:0,\u0026quot;failed\u0026quot;:0},\u0026quot;hits\u0026quot;:{\u0026quot;total\u0026quot;:{\u0026quot;value\u0026quot;:0,\u0026quot;relation\u0026quot;:\u0026quot;eq\u0026quot;},\u0026quot;max_score\u0026quot;:null,\u0026quot;hits\u0026quot;:[]}} [07-19 16:15:01] [INF] [loader.go:316] [POST] http://localhost:8000/_bulk [07-19 16:15:01] [INF] [loader.go:317] status: 200,\u0026lt;nil\u0026gt;,{\u0026quot;took\u0026quot;:120,\u0026quot;errors\u0026quot;:false,\u0026quot;items\u0026quot;:[{\u0026quot;index\u0026quot;:{\u0026quot;_index\u0026quot;:\u0026quot;medcl-y4\u0026quot;,\u0026quot;_type\u0026quot;:\u0026quot;doc\u0026quot;,\u0026quot;_id\u0026quot;:\u0026quot;c3qj9123r0okahraiej0\u0026quot;,\u0026quot;_version\u0026quot;:1,\u0026quot;result\u0026quot;:\u0026quot;created\u0026quot;,\u0026quot;_shards\u0026quot;:{\u0026quot;total\u0026quot;:2,\u0026quot;successful\u0026quot;:1,\u0026quot;failed\u0026quot;:0},\u0026quot;_seq_no\u0026quot;:5735852,\u0026quot;_primary_term\u0026quot;:3,\u0026quot;status\u0026quot;:201}}]} [07-19 16:15:01] [INF] [loader.go:325] warmup finished\n5253 requests in 32.756483336s, 524.61KB sent, 2.49MB received\n[Loadgen Client Metrics] Requests/sec:\t175.10 Request Traffic/sec:\t17.49KB Total Transfer/sec:\t102.34KB Avg Req Time:\t5.711022ms Fastest Request:\t440.448µs Slowest Request:\t3.624302658s Number of Errors:\t0 Number of Invalid:\t0 Status 200:\t5253\n[Estimated Server Metrics] Requests/sec:\t160.37 Transfer/sec:\t93.73KB Avg Req Time:\t623.576686ms Loadgen 在正式压测之前会将所有的请求执行一次来进行预热，如果出现错误会提示是否继续，预热的请求结果也会输出到终端，执行完成之后会输出执行的摘要信息。可以通过设置 runner.no_warm 来跳过这个检查阶段。\n 因为 Loadgen 最后的结果是所有请求全部执行完成之后的累计统计，可能存在不准的问题，建议通过打开 Kibana 的监控仪表板来实时查看 Elasticsearch 的各项运行指标。\n 命令行参数 #  Loadgen 会循环执行配置文件里面定义的请求，默认 Loadgen 只会运行 5s 就自动退出了，如果希望延长运行时间或者加大并发可以通过启动的时候设置参数来控制，通过查看帮助命令如下：\n$ loadgen -help Usage of loadgen: -c int Number of concurrent threads (default 1) -compress Compress requests with gzip -config string the location of config file (default \u0026#34;loadgen.yml\u0026#34;) -cpu int the number of CPUs to use (default -1) -d int Duration of tests in seconds (default 5) -debug run in debug mode, loadgen will quit on panic immediately with full stack trace -dial-timeout int Connection dial timeout in seconds, default 3s (default 3) -gateway-log string Log level of Gateway (default \u0026#34;debug\u0026#34;) -l int Limit total requests (default -1) -log string the log level, options: trace,debug,info,warn,error,off -mem int the max size of Memory to use, soft limit in megabyte (default -1) -plugin value load additional plugins -r int Max requests per second (fixed QPS) (default -1) -read-timeout int Connection read timeout in seconds, default 0s (use -timeout) -run string DSL config to run tests (default \u0026#34;loadgen.dsl\u0026#34;) -service string service management, options: install,uninstall,start,stop -timeout int Request timeout in seconds, default 60s (default 60) -v\tversion -write-timeout int Connection write timeout in seconds, default 0s (use -timeout) 限制客户端压力 #  使用 Loadgen 并设置命令行参数 -r 可以限制客户端发送的每秒请求数，从而评估固定压力下 Elasticsearch 的响应时间和负载情况，如下：\nloadgen -d 30 -c 100 -r 100  注意，在大量并发下，此客户端吞吐限制可能不完全准确。\n 限制请求的总条数 #  通过设置参数 -l 可以控制客户端发送的请求总数，从而制造固定的文档，修改配置如下：\n#// loadgen-gw.dsl POST http://localhost:8000/medcl-test/doc2/_bulk {\u0026#34;index\u0026#34;: {\u0026#34;_index\u0026#34;: \u0026#34;medcl-test\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;$[[uuid]]\u0026#34;}} {\u0026#34;id\u0026#34;: \u0026#34;$[[id]]\u0026#34;, \u0026#34;field1\u0026#34;: \u0026#34;$[[user]]\u0026#34;, \u0026#34;ip\u0026#34;: \u0026#34;$[[ip]]\u0026#34;} # request: { # basic_auth: { # username: \u0026#34;test\u0026#34;, # password: \u0026#34;testtest\u0026#34;, # }, # body_repeat_times: 1, # }, 每次请求只有一个文档，然后执行 Loadgen\nloadgen -run loadgen-gw.dsl -d 600 -c 100 -l 50000 执行完成之后，Elasticsearch 的索引 medcl-test 将增加 50000 条记录。\n使用自增 ID 来确保文档的顺序性 #  如果希望生成的文档编号自增有规律，方便进行对比，可以使用 sequence 类型的自增 ID 来作为主键，内容也不要用随机数，如下：\nPOST http://localhost:8000/medcl-test/doc2/_bulk {\u0026#34;index\u0026#34;: {\u0026#34;_index\u0026#34;: \u0026#34;medcl-test\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;$[[id]]\u0026#34;}} {\u0026#34;id\u0026#34;: \u0026#34;$[[id]]\u0026#34;} # request: { # basic_auth: { # username: \u0026#34;test\u0026#34;, # password: \u0026#34;testtest\u0026#34;, # }, # body_repeat_times: 1, # }, 上下文复用变量 #  在一个请求中，我们可能希望有相同的参数出现，比如 routing 参数用来控制分片的路由，同时我们又希望该参数也保存在文档的 JSON 里面， 可以使用 runtime_variables 来设置请求级别的变量，或者 runtime_body_line_variables 定义请求体级别的变量，如果请求体复制 N 份，每份的参数是不同的，举例如下：\n# variables: [ # {name: \u0026#34;id\u0026#34;, type: \u0026#34;sequence\u0026#34;}, # {name: \u0026#34;uuid\u0026#34;, type: \u0026#34;uuid\u0026#34;}, # {name: \u0026#34;now_local\u0026#34;, type: \u0026#34;now_local\u0026#34;}, # {name: \u0026#34;now_utc\u0026#34;, type: \u0026#34;now_utc\u0026#34;}, # {name: \u0026#34;now_unix\u0026#34;, type: \u0026#34;now_unix\u0026#34;}, # {name: \u0026#34;suffix\u0026#34;, type: \u0026#34;range\u0026#34;, from: 10, to 15}, # ], POST http://192.168.3.188:9206/_bulk {\u0026quot;create\u0026quot;: {\u0026quot;_index\u0026quot;: \u0026quot;test-$[[suffix]]\u0026quot;, \u0026quot;_type\u0026quot;: \u0026quot;doc\u0026quot;, \u0026quot;_id\u0026quot;: \u0026quot;$[[uuid]]\u0026quot;, \u0026quot;routing\u0026quot;: \u0026quot;$[[routing_no]]\u0026quot;}} {\u0026quot;id\u0026quot;: \u0026quot;$[[uuid]]\u0026quot;, \u0026quot;routing_no\u0026quot;: \u0026quot;$[[routing_no]]\u0026quot;, \u0026quot;batch_number\u0026quot;: \u0026quot;$[[batch_no]]\u0026quot;, \u0026quot;random_no\u0026quot;: \u0026quot;$[[suffix]]\u0026quot;, \u0026quot;ip\u0026quot;: \u0026quot;$[[ip]]\u0026quot;, \u0026quot;now_local\u0026quot;: \u0026quot;$[[now_local]]\u0026quot;, \u0026quot;now_unix\u0026quot;: \u0026quot;$[[now_unix]]\u0026quot;}\nrequest: { runtime_variables: { batch_no: \u0026quot;id\u0026quot;, }, runtime_body_line_variables: { routing_no: \u0026quot;uuid\u0026quot;, }, basic_auth: { username: \u0026quot;ingest\u0026quot;, password: \u0026quot;password\u0026quot;, }, body_repeat_times: 10, }, 我们定义了 batch_no　变量来代表一批文档里面的相同批次号，同时又定义了　routing_no　变量来代表每个文档级别的 routing 值。\n自定义 Header #  GET http://localhost:8000/test/_search # request: { # headers: [ # {Agent: \u0026#34;Loadgen-1\u0026#34;}, # ], # disable_header_names_normalizing: false, # }, 默认配置下，Loadgen 会自动格式化配置里的 HTTP 的请求头（user-agent: xxx -\u0026gt; User-Agent: xxx），如果需要精确设置 HTTP 请求头，可以通过设置 disable_header_names_normalizing: true 来禁用这个行为。\n运行测试套件 #  Loadgen 支持批量运行测试用例，不需要重复编写测试用例，通过切换套件配置来快速测试不同的环境配置：\n# loadgen.yml env: # Set up envrionments to run test suite LR_TEST_DIR: ./testing # The path to the test cases. # If you want to start gateway dynamically and automatically: LR_GATEWAY_CMD: ./bin/gateway # The path to the executable of INFINI Gateway LR_GATEWAY_HOST: 0.0.0.0:18000 # The binding host of the INFINI Gateway LR_GATEWAY_API_HOST: 0.0.0.0:19000 # The binding host of the INFINI Gateway API server # Set up other envrionments for the gateway and loadgen LR_ELASTICSEARCH_ENDPOINT: http://localhost:19201 CUSTOM_ENV: myenv tests: # The relative path of test cases under `LR_TEST_DIR` # # - gateway.yml: (Optional) the configuration to start the INFINI Gateway dynamically. # - loadgen.dsl: the configuration to run the loadgen tool. # # The environments set in `env` section will be passed to the INFINI Gateway and loadgen. - path: cases/gateway/echo/echo_with_context 环境变量配置 #  Loadgen 通过环境变量来动态配置 INFINI Gateway，环境变量在 env 里指定。以下环境变量是必选的：\n   变量名 说明     LR_TEST_DIR 测试用例所在目录    如果你需要 loadgen 根据配置动态启动 INFINI Gateway，需要设置以下环境变量：\n   变量名 说明     LR_GATEWAY_CMD INFINI Gateway 可执行文件的路径   LR_GATEWAY_HOST INFINI Gateway 绑定的主机名:端口   LR_GATEWAY_API_HOST INFINI Gateway API 绑定的主机名:端口    测试用例配置 #  测试用例在 tests 里配置，每个路径（path）指向一个测试用例的目录，每个测试用例需要配置一份 gateway.yml（可选）和 loadgen.dsl。配置文件可以使用 env 下配置的环境变量（$[[env.ENV_KEY]]）。\ngateway.yml 参考配置：\npath.data: data path.logs: log entry:\n name: my_es_entry enabled: true router: my_router max_concurrency: 200000 network: binding: $[[env.LR_GATEWAY_HOST]]  flow:\n name: hello_world filter:  echo: message: \u0026quot;hello world\u0026quot; router:   name: my_router default_flow: hello_world loadgen.dsl 参考配置：\n  # runner: { # total_rounds: 1, # no_warm: true, # log_requests: true, # assert_invalid: true, # assert_error: true, # }, GET http://$[[env.LR_GATEWAY_HOST]]/ # assert: { # _ctx.response: { # status: 200, # body: \u0026quot;hello world\u0026quot;, # }, # }, 测试套件运行 #\n 配置好测试 loadgen.yml 后，可以通过以下命令运行 Loadgen：\nloadgen -config loadgen.yml Loadgen 会运行配置指定的所有测试用例，并输出测试结果：\n$ loadgen -config loadgen.yml __ ___ _ ___ ___ __ __ / / /___\\/_\\ / \\/ _ \\ /__\\/\\ \\ \\ / / // ///_\\\\ / /\\ / /_\\//_\\ / \\/ / / /__/ \\_// _ \\/ /_// /_\\\\//__/ /\\ / \\____|___/\\_/ \\_/___,\u0026#39;\\____/\\__/\\_\\ \\/ [LOADGEN] A http load generator and testing suit. [LOADGEN] 1.0.0_SNAPSHOT, 83f2cb9, Sun Jul 4 13:52:42 2021 +0800, medcl, support single item in dict files [02-21 10:50:05] [INF] [app.go:192] initializing loadgen [02-21 10:50:05] [INF] [app.go:193] using config: /Users/kassian/Workspace/infini/src/infini.sh/testing/suites/dev.yml [02-21 10:50:05] [INF] [instance.go:78] workspace: /Users/kassian/Workspace/infini/src/infini.sh/testing/data/loadgen/nodes/cfpihf15k34iqhpd4d00 [02-21 10:50:05] [INF] [app.go:399] loadgen is up and running now. [2023-02-21 10:50:05][TEST][SUCCESS] [setup/loadgen/cases/dummy] duration: 105(ms)\n1 requests in 68.373875ms, 0.00bytes sent, 0.00bytes received\n[Loadgen Client Metrics] Requests/sec:\t0.20 Request Traffic/sec:\t0.00bytes Total Transfer/sec:\t0.00bytes Avg Req Time:\t5s Fastest Request:\t68.373875ms Slowest Request:\t68.373875ms Number of Errors:\t0 Number of Invalid:\t0 Status 200:\t1\n[Estimated Server Metrics] Requests/sec:\t14.63 Transfer/sec:\t0.00bytes Avg Req Time:\t68.373875ms\n[2023-02-21 10:50:06][TEST][FAILED] [setup/gateway/cases/echo/echo_with_context/] duration: 1274(ms) #0 request, GET http://$[[env.LR_GATEWAY_HOST]]/any/, assertion failed, skiping subsequent requests 1 requests in 1.255678s, 0.00bytes sent, 0.00bytes received\n[Loadgen Client Metrics] Requests/sec:\t0.20 Request Traffic/sec:\t0.00bytes Total Transfer/sec:\t0.00bytes Avg Req Time:\t5s Fastest Request:\t1.255678s Slowest Request:\t1.255678s Number of Errors:\t1 Number of Invalid:\t1 Status 0:\t1\n[Estimated Server Metrics] Requests/sec:\t0.80 Transfer/sec:\t0.00bytes Avg Req Time:\t1.255678s\n\n","subcategory":null,"summary":"","tags":null,"title":"性能测试","url":"/loadgen/v1.29.1/zh/docs/getting-started/benchmark/"},{"category":null,"content":"安装 INFINI Loadgen #  INFINI Loadgen 支持主流的操作系统和平台，程序包很小，没有任何额外的外部依赖，安装起来应该是很快的 ：）\n下载安装 #  自动安装\ncurl -sSL http://get.infini.cloud | bash -s -- -p loadgen 通过以上脚本可自动下载相应平台的 loadgen 最新版本并解压到/opt/loadgen\n脚本的可选参数如下：\n -v [版本号]（默认采用最新版本号）\n-d [安装目录]（默认安装到/opt/loadgen）\n ➜ /tmp mkdir loadgen ➜ /tmp curl -sSL http://get.infini.cloud | bash -s -- -p loadgen -d /tmp/loadgen  @@@@@@@@@@@ @@@@@@@@@@@@ @@@@@@@@@@@@ @@@@@@@@@\u0026amp;amp;@@@ \u0026lt;span style=\u0026quot;color:#75715e\u0026quot;\u0026gt;#@@@@@@@@@@@@@\u0026lt;/span\u0026gt; @@@ @@@@@@@@@@@@@ \u0026amp;amp;@@@@@@@ \u0026amp;amp;@@@@@@@@@@@@@ @\u0026amp;amp;@@@@@@@\u0026amp;amp;@ @@@\u0026amp;amp;@@@@@@@\u0026amp;amp;@ @@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@\u0026amp;amp; @@@@@@@@@@@@@ %@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@\u0026amp;amp;@@@@@@@@@@@@@@@ @@ ,@@@@@@@@@@@@@@@@@@@@@@@\u0026amp;amp; @@@@@. @@@@@\u0026amp;amp;@@@@@@@@@@@@@@  @@@@@@@@@@ @@@@@@@@@@@@@@@# @\u0026amp;@@@\u0026amp;@@@\u0026amp;@@@ \u0026amp;@\u0026amp;@@@\u0026amp;@@@\u0026amp;@ @@@@@@@@@@@@@. @@@@@@@* @@@@@@@@@@@@@ %@@@ @@@@@@@@@@@@@ /@@@@@@@\u0026amp;@@@@@ @@@@@@@@@@@@@ @@@@@@@@@@@@@ @@@@@@@@@@@@ Welcome to INFINI Labs!\nNow attempting the installation\u0026hellip;\nName: [loadgen], Version: [1.26.1-598], Path: [/tmp/loadgen] File: [https://release.infinilabs.com/loadgen/stable/loadgen-1.26.1-598-mac-arm64.zip] ##=O#- #\nInstallation complete. [loadgen] is ready to use!\n cd /tmp/loadgen \u0026amp;\u0026amp; ./loadgen-mac-arm64  / // |/ // __// // |/ // / / // || // / / // || // / ////|/// ////|//_/\n©INFINI.LTD, All Rights Reserved. 手动安装\n根据您所在的操作系统和平台选择下面相应的下载地址：\n https://release.infinilabs.com/loadgen/\n","subcategory":null,"summary":"","tags":null,"title":"下载安装","url":"/loadgen/v1.29.1/zh/docs/getting-started/install/"}]