<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>文档与数据建模 on INFINI Easysearch (main)</title><link>/easysearch/main/docs/best-practices/data-modeling/</link><description>Recent content in 文档与数据建模 on INFINI Easysearch (main)</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/main/docs/best-practices/data-modeling/index.xml" rel="self" type="application/rss+xml"/><item><title>文档设计</title><link>/easysearch/main/docs/best-practices/data-modeling/document-design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/best-practices/data-modeling/document-design/</guid><description>文档设计 # 这一页回答两个问题：应该把什么放进一个文档？字段怎么设计才适合搜索？ 这里聚焦单个文档层面的建模，跨文档关系（Nested、Parent-Child、反范式）放在后续章节。
什么是文档 # 在 Easysearch 中，一个 文档（Document） 是被序列化为 JSON 的最顶层对象，指定了唯一 ID 并存储到 Easysearch 中。例如：
{ &amp;#34;name&amp;#34;: &amp;#34;John Smith&amp;#34;, &amp;#34;age&amp;#34;: 42, &amp;#34;confirmed&amp;#34;: true, &amp;#34;join_date&amp;#34;: &amp;#34;2014-06-01&amp;#34;, &amp;#34;home&amp;#34;: { &amp;#34;lat&amp;#34;: 51.5, &amp;#34;lon&amp;#34;: 0.1 }, &amp;#34;accounts&amp;#34;: [ { &amp;#34;type&amp;#34;: &amp;#34;facebook&amp;#34;, &amp;#34;id&amp;#34;: &amp;#34;johnsmith&amp;#34; }, { &amp;#34;type&amp;#34;: &amp;#34;twitter&amp;#34;, &amp;#34;id&amp;#34;: &amp;#34;johnsmith&amp;#34; } ] } 文档可以包含字符串、数字、布尔、日期、嵌套对象、数组等多种类型。
文档元数据 # 每个文档都有三个核心元数据：
元数据 说明 _index 文档存放的索引，是逻辑命名空间 _id 文档的唯一标识符，可自定义或自动生成 _source 文档的原始 JSON 内容 此外，每个文档还有 _version 字段——每次对文档修改（包括删除）时版本号递增，用于并发控制。</description></item><item><title>Mapping 模式与最佳实践</title><link>/easysearch/main/docs/best-practices/data-modeling/mapping-patterns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/best-practices/data-modeling/mapping-patterns/</guid><description>Mapping 模式与最佳实践 # 在理解了 Mapping 基础之后，本页给出几种最常用、最实用的 Mapping 设计模式，帮助你避免常见坑。
复杂数据类型：数组、对象与内部对象 # 多值字段（数组） # 任何字段都可以包含多个值，以数组形式索引：
{ &amp;#34;tag&amp;#34;: [ &amp;#34;search&amp;#34;, &amp;#34;nosql&amp;#34; ] } 要点：
数组中所有值必须是相同数据类型（不能混用日期和字符串） 如果通过索引数组创建新字段，Easysearch 会用第一个值的数据类型作为字段类型 数组在索引时被处理为“多值字段”，可以搜索，但无序 搜索时不能指定“第一个”或“最后一个”元素 注意：从 Easysearch 获取文档时，_source 中的数组顺序与索引时一致；但索引层面是无序的，可以把数组想象成“装在袋子里的值”。
空字段 # 以下三种情况被认为是空字段，不会被索引：
{ &amp;#34;null_value&amp;#34;: null, &amp;#34;empty_array&amp;#34;: [], &amp;#34;array_with_null_value&amp;#34;: [ null ] } 在 Lucene 中不能存储 null 值，所以空字段等同于不存在。
内部对象（嵌套对象） # JSON 支持嵌套对象，例如：
{ &amp;#34;tweet&amp;#34;: &amp;#34;Easysearch is very flexible&amp;#34;, &amp;#34;user&amp;#34;: { &amp;#34;id&amp;#34;: &amp;#34;@johnsmith&amp;#34;, &amp;#34;gender&amp;#34;: &amp;#34;male&amp;#34;, &amp;#34;age&amp;#34;: 26, &amp;#34;name&amp;#34;: { &amp;#34;full&amp;#34;: &amp;#34;John Smith&amp;#34;, &amp;#34;first&amp;#34;: &amp;#34;John&amp;#34;, &amp;#34;last&amp;#34;: &amp;#34;Smith&amp;#34; } } } Easysearch 会自动将内部对象映射为 object 类型，并在 properties 下列出内部字段：</description></item><item><title>反范式与权衡</title><link>/easysearch/main/docs/best-practices/data-modeling/denormalization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/best-practices/data-modeling/denormalization/</guid><description>反范式与权衡 # 在关系型数据库中，规范化（范式）是黄金法则。但在 Easysearch 这样的搜索系统中，反范式（denormalization）往往是更好的选择。本页解释为什么，以及如何在一致性和性能之间做权衡。
搜索系统中的规范化与冗余 # 与传统数据库&amp;quot;强规范化&amp;quot;不同，面向搜索的文档往往会有适度冗余：
预先把常用的派生信息存进文档（如标准化后的地区名、拼音、缩写） 把查询高频的外键信息&amp;quot;带过来&amp;quot;，减少查询时的 join 需求 但冗余也要有边界：
冗余会放大存储与更新成本 冗余字段过多，会让 mapping 变得臃肿、难以维护 经验做法：
只冗余&amp;quot;确实会被高频查询/排序/聚合&amp;quot;的字段 对变动频率极高的冗余信息，要慎重评估更新成本 为什么需要反范式？ # 使用 Easysearch 得到最好搜索性能的方法是有目的地在索引时进行反范式。对每个文档保持一定数量的冗余副本可以在需要访问时避免进行关联操作。
示例：博客文章与用户 # 如果我们希望通过用户姓名找到他写的博客文章，可以在博客文档中包含这个用户的姓名：
PUT /my_index/_doc/1 { &amp;#34;name&amp;#34;: &amp;#34;John Smith&amp;#34;, &amp;#34;email&amp;#34;: &amp;#34;john@smith.com&amp;#34;, &amp;#34;dob&amp;#34;: &amp;#34;1970/10/24&amp;#34; } PUT /my_index/_doc/2 { &amp;#34;title&amp;#34;: &amp;#34;Relationships&amp;#34;, &amp;#34;body&amp;#34;: &amp;#34;It&amp;#39;s complicated...&amp;#34;, &amp;#34;user&amp;#34;: { &amp;#34;id&amp;#34;: 1, &amp;#34;name&amp;#34;: &amp;#34;John Smith&amp;#34; } } 通过单次查询就能找到用户 John 的博客文章：
GET /my_index/_search { &amp;#34;query&amp;#34;: { &amp;#34;bool&amp;#34;: { &amp;#34;must&amp;#34;: [ { &amp;#34;match&amp;#34;: { &amp;#34;title&amp;#34;: &amp;#34;relationships&amp;#34; }}, { &amp;#34;match&amp;#34;: { &amp;#34;user.</description></item><item><title>Nested 建模</title><link>/easysearch/main/docs/best-practices/data-modeling/nested/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/best-practices/data-modeling/nested/</guid><description>Nested 建模 # Nested 解决的是这样一种典型需求：数组里是一组对象，而不是一堆无关字段的拼接，查询时既要对数组元素内部做精确匹配，又不想被&amp;quot;笛卡尔积假匹配&amp;quot;坑到。
什么时候需要 nested？ # 先看一个常见例子：订单里有多条明细 items：
{ &amp;#34;order_id&amp;#34;: &amp;#34;O-1&amp;#34;, &amp;#34;items&amp;#34;: [ { &amp;#34;sku&amp;#34;: &amp;#34;A&amp;#34;, &amp;#34;price&amp;#34;: 100, &amp;#34;qty&amp;#34;: 1 }, { &amp;#34;sku&amp;#34;: &amp;#34;B&amp;#34;, &amp;#34;price&amp;#34;: 200, &amp;#34;qty&amp;#34;: 2 } ] } 如果你把 items.sku、items.price、items.qty 都当成普通多值字段：
items.sku = [&amp;ldquo;A&amp;rdquo;, &amp;ldquo;B&amp;rdquo;] items.price = [100, 200] items.qty = [1, 2] 此时一个查询：
items.sku = &amp;quot;A&amp;quot; 且 items.price = 200 在&amp;quot;扁平多值字段&amp;quot;模型下是会命中的（因为它只在每个字段内部看是否包含该值），但现实里并不存在 sku=A 且 price=200 这一条明细。这就是经典的&amp;quot;笛卡尔积假匹配&amp;quot;。
要避免这种问题，就需要 nested。
如何定义 nested 字段 # 在 Mapping 中，把数组元素声明为 nested 类型（示意）：</description></item><item><title>向量字段建模</title><link>/easysearch/main/docs/best-practices/data-modeling/vector-fields/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/best-practices/data-modeling/vector-fields/</guid><description>向量字段建模 # 概述 # 向量字段是实现语义搜索（向量/kNN 搜索）的基础设施。本指南覆盖 Easysearch 中向量字段的设计原则、存储优化、性能权衡，帮助你做出合理的架构决策。
核心出发点： 向量字段的设计直接影响三个维度——存储成本、索引性能、查询效率。在业务约束下找到最优平衡是关键。
1. 文档模型设计 # 1.1 基本模式：混合字段设计 # 在支持语义搜索的系统中，典型文档包含三类字段：
{ &amp;#34;_id&amp;#34;: &amp;#34;doc-001&amp;#34;, &amp;#34;metadata&amp;#34;: { &amp;#34;title&amp;#34;: &amp;#34;Easysearch 向量搜索最佳实践&amp;#34;, &amp;#34;created_at&amp;#34;: &amp;#34;2026-02-13&amp;#34;, &amp;#34;category&amp;#34;: &amp;#34;AI搜索&amp;#34; }, &amp;#34;content&amp;#34;: &amp;#34;完整的正文内容……&amp;#34;, &amp;#34;embedding&amp;#34;: [0.124, -0.031, 0.092, ...], &amp;#34;snippet&amp;#34;: &amp;#34;用于快速展示的摘要&amp;#34; } 字段分工：
字段类型 典型字段名 数据类型 用途 存储开销 文本字段 title, content text BM25 全文搜索、分面过滤 低 元数据字段 created_at, category keyword, date 精确过滤、排序、聚合 低 向量字段 embedding, vector dense_vector kNN 语义相似度查询 高 展示字段 snippet, summary text（不分词） 快速返回、避免重查询 中 设计要点：</description></item><item><title>Parent-Child 建模</title><link>/easysearch/main/docs/best-practices/data-modeling/parent-child/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/best-practices/data-modeling/parent-child/</guid><description>Parent-Child 建模 # Parent-Child 用来表达&amp;quot;两个文档属于不同类型/生命周期，但又需要建立关联&amp;quot;的场景。相比 nested，它更适合父文档频繁变化 / 子文档数量较多 / 生命周期不同步的情况。
什么时候考虑 Parent-Child？ # 典型场景：
主资源 + 活动记录：例如用户（父）+ 多条行为日志/评论（子） 订单 + 物流/状态变更记录：订单比较稳定，状态记录会持续追加 文档 + 标签/评分：标签或评分变化频率远高于主体文档 这类关系有几个共同特点：
父/子文档生命周期不同步（子可以频繁新增/删除，父相对稳定） 子文档数量可能很多，如果全部嵌入父文档会让父文档变得非常庞大 查询时既可能只查子文档，也可能需要&amp;quot;从父找子&amp;quot;或&amp;quot;从子找父&amp;quot; Parent-Child 与 Nested 的对比 # 可以用下面的方式做一个快速选择：
更适合 Nested 的情况：
子元素数量有限，整体更新成本可接受 查询几乎总是&amp;quot;连带父文档一起看&amp;quot; 不需要单独对&amp;quot;子&amp;quot;做大规模搜索或独立生命周期管理 更适合 Parent-Child 的情况：
子元素数量较多，且经常新增/删除 子文档需要独立参与搜索与统计 父/子有不同的更新/存储策略 Nested 更像&amp;quot;文档内部的结构&amp;quot;， Parent-Child 更像&amp;quot;两个文档集合之间的引用关系&amp;quot;。
建模要点（概念级） # 底层上，父文档与子文档都存储在同一个索引中，通过一个&amp;quot;连接字段&amp;quot;来描述父/子的关系：</description></item><item><title>时间序列建模</title><link>/easysearch/main/docs/best-practices/data-modeling/time-series/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/best-practices/data-modeling/time-series/</guid><description>时间序列建模 # 时间序列数据（如日志、指标、事件流）是 Easysearch 的常见用例。这类数据有几个特点：文档数量快速增长、基本不更新、主要查询最近的数据。本页介绍如何为时间序列数据设计索引结构。
时间序列数据的特点 # 与传统的搜索场景不同，时间序列数据有以下特点：
文档数量快速增长：日志、指标等数据持续写入，不会停顿 文档基本不更新：写入后很少修改，主要是追加 查询集中在最近数据：大多数查询关注最近几小时、几天或几周的数据 旧数据逐渐失去价值：随着时间推移，旧数据的查询频率降低 按时间范围索引 # 如果我们为此种类型的文档建立一个超大索引，我们可能会很快耗尽存储空间。日志事件会不断的进来，不会停顿也不会中断。
我们可以使用 scroll 查询和批量删除来删除旧的事件。但这种方法非常低效。当你删除一个文档，它只会被标记为被删除。在包含它的段被合并之前不会被物理删除。
替代方案是，我们使用一个时间范围索引。你可以着手于一个按年的索引 (logs_2014) 或按月的索引 (logs_2014-10)。也许当你的数据变得十分繁忙时，你需要切换到一个按天的索引 (logs_2014-10-24)。删除旧数据十分简单：只需要删除旧的索引。
这种方法有这样的优点，允许你在需要的时候进行扩容。你不需要预先做任何艰难的决定。每天都是一个新的机会来调整你的索引时间范围来适应当前需求。
应用相同的逻辑到决定每个索引的大小上。起初也许你需要的仅仅是每周一个主分片。过一阵子，也许你需要每天五个主分片。这都不重要——任何时间你都可以调整到新的环境。
使用别名管理时间序列索引 # 别名可以帮助我们更加透明地在索引间切换。当创建索引时，你可以将 logs_current 指向当前索引来接收新的日志事件，当检索时，更新 last_3_months 来指向所有最近三个月的索引：
POST /_aliases { &amp;#34;actions&amp;#34;: [ { &amp;#34;add&amp;#34;: { &amp;#34;alias&amp;#34;: &amp;#34;logs_current&amp;#34;, &amp;#34;index&amp;#34;: &amp;#34;logs_2014-10&amp;#34; }}, { &amp;#34;remove&amp;#34;: { &amp;#34;alias&amp;#34;: &amp;#34;logs_current&amp;#34;, &amp;#34;index&amp;#34;: &amp;#34;logs_2014-09&amp;#34; }}, { &amp;#34;add&amp;#34;: { &amp;#34;alias&amp;#34;: &amp;#34;last_3_months&amp;#34;, &amp;#34;index&amp;#34;: &amp;#34;logs_2014-10&amp;#34; }}, { &amp;#34;remove&amp;#34;: { &amp;#34;alias&amp;#34;: &amp;#34;last_3_months&amp;#34;, &amp;#34;index&amp;#34;: &amp;#34;logs_2014-07&amp;#34; }} ] } 这样，写入操作始终使用 logs_current 别名，查询操作可以使用 last_3_months 别名来查询最近三个月的数据。</description></item><item><title>多租户建模</title><link>/easysearch/main/docs/best-practices/data-modeling/multi-tenancy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/best-practices/data-modeling/multi-tenancy/</guid><description>多租户建模 # 多租户（Multi-tenancy）是指多个用户或组织共享同一个 Easysearch 集群，但各自的数据需要隔离。本页介绍多租户场景下的索引设计、路由策略和容量规划思路。
多租户的两种主要模式 # 模式一：一个用户一个索引 # 通常来说，用户使用 Easysearch 的原因是他们需要添加全文检索或者需要分析一个已经存在的应用。他们创建一个索引来存储所有文档。公司里的其他人也逐渐发现了 Easysearch 带来的好处，也想把他们的数据添加到 Easysearch 中去。
幸运的是，Easysearch 支持多租户，所以每个用户可以在相同的集群中拥有自己的索引。有人偶尔会想要搜索所有用户的文档，这种情况可以通过搜索所有索引实现，但大多数情况下用户只关心它们自己的文档。
一些用户有着比其他人更多的文档，一些用户可能有比其他人更多的搜索次数，所以这种对指定每个索引主分片和副本分片数量能力的需要应该很适合使用&amp;quot;一个用户一个索引&amp;quot;的模式。类似地，较为繁忙的索引可以通过分片分配过滤指定到高配的节点。
提示：不要为每个索引都使用默认的主分片数。想想看它需要存储多少数据。有可能你仅需要一个分片——再多的都只是浪费资源。
大多数 Easysearch 的用户读到这里就已经够了。简单的&amp;quot;一个用户一个索引&amp;quot;对大多数场景都可以满足了。
模式二：共享索引 + 过滤 # 对于例外的场景，你可能会发现需要支持很大数量的用户，都是相似的需求。一个例子可能是为一个拥有几千个邮箱账户的论坛提供搜索服务。一些论坛可能有巨大的流量，但大多数都很小。将一个有着单个分片的索引用于一个小规模论坛已经是足够的了——一个分片可以承载很多个论坛的数据。
我们需要的是一种可以在用户间共享资源的方法，给每个用户他们拥有自己的索引这种印象，而不在小用户上浪费资源。
共享索引的实现 # 我们可以为许多的小用户使用一个大的共享的索引，将用户标识索引进一个字段并且将它用作一个过滤器：
PUT /forums { &amp;#34;settings&amp;#34;: { &amp;#34;number_of_shards&amp;#34;: 10 }, &amp;#34;mappings&amp;#34;: { &amp;#34;properties&amp;#34;: { &amp;#34;forum_id&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;keyword&amp;#34; }, &amp;#34;title&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;text&amp;#34; } } } } PUT /forums/_doc/1 { &amp;#34;forum_id&amp;#34;: &amp;#34;baking&amp;#34;, &amp;#34;title&amp;#34;: &amp;#34;Easy recipe for ginger nuts&amp;#34;, .</description></item></channel></rss>