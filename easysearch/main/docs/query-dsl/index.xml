<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>查询 DSL on INFINI Easysearch</title><link>/easysearch/main/docs/query-dsl/</link><description>Recent content in 查询 DSL on INFINI Easysearch</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/main/docs/query-dsl/index.xml" rel="self" type="application/rss+xml"/><item><title>全匹配查询</title><link>/easysearch/main/docs/query-dsl/match-all/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/query-dsl/match-all/</guid><description>全匹配查询 # match_all 查询返回所有文档。如果需要返回整个文档集，这个查询在测试大量文档集时很有用。
GET _search { &amp;quot;query&amp;quot;: { &amp;quot;match_all&amp;quot;: {} } } match_all 查询有一个 match_none 的对应查询，这个对应查询很少有用：
GET _search { &amp;quot;query&amp;quot;: { &amp;quot;match_none&amp;quot;: {} } } 参数说明 # 全匹配和全不匹配查询都接受以下参数。所有参数都是可选的。
参数 数据类型 描述 boost Float 一个浮点数值，用于指定该字段对相关性分数的权重。大于 1.0 的值会增加字段的权重。介于 0.0 和 1.0 之间的值会降低字段的权重。默认值为 1.0。 _name String 用于查询标签的查询名称。可选。</description></item><item><title>最小匹配</title><link>/easysearch/main/docs/query-dsl/minimum-should-match/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/query-dsl/minimum-should-match/</guid><description>最小匹配 # minimum_should_match 参数可用于全文搜索，并指定文档必须匹配的最小词项数量才能在搜索结果中返回。
以下示例要求文档至少匹配三个搜索词中的两个才能作为搜索结果返回：
GET /shakespeare/_search { &amp;quot;query&amp;quot;: { &amp;quot;match&amp;quot;: { &amp;quot;text_entry&amp;quot;: { &amp;quot;query&amp;quot;: &amp;quot;prince king star&amp;quot;, &amp;quot;minimum_should_match&amp;quot;: &amp;quot;2&amp;quot; } } } } 在这个示例中，查询有三个可选子句，它们通过 OR 结合，因此文档必须匹配 prince 和 king ，或者 prince 和 star ，或者 king 和 star 。
参数值说明 # 您可以指定 minimum_should_match 参数为以下值之一。
值类型 示例 描述 非负整数 2 一个文档必须匹配这个数量的可选子句。 负整数 -1 一个文档必须匹配可选子句总数减去这个数。 非负百分比 70% 一个文档必须匹配可选子句总数的这个百分比。要匹配的子句数向下取整到最接近的整数。 负百分比 -30% 一个文档可以有这个百分比的不匹配的可选子句。文档允许不匹配的子句数向下取整到最接近的整数。 组合 2&amp;lt;75% n&amp;lt;p% 格式的表达式。如果可选子句的数量小于或等于 n ，文档必须匹配所有可选子句。如果可选子句的数量大于 n ，则文档必须匹配 p 百分比的可选子句。 多种组合 3&amp;lt;-1 5&amp;lt;50% 用空格分隔的多个组合。每个条件适用于 &amp;lt; 符号左侧数字更多的可选子句数量。在这个例子中，如果有三个或更少可选子句，文档必须匹配所有它们。如果有四或五个可选子句，文档必须匹配所有但一个。如果有 6 个或更多可选子句，文档必须匹配 50% 的它们。 设 n 为文档必须匹配的可选子句数量。当 n 计算为百分比时，如果 n 小于 1，则使用 1。如果 n 大于可选子句的数量，则使用可选子句的数量。</description></item><item><title>查询和过滤上下文</title><link>/easysearch/main/docs/query-dsl/query-filter-context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/query-dsl/query-filter-context/</guid><description>查询和过滤上下文 # 查询由查询子句组成，这些子句可以在过滤（filter）上下文或查询上下文中运行。 在过滤（filter）上下文中的查询子句会询问“文档是否匹配查询子句？”并返回匹配的文档。在查询上下文中的查询子句会询问“文档与查询子句匹配程度如何？”，返回匹配的文档，并以相关性分数的形式提供每个文档的相关性。
相关性分数 # 相关性分数衡量文档与查询的匹配程度。它是一个正浮点数，Easysearch 会记录在每个文档的 _score 元数据字段中：
&amp;quot;hits&amp;quot; : [ { &amp;quot;_index&amp;quot; : &amp;quot;shakespeare&amp;quot;, &amp;quot;_id&amp;quot; : &amp;quot;32437&amp;quot;, &amp;quot;_score&amp;quot; : 18.781435, &amp;quot;_source&amp;quot; : { &amp;quot;type&amp;quot; : &amp;quot;line&amp;quot;, &amp;quot;line_id&amp;quot; : 32438, &amp;quot;play_name&amp;quot; : &amp;quot;Hamlet&amp;quot;, &amp;quot;speech_number&amp;quot; : 3, &amp;quot;line_number&amp;quot; : &amp;quot;1.1.3&amp;quot;, &amp;quot;speaker&amp;quot; : &amp;quot;BERNARDO&amp;quot;, &amp;quot;text_entry&amp;quot; : &amp;quot;Long live the king!&amp;quot; } }, ... 一个更高的分数表示文档更相关。虽然不同的查询类型计算相关性分数的方式不同，但所有查询类型都会考虑查询子句是在过滤（filter）上下文还是查询上下文中运行。
在查询上下文中使用你想影响相关性分数的查询子句，并在过滤（filter）上下文中使用所有其他查询子句。
过滤上下文 # 在过滤上下文中的查询子句会问“文档是否匹配查询子句？”，这个问题有二元答案。例如，如果你有一个包含学生数据的索引，你可以使用过滤上下文来回答以下关于学生的疑问:
学生的 honors 状态是否设置为 true ？ 学生的 graduation_year 是否在 2020–2022 范围内？ 使用过滤上下文时，Easysearch 会返回匹配的文档，而不会计算相关性分数。因此，您应该使用过滤上下文来处理具有精确值的字段。</description></item><item><title>正则表达式语法</title><link>/easysearch/main/docs/query-dsl/regex-syntax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/query-dsl/regex-syntax/</guid><description>正则表达式语法 # 正则表达式（regex）是一种使用特殊符号和运算符定义搜索模式的方法。这些模式允许你在字符串中匹配字符序列。
在 Easysearch 中，你可以在以下查询类型中使用正则表达式：
regexp query_string Easysearch 使用 Apache Lucene 正则表达式引擎，该引擎有自己的语法和限制。它不使用 Perl 兼容正则表达式（PCRE），因此某些熟悉的正则表达式功能可能会表现不同或不受支持。
在 regexp 和 query_string 查询之间进行选择 # regexp 和 query_string 查询都支持正则表达式，但它们的行为不同，适用于不同的使用场景。
特性 regexp 查询 query_string 查询 模式匹配 正则表达式模式必须匹配整个字段值 正则表达式模式可以匹配字段中的任何部分 flags 支持 flags 启用可选正则表达式运算符 flags 不支持 查询类型 词级查询（未评分） 全文检索（评分和解析） 最佳使用场景 对关键字或精确字段进行严格模式匹配 使用支持正则表达式模式的灵活查询字符串在分析字段中进行搜索 复杂查询组合 仅限于正则表达式模式 支持 AND 、 OR 、通配符、字段、提升值以及其他功能。参见查询字符串查询。 保留字符 # Lucene 的正则表达式引擎支持所有 Unicode 字符。然而，以下字符被视为特殊运算符：</description></item><item><title>精确查询与全文检索的对比</title><link>/easysearch/main/docs/query-dsl/term-vs-full-text/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/query-dsl/term-vs-full-text/</guid><description>精确查询与全文检索的对比 # 您可以使用精确查询和全文检索来搜索文本，但精确查询通常用于搜索结构化数据，而全文检索则用于全文搜索。精确查询与全文检索的主要区别在于，精确查询搜索文档中的确切指定词项，而全文检索分析查询字符串。下表总结了精确查询与全文检索之间的差异。
精确查询 全文检索 描述 精确查询回答哪些文档匹配查询。 全文检索回答文档与查询匹配的程度。 分词器 搜索词没有被分析。这意味着精确查询会按照你输入的搜索词进行搜索。 搜索词由在索引特定文档字段时使用的相同分词器进行分析。这意味着您的搜索词会经历与文档字段相同的分词过程。 相关性 词级查询仅返回匹配的文档，而不根据相关性分数对它们进行排序。它们仍然计算相关性分数，但这个分数是所有返回文档相同的。 全文检索为每个匹配计算相关性分数，并按相关性分数降序对结果进行排序。 用例 当你需要匹配精确值（如数字、日期或标签）且不需要按相关性排序时，使用词级查询。 使用全文检索来匹配文本字段，并根据大小写和词干变化等因素进行相关性排序。 Easysearch 使用 BM25 排序算法来计算相关性分数。欲了解更多信息，请参阅 Okapi BM25。
我应该使用全文检索还是精确查询？ # 为了说明全文检索和精确查询的区别，考虑以下两个搜索特定文本短语的示例。莎士比亚的全部作品在一个 Easysearch 集群中被索引。
示例：短语搜索 # 在这个示例中，你将在 text_entry 字段中搜索莎士比亚的全部作品中短语“To be, or not to be”。
首先，使用精确查询进行此搜索：
GET shakespeare/_search { &amp;quot;query&amp;quot;: { &amp;quot;term&amp;quot;: { &amp;quot;text_entry&amp;quot;: &amp;quot;To be, or not to be&amp;quot; } } } 返回内容不包含任何匹配项，hits 为 0：</description></item><item><title>重写参数</title><link>/easysearch/main/docs/query-dsl/rewrite-parameter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/query-dsl/rewrite-parameter/</guid><description>重写参数 # 像 wildcard 、 prefix 、 regexp 、 fuzzy 和 range 这样的多词查询在内部会重组成一组词。 rewrite 参数允许你控制这些词重写的执行和评分。
当多词查询扩展成很多词（例如 prefix: &amp;quot;error*&amp;quot; 匹配数百个词）时，它们在内部会转换成 term 查询。这个过程可能会有以下缺点：
超出 indices.query.bool.max_clause_count 限制（默认是 1024 ）。 影响匹配文档的评分计算方式。 根据所使用的重写方法，影响内存和延迟。 rewrite 参数让你能够控制多词查询的内部行为。
模式 评分规则 性能 注释 constant_score 所有匹配具有相同分数 最佳 默认模式，适合过滤器 scoring_boolean 基于 TF/IDF 中等 完整相关性评分 constant_score_boolean 相同分数但使用布尔结构 中等 与 must_not 或 minimum_should_match 一起使用 top_terms_N 在顶部 N 个词上使用 TF/IDF 高效 截断扩展 top_terms_boost_N 静态提升 快速 较低准确度 top_terms_blended_freqs_N 混合评分 平衡 最佳评分/效率权衡 可用的重写方法 # 下表总结了可用的重写方法。</description></item></channel></rss>