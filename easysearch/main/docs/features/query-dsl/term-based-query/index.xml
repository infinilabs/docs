<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>精确查询 on INFINI Easysearch (main)</title><link>/easysearch/main/docs/features/query-dsl/term-based-query/</link><description>Recent content in 精确查询 on INFINI Easysearch (main)</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/main/docs/features/query-dsl/term-based-query/index.xml" rel="self" type="application/rss+xml"/><item><title>Exists 查询</title><link>/easysearch/main/docs/features/query-dsl/term-based-query/exists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/term-based-query/exists/</guid><description>Exists 查询 # 使用 exists 查询来搜索包含特定字段的文档。
相关指南（先读这些） # 结构化搜索 Query DSL 基础 如果出现以下任一情况，索引值将不会存在于文档字段中：
该字段在映射中指定了 &amp;quot;index&amp;quot; : false 。 源 JSON 中的字段为 null 或 [] 。 字段值的长度超过了映射中 ignore_above 的设置。 字段值格式错误，并且映射中定义了 ignore_malformed 。 索引值将在以下情况下存在于文档字段中：
该值是一个包含一个或多个 null 元素和一个或多个非 null 元素的数组（例如， [&amp;quot;one&amp;quot;, null] ）。 该值是一个空字符串（ &amp;quot;&amp;quot; 或 &amp;quot;-&amp;quot; ）。 该值是一个自定义的 null_value ，如字段映射中所定义。 参考样例 # 例如，假设索引包含以下两个文档：
PUT testindex/_doc/1 { &amp;#34;title&amp;#34;: &amp;#34;The wind rises&amp;#34; } PUT testindex/_doc/2 { &amp;#34;title&amp;#34;: &amp;#34;Gone with the wind&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;A 1939 American epic historical film&amp;#34; } 以下查询搜索包含 description 字段的文档：</description></item><item><title>Fuzzy 查询</title><link>/easysearch/main/docs/features/query-dsl/term-based-query/fuzzy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/term-based-query/fuzzy/</guid><description>Fuzzy 查询 # fuzzy 查询用于搜索包含与搜索词相似的词条的文档，相似度在允许的最大 Damerau-Levenshtein 距离范围内。Damerau-Levenshtein 距离衡量将一个词条变为另一个词条所需的一字符变化的数量。这些变化包括：
相关指南（先读这些） # 文本分析：模糊匹配
全文搜索
Replacements: 替换，cat 变为 bat
Insertions: 插入，cat 变为 cats
Deletions: 删除，cat 变为 at
Transpositions: 转换，cat 变为 act
模糊查询会生成一个包含所有可能扩展的搜索词列表，这些扩展在 Damerau-Levenshtein 距离内。你可以在 max_expansions 字段中指定此类扩展的最大数量。查询然后会搜索匹配任何扩展的文档。如果你将 transpositions 参数设置为 false ，则搜索将使用经典的 Levenshtein 距离。
以下示例查询搜索发言者 HALET （误写为 HAMLET ）。未指定最大编辑距离，因此使用默认的 AUTO 编辑距离：
GET shakespeare/_search { &amp;#34;query&amp;#34;: { &amp;#34;fuzzy&amp;#34;: { &amp;#34;speaker&amp;#34;: { &amp;#34;value&amp;#34;: &amp;#34;HALET&amp;#34; } } } } 返回内容包含所有发言者为 HAMLET 的文档。</description></item><item><title>IDs 查询</title><link>/easysearch/main/docs/features/query-dsl/term-based-query/ids/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/term-based-query/ids/</guid><description>IDs 查询 # 使用 ids 查询在 _id 字段中搜索具有一个或多个特定文档 ID 值的文档。例如，以下查询请求 ID 为 34229 和 91296 的文档：
相关指南（先读这些） # 结构化搜索 Query DSL 基础 GET shakespeare/_search { &amp;#34;query&amp;#34;: { &amp;#34;ids&amp;#34;: { &amp;#34;values&amp;#34;: [ 34229, 91296 ] } } } 参数说明 # 查询接受以下参数。
参数 数据类型 描述 values Array of strings 要搜索的文档 ID。必填。 boost Float 一个浮点值，用于指定此字段相对于相关性分数的权重。值高于 1.0 会增加字段的相关性。值介于 0.</description></item><item><title>Prefix 查询</title><link>/easysearch/main/docs/features/query-dsl/term-based-query/prefix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/term-based-query/prefix/</guid><description>Prefix 查询 # 使用 prefix 查询可以搜索以特定前缀开头的词。例如，以下查询会搜索 speaker 字段包含以 KING H 开头的词的文档。
相关指南（先读这些） # 部分匹配 结构化搜索 GET shakespeare/_search { &amp;#34;query&amp;#34;: { &amp;#34;prefix&amp;#34;: { &amp;#34;speaker&amp;#34;: &amp;#34;KING H&amp;#34; } } } 为了提供参数，您可以使用与前面的查询相同的形式，并使用以下扩展语法
GET shakespeare/_search { &amp;#34;query&amp;#34;: { &amp;#34;prefix&amp;#34;: { &amp;#34;speaker&amp;#34;: { &amp;#34;value&amp;#34;: &amp;#34;KING H&amp;#34; } } } } 参数说明 # 查询接受字段名称（ &amp;lt;field&amp;gt; ）作为顶级参数：
GET _search { &amp;#34;query&amp;#34;: { &amp;#34;prefix&amp;#34;: { &amp;#34;&amp;lt;field&amp;gt;&amp;#34;: { &amp;#34;value&amp;#34;: &amp;#34;sample&amp;#34;, ... } } } } &amp;lt;field&amp;gt; 接受以下参数。除了 value 之外，所有参数都是可选的。</description></item><item><title>Range 查询</title><link>/easysearch/main/docs/features/query-dsl/term-based-query/range/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/term-based-query/range/</guid><description>Range 查询 # 您可以使用 range 查询搜索字段中的值范围。
相关指南（先读这些） # 结构化搜索 Query DSL 基础 要搜索 line_id 值为 &amp;gt;= 10 和 &amp;lt;= 20 的文档，请使用以下请求：
GET shakespeare/_search { &amp;#34;query&amp;#34;: { &amp;#34;range&amp;#34;: { &amp;#34;line_id&amp;#34;: { &amp;#34;gte&amp;#34;: 10, &amp;#34;lte&amp;#34;: 20 } } } } 运算符 # 范围查询中的字段参数接受以下可选运算符参数：
gte：大于或等于 gt：大于 lte：小于或等于 lt：小于 日期字段 # 您可以对包含日期的字段使用范围查询。例如，假设您有一个products索引，并且想要查找 2019 年添加的所有产品：
GET products/_search { &amp;#34;query&amp;#34;: { &amp;#34;range&amp;#34;: { &amp;#34;created&amp;#34;: { &amp;#34;gte&amp;#34;: &amp;#34;2019/01/01&amp;#34;, &amp;#34;lte&amp;#34;: &amp;#34;2019/12/31&amp;#34; } } } } 日期格式 # 要在查询中使用字段映射格式以外的日期格式，请在 format 字段中指定它。</description></item><item><title>Regexp 查询</title><link>/easysearch/main/docs/features/query-dsl/term-based-query/regexp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/term-based-query/regexp/</guid><description>Regexp 查询 # 使用 regexp 查询来搜索符合正则表达式的词项。有关编写正则表达式的更多信息，请参见正则表达式语法。
相关指南（先读这些） # 部分匹配 结构化搜索 以下查询搜索以任何大写或小写字母开头的任何词项 amlet ：
GET shakespeare/_search { &amp;#34;query&amp;#34;: { &amp;#34;regexp&amp;#34;: { &amp;#34;play_name&amp;#34;: &amp;#34;[a-zA-Z]amlet&amp;#34; } } } 重要注意事项：
正则表达式应用于字段中的词条（即，标记/token），而不是整个字段。 默认情况下，正则表达式的最大长度为 1,000 个字符。要更改最大长度，请更新 index.max_regex_length 设置。 正则表达式使用 Lucene 语法，这与更标准的实现有所不同。请充分测试以确保获得预期的结果。 为了提高正则表达式查询的性能，避免使用没有前缀或后缀的通配符模式，例如 .* 或 .*?+ 。 regexp 查询可能会非常耗时，并且需要将 search.allow_expensive_queries 设置为 true 。在频繁执行 regexp 查询之前，请测试其对集群性能的影响，并考虑使用其他可能达到类似效果的查询。更多性能优化建议，请参考 部分匹配章节。 参数说明 # 查询接受字段名称（ &amp;lt;field&amp;gt; ）作为顶级参数：
GET _search { &amp;#34;query&amp;#34;: { &amp;#34;regexp&amp;#34;: { &amp;#34;&amp;lt;field&amp;gt;&amp;#34;: { &amp;#34;value&amp;#34;: &amp;#34;[Ss]ample&amp;#34;, .</description></item><item><title>Term 查询</title><link>/easysearch/main/docs/features/query-dsl/term-based-query/term/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/term-based-query/term/</guid><description>Term 查询 # 使用 term 查询在字段中搜索确切的词项。例如，以下查询搜索包含确切的行号的行：
相关指南（先读这些） # 结构化搜索 Query DSL 基础 GET shakespeare/_search { &amp;#34;query&amp;#34;: { &amp;#34;term&amp;#34;: { &amp;#34;line_id&amp;#34;: { &amp;#34;value&amp;#34;: &amp;#34;61809&amp;#34; } } } } 注意：term 查询仅匹配确切的词项，不会对查询文本进行分词。避免在 text 字段上使用 term 查询，应使用 keyword 字段或 match 查询。更多信息，请参阅 结构化搜索。
您可以在 case_insensitive 参数中指定查询应不区分大小写：
GET shakespeare/_search { &amp;#34;query&amp;#34;: { &amp;#34;term&amp;#34;: { &amp;#34;speaker&amp;#34;: { &amp;#34;value&amp;#34;: &amp;#34;HAMLET&amp;#34;, &amp;#34;case_insensitive&amp;#34;: true } } } } 返回内容包含匹配的文档，无论大小写是否有差异：
&amp;#34;hits&amp;#34;: { &amp;#34;total&amp;#34;: { &amp;#34;value&amp;#34;: 1582, &amp;#34;relation&amp;#34;: &amp;#34;eq&amp;#34; }, &amp;#34;max_score&amp;#34;: 2, &amp;#34;hits&amp;#34;: [ { &amp;#34;_index&amp;#34;: &amp;#34;shakespeare&amp;#34;, &amp;#34;_id&amp;#34;: &amp;#34;32700&amp;#34;, &amp;#34;_score&amp;#34;: 2, &amp;#34;_source&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;line&amp;#34;, &amp;#34;line_id&amp;#34;: 32701, &amp;#34;play_name&amp;#34;: &amp;#34;Hamlet&amp;#34;, &amp;#34;speech_number&amp;#34;: 9, &amp;#34;line_number&amp;#34;: &amp;#34;1.</description></item><item><title>Terms Set 查询</title><link>/easysearch/main/docs/features/query-dsl/term-based-query/terms-set/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/term-based-query/terms-set/</guid><description>Terms Set 查询 # 使用 terms_set 查询，您可以在指定字段中搜索匹配一定数量的精确词的文档。与 terms 查询类似，您可以指定返回文档所需的匹配词的最小数量。您可以直接在索引字段中指定这个数量，也可以通过脚本指定。
相关指南（先读这些） # 结构化搜索 查询 DSL 基础 例如，假设有一个索引，其中包含学生的姓名和他们所选的课程。在设置该索引的映射时，您需要提供一个数值字段，以指定返回文档所需的最小匹配项数量：
PUT students { &amp;#34;mappings&amp;#34;: { &amp;#34;properties&amp;#34;: { &amp;#34;name&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;keyword&amp;#34; }, &amp;#34;classes&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;keyword&amp;#34; }, &amp;#34;min_required&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;integer&amp;#34; } } } } 接下来，索引两个与学生相关的文档：
PUT students/_doc/1 { &amp;#34;name&amp;#34;: &amp;#34;Mary Major&amp;#34;, &amp;#34;classes&amp;#34;: [ &amp;#34;CS101&amp;#34;, &amp;#34;CS102&amp;#34;, &amp;#34;MATH101&amp;#34; ], &amp;#34;min_required&amp;#34;: 2 } PUT students/_doc/2 { &amp;#34;name&amp;#34;: &amp;#34;John Doe&amp;#34;, &amp;#34;classes&amp;#34;: [ &amp;#34;CS101&amp;#34;, &amp;#34;MATH101&amp;#34;, &amp;#34;ENG101&amp;#34; ], &amp;#34;min_required&amp;#34;: 2 } 现在搜索已经修读了以下至少两门课程的学生： CS101 ， CS102 ， MATH101 ：</description></item><item><title>Terms 查询</title><link>/easysearch/main/docs/features/query-dsl/term-based-query/terms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/term-based-query/terms/</guid><description>Terms 查询 # 使用 terms 查询在同一字段中搜索多个词项。例如，以下查询搜索具有 ID 61809 和 61810 的文档：
相关指南（先读这些） # 结构化搜索 Query DSL 基础 GET shakespeare/_search { &amp;#34;query&amp;#34;: { &amp;#34;terms&amp;#34;: { &amp;#34;line_id&amp;#34;: [ &amp;#34;61809&amp;#34;, &amp;#34;61810&amp;#34; ] } } } 如果文档与数组中的任何词项匹配，则会返回该文档。
默认情况下， terms 查询中允许的最大词项数量为 65,536。要更改最大词项数量，请更新 index.max_terms_count 设置。
为了更好的查询性能，请传递包含已排序词项的长期数组（按 UTF-8 字节值升序排序）。
根据高亮器类型和查询中词项的数量，高亮显示词项查询结果的能力可能无法保证。
参数说明 # 该查询接受以下参数。所有参数都是可选的。
参数 数据类型 描述 &amp;lt;field&amp;gt; String 要搜索的字段。只有当文档的字段值与查询中至少一个词项完全匹配（包括正确的空格和大小写）时，该文档才会出现在结果中。 boost Float 一个浮点数值，用于指定该字段对相关性分数的权重。大于 1.</description></item><item><title>Wildcard 查询</title><link>/easysearch/main/docs/features/query-dsl/term-based-query/wildcard/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/term-based-query/wildcard/</guid><description>Wildcard 查询 # 使用 wildcard 查询来搜索匹配通配符模式的词项。通配符查询支持以下操作符。
相关指南（先读这些） # 部分匹配 结构化搜索 通配符字段类型（Wildcard） — 专为高效通配符匹配设计的字段类型 操作符 描述 * 匹配零个或多个字符。 ? 匹配任意单个字符。 case_insensitive 若 true 为真，则通配符查询不区分大小写；若 false 为真，则通配符查询区分大小写。默认情况下 false 为真（区分大小写）。 若进行区分大小写的搜索，查找以 H 开头且以 Y 结尾的词，可使用以下请求：
GET shakespeare/_search { &amp;#34;query&amp;#34;: { &amp;#34;wildcard&amp;#34;: { &amp;#34;speaker&amp;#34;: { &amp;#34;value&amp;#34;: &amp;#34;H*Y&amp;#34;, &amp;#34;case_insensitive&amp;#34;: false } } } } 如果你将 * 更改为 ?</description></item><item><title>Fast Terms 查询</title><link>/easysearch/main/docs/features/query-dsl/term-based-query/fast-terms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/term-based-query/fast-terms/</guid><description>Fast Terms 查询 # Fast Terms 是 Easysearch 提供的高性能 terms 查询插件，专为大规模 terms 过滤场景优化。当需要在查询中使用大量 term 值进行过滤时（如数万甚至数十万个 ID），Fast Terms 可以提供比标准 terms 查询更好的性能。
适用场景 # 大规模 ID 过滤：根据外部系统提供的大量 ID 列表过滤文档 权限过滤：根据用户可访问的文档 ID 集合进行过滤 黑/白名单：根据预定义的大规模列表进行包含/排除过滤 高基数字段过滤：在高基数数值字段上进行大量值的匹配 工作原理 # Fast Terms 使用 RoaringBitmap 和零分配哈希（XXHash）等技术对大规模 terms 集合进行压缩和高效匹配，相比标准 terms 查询在以下方面有显著优势：
对比项 标准 terms 查询 Fast Terms 内存占用 较高（每个 term 独立存储） 低（Bitmap 压缩） 大规模 terms 性能 随 terms 数量线性下降 保持稳定 缓存效率 一般 高（LZ4 压缩 + 过期缓存） 使用方法 # Bitmap Value Type # 在 terms 查询中使用 value_type: bitmap 来启用 Fast Terms 优化：</description></item></channel></rss>