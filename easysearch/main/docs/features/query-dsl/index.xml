<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>查询 DSL on INFINI Easysearch</title><link>/easysearch/main/docs/features/query-dsl/</link><description>Recent content in 查询 DSL on INFINI Easysearch</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/main/docs/features/query-dsl/index.xml" rel="self" type="application/rss+xml"/><item><title>查询与过滤上下文</title><link>/easysearch/main/docs/features/query-dsl/query-filter-context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/query-filter-context/</guid><description>查询与过滤上下文 # 查询由查询子句组成，这些子句可以在过滤（filter）上下文或查询上下文中运行。
在过滤（filter）上下文中的查询子句会询问&amp;quot;文档是否匹配查询子句？&amp;ldquo;并返回匹配的文档。在查询上下文中的查询子句会询问&amp;quot;文档与查询子句匹配程度如何？&amp;quot;，返回匹配的文档，并以相关性分数的形式提供每个文档的相关性。
相关指南（先读这些） # 查询 DSL 基础 结构化搜索 相关性分数 # 相关性分数衡量文档与查询的匹配程度。它是一个正浮点数，Easysearch 会记录在每个文档的 _score 元数据字段中：
&amp;#34;hits&amp;#34; : [ { &amp;#34;_index&amp;#34; : &amp;#34;shakespeare&amp;#34;, &amp;#34;_id&amp;#34; : &amp;#34;32437&amp;#34;, &amp;#34;_score&amp;#34; : 18.781435, &amp;#34;_source&amp;#34; : { &amp;#34;type&amp;#34; : &amp;#34;line&amp;#34;, &amp;#34;line_id&amp;#34; : 32438, &amp;#34;play_name&amp;#34; : &amp;#34;Hamlet&amp;#34;, &amp;#34;speech_number&amp;#34; : 3, &amp;#34;line_number&amp;#34; : &amp;#34;1.1.3&amp;#34;, &amp;#34;speaker&amp;#34; : &amp;#34;BERNARDO&amp;#34;, &amp;#34;text_entry&amp;#34; : &amp;#34;Long live the king!&amp;#34; } }, ... 一个更高的分数表示文档更相关。虽然不同的查询类型计算相关性分数的方式不同，但所有查询类型都会考虑查询子句是在过滤（filter）上下文还是查询上下文中运行。
在查询上下文中使用你想影响相关性分数的查询子句，并在过滤（filter）上下文中使用所有其他查询子句。
过滤上下文 # 在过滤上下文中的查询子句会问“文档是否匹配查询子句？”，这个问题有二元答案。例如，如果你有一个包含学生数据的索引，你可以使用过滤上下文来回答以下关于学生的疑问:</description></item><item><title>Match All 查询</title><link>/easysearch/main/docs/features/query-dsl/match-all/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/match-all/</guid><description>Match All 查询 # match_all 查询返回所有文档。如果需要返回整个文档集，这个查询在测试大量文档集时很有用。
相关指南（先读这些） # 查询 DSL 基础 结构化搜索 GET _search { &amp;#34;query&amp;#34;: { &amp;#34;match_all&amp;#34;: {} } } match_all 查询有一个 match_none 的对应查询，这个对应查询很少有用：
GET _search { &amp;#34;query&amp;#34;: { &amp;#34;match_none&amp;#34;: {} } } 参数说明 # 全匹配和全不匹配查询都接受以下参数。所有参数都是可选的。
参数 数据类型 描述 boost Float 一个浮点数值，用于指定该字段对相关性分数的权重。大于 1.0 的值会增加字段的权重。介于 0.0 和 1.0 之间的值会降低字段的权重。默认值为 1.0。 _name String 用于查询标签的查询名称。可选。 常见使用场景 # 配合 filter 使用 # match_all 经常与过滤器结合使用，在不需要相关性评分的场景下获取文档子集：</description></item><item><title>Query DSL 基础</title><link>/easysearch/main/docs/features/query-dsl/query-dsl-basics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/query-dsl-basics/</guid><description>这一页的目标是：在不记任何 API 细节的前提下，先把 Query DSL 的“骨架”和核心概念讲清楚，后面看具体查询语法就会轻松很多。
JSON 结构而不是&amp;quot;SQL 语句&amp;quot; # Easysearch 的查询是 JSON 结构，而不是一条字符串语句。一个最小的查询大致长这样：
GET /_search { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;message&amp;#34;: &amp;#34;hello world&amp;#34; } } } 要记住两个层级：
最外层的 &amp;quot;query&amp;quot;：说明这是一个&amp;quot;查询上下文&amp;quot; &amp;quot;match&amp;quot;、&amp;quot;term&amp;quot;、&amp;quot;range&amp;quot; 等：都是不同类型的&amp;quot;子查询&amp;quot; 查询语句的结构 # 一个查询语句的典型结构：
{ QUERY_NAME: { ARGUMENT: VALUE, ARGUMENT: VALUE,... } } 如果是针对某个字段，那么它的结构如下：
{ QUERY_NAME: { FIELD_NAME: { ARGUMENT: VALUE, ARGUMENT: VALUE,... } } } 例如，使用 match 查询语句来查询 tweet 字段中包含 easysearch 的文档：
{ &amp;#34;match&amp;#34;: { &amp;#34;tweet&amp;#34;: &amp;#34;easysearch&amp;#34; } } 空查询 # 空查询（{}）在功能上等价于使用 match_all 查询，正如其名字一样，匹配所有文档：</description></item><item><title>自动补全</title><link>/easysearch/main/docs/features/query-dsl/autocomplete/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/autocomplete/</guid><description>自动补全是在用户输入过程中，实时给出可能的搜索词建议。Easysearch 支持三种实现方式，各有适用场景：
方式 时机 性能 适用场景 前缀匹配（match_phrase_prefix） 查询时 一般 快速原型，无需特殊 mapping Edge N-gram 索引时 好 大规模数据的前缀补全 Completion Suggester 索引时 最优 高并发自动补全，支持权重控制 相关指南 # 建议与纠错 部分匹配 前缀匹配（match_phrase_prefix） # 前缀匹配会在查询时，对最后一个 term 做前缀展开。典型做法是使用 match_phrase_prefix 在 text 字段上做查询。
不需要特殊 mapping，可以直接在现有 text 字段上使用。
GET shakespeare/_search { &amp;#34;query&amp;#34;: { &amp;#34;match_phrase_prefix&amp;#34;: { &amp;#34;text_entry&amp;#34;: { &amp;#34;query&amp;#34;: &amp;#34;qui&amp;#34;, &amp;#34;slop&amp;#34;: 3 } } } } 参数说明 # 参数 说明 默认值 query 查询文本 必填 slop 允许的词项位置偏移量 0 max_expansions 最后一个词项的最大前缀展开数量 50 analyzer 覆盖默认分析器 字段默认分析器 zero_terms_query 当分析器移除所有词项时的行为（none 或 all） none 性能注意：前缀匹配属于相对昂贵的查询。例如前缀为 a 时，可能会匹配到几十万 terms。建议通过 max_expansions 限制展开规模：</description></item><item><title>Minimum Should Match 参数</title><link>/easysearch/main/docs/features/query-dsl/minimum-should-match/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/minimum-should-match/</guid><description>Minimum Should Match 参数 # minimum_should_match 参数可用于全文搜索，并指定文档必须匹配的最小词项数量才能在搜索结果中返回。
以下示例要求文档至少匹配三个搜索词中的两个才能作为搜索结果返回：
相关指南（先读这些） # 查询 DSL 基础 全文搜索 GET /shakespeare/_search { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;text_entry&amp;#34;: { &amp;#34;query&amp;#34;: &amp;#34;prince king star&amp;#34;, &amp;#34;minimum_should_match&amp;#34;: &amp;#34;2&amp;#34; } } } } 在这个示例中，查询有三个可选子句，它们通过 OR 结合，因此文档必须匹配 prince 和 king ，或者 prince 和 star ，或者 king 和 star 。
参数值说明 # 您可以指定 minimum_should_match 参数为以下值之一。
值类型 示例 描述 非负整数 2 一个文档必须匹配这个数量的可选子句。 负整数 -1 一个文档必须匹配可选子句总数减去这个数。 非负百分比 70% 一个文档必须匹配可选子句总数的这个百分比。要匹配的子句数向下取整到最接近的整数。 负百分比 -30% 一个文档可以有这个百分比的不匹配的可选子句。文档允许不匹配的子句数向下取整到最接近的整数。 组合 2&amp;lt;75% n&amp;lt;p% 格式的表达式。如果可选子句的数量小于或等于 n ，文档必须匹配所有可选子句。如果可选子句的数量大于 n ，则文档必须匹配 p 百分比的可选子句。 多种组合 3&amp;lt;-1 5&amp;lt;50% 用空格分隔的多个组合。每个条件适用于 &amp;lt; 符号左侧数字更多的可选子句数量。在这个例子中，如果有三个或更少可选子句，文档必须匹配所有它们。如果有四或五个可选子句，文档必须匹配所有但一个。如果有 6 个或更多可选子句，文档必须匹配 50% 的它们。 设 n 为文档必须匹配的可选子句数量。当 n 计算为百分比时，如果 n 小于 1，则使用 1。如果 n 大于可选子句的数量，则使用可选子句的数量。</description></item><item><title>查询字符串语法</title><link>/easysearch/main/docs/features/query-dsl/query-parser-syntax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/query-parser-syntax/</guid><description>Easysearch 的 query_string 和 simple_query_string 查询底层使用 Lucene 查询解析器（Query Parser）将查询字符串解析为查询对象。本页详细描述查询解析器支持的完整语法。
相关指南 # Query String 查询 — query_string 查询的 API 参数 Simple Query String 查询 — 更宽松的查询字符串语法 正则表达式语法 — regexp 查询和 query_string 中使用的正则语法 词项（Terms） # 查询字符串由词项和操作符组成。词项有两种类型：
单个词项：一个单词，如 test、hello 短语：用双引号包围的一组词，如 &amp;quot;hello dolly&amp;quot; 多个词项可以通过布尔操作符组合成更复杂的查询。
注意：查询字符串中的词项和短语会经过索引时使用的相同分析器处理。因此，选择不会干扰查询词项的分析器非常重要。
字段（Fields） # Easysearch 支持按字段搜索。搜索时可以指定字段名，也可以使用默认字段。
语法为字段名后跟冒号 :，然后是要搜索的词项：
title:&amp;#34;The Right Way&amp;#34; AND content:go 上面的查询在 title 字段中查找短语 &amp;ldquo;The Right Way&amp;rdquo;，在 content 字段中查找词 &amp;ldquo;go&amp;rdquo;。</description></item><item><title>正则表达式语法</title><link>/easysearch/main/docs/features/query-dsl/regex-syntax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/regex-syntax/</guid><description>正则表达式语法 # 正则表达式（regex）是一种使用特殊符号和运算符定义搜索模式的方法。这些模式允许你在字符串中匹配字符序列。
在 Easysearch 中，你可以在以下查询类型中使用正则表达式：
regexp query_string 注意：Easysearch 使用 Apache Lucene 正则表达式引擎，该引擎有自己的语法和限制。它不使用 Perl 兼容正则表达式（PCRE），因此某些熟悉的正则表达式功能可能会表现不同或不受支持。
相关指南（先读这些） # 部分匹配 正则查询 字符串查询 查询字符串语法 — 通配符、模糊、范围、布尔等完整语法参考 在 regexp 和 query_string 查询之间进行选择 # regexp 和 query_string 查询都支持正则表达式，但它们的行为不同，适用于不同的使用场景。
特性 regexp 查询 query_string 查询 模式匹配 正则表达式模式必须匹配整个字段值 正则表达式模式可以匹配字段中的任何部分 flags 支持 flags 启用可选正则表达式运算符 flags 不支持 查询类型 词级查询（未评分） 全文检索（评分和解析） 最佳使用场景 对关键字或精确字段进行严格模式匹配 使用支持正则表达式模式的灵活查询字符串在分析字段中进行搜索 复杂查询组合 仅限于正则表达式模式 支持 AND 、 OR 、通配符、字段、提升值以及其他功能。参见查询字符串查询。 保留字符 # Lucene 的正则表达式引擎支持所有 Unicode 字符。然而，以下字符被视为特殊运算符：</description></item><item><title>Rewrite 参数</title><link>/easysearch/main/docs/features/query-dsl/rewrite-parameter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/rewrite-parameter/</guid><description>Rewrite 参数 # 像 wildcard、prefix、regexp、fuzzy 和 range 这样的多词查询在内部会重组成一组词。rewrite 参数允许你控制这些词重写的执行和评分。
当多词查询扩展成很多词（例如 prefix: &amp;quot;error*&amp;quot; 匹配数百个词）时，它们在内部会转换成 term 查询。这个过程可能会有以下缺点：
超出 indices.query.bool.max_clause_count 限制（默认是 1024）。 影响匹配文档的评分计算方式。 根据所使用的重写方法，影响内存和延迟。 rewrite 参数让你能够控制多词查询的内部行为。
模式 评分规则 性能 注释 constant_score 所有匹配具有相同分数 最佳 默认模式，适合过滤器 scoring_boolean 基于 TF/IDF 中等 完整相关性评分 constant_score_boolean 相同分数但使用布尔结构 中等 与 must_not 或 minimum_should_match 一起使用 top_terms_N 在顶部 N 个词上使用 TF/IDF 高效 截断扩展 top_terms_boost_N 静态提升 快速 较低准确度 top_terms_blended_freqs_N 混合评分 平衡 最佳评分/效率权衡 相关指南（先读这些） # 部分匹配 查询 DSL 基础 可用的重写方法 # 下表总结了可用的重写方法。</description></item><item><title>分页与滚动</title><link>/easysearch/main/docs/features/query-dsl/paginate-and-scroll/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/paginate-and-scroll/</guid><description>Easysearch 提供多种分页机制，适用于不同场景：
方式 适用场景 一致性 深度限制 from/size 小规模翻页（前几页） 无（实时数据） 默认 10,000 search_after + sort 深分页、增量翻页 无（实时数据） 无 search_after + PIT 深分页、一致性翻页 快照一致 无 Scroll 批量导出、离线处理 快照一致 无 相关指南 # 分页与排序 from/size 基础分页 # 最基础的分页依赖 from 和 size 两个参数：
参数 说明 默认值 from 起始偏移（0 基） 0 size 本页返回条数 10 GET shakespeare/_search { &amp;#34;from&amp;#34;: 0, &amp;#34;size&amp;#34;: 10, &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;play_name&amp;#34;: &amp;#34;Hamlet&amp;#34; } } } 计算页码对应的 from：from = size × (page_number - 1)</description></item><item><title>结构化搜索</title><link>/easysearch/main/docs/features/query-dsl/structured-search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/structured-search/</guid><description>结构化搜索针对的是“精确可判定”的字段：ID、枚举、时间、数值、状态位等。本页重点讲如何用好 term/terms/range/exists 这几类基础查询，并配合 filter 上下文使用。
适用字段与“不适用”的情况 # 适合用结构化查询的典型字段：
关键词/编码：订单号、用户 ID、设备 ID、状态码 数值：价格、年龄、计数、评分 时间：创建时间、更新时间、业务时间 标志位/枚举：is_deleted、status、type 等 不适合用结构化查询的字段：
需要做全文检索的长文本（标题、描述、评论等）
→ 应使用 match/match_phrase 等全文查询，详见“全文检索”章节。 term：精确匹配 # term 查询不会做分词，也不会自动大小写转换，适合：
keyword 字段 数值字段 布尔/枚举字段 典型用法（以伪 JSON 示意）：
{ &amp;#34;query&amp;#34;: { &amp;#34;term&amp;#34;: { &amp;#34;status&amp;#34;: &amp;#34;active&amp;#34; } } } 建议：
对 text 字段做 term 查询通常是错误的（除非你非常明确知道底层分析行为） 业务 ID、编码类字段建议使用 keyword 类型并用 term 查询 terms：在一组值中匹配 # terms 用于“IN 列表”场景：</description></item><item><title>排序</title><link>/easysearch/main/docs/features/query-dsl/sort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/sort/</guid><description>默认情况下，全文查询按相关性 _score 排序。你也可以按任意字段值升序/降序排序，或使用地理距离、脚本等高级排序方式。
相关指南 # 分页与排序 基础字段排序 # 通过 sort 参数指定排序字段和顺序：
GET shakespeare/_search { &amp;#34;query&amp;#34;: { &amp;#34;term&amp;#34;: { &amp;#34;play_name&amp;#34;: { &amp;#34;value&amp;#34;: &amp;#34;Henry IV&amp;#34; } } }, &amp;#34;sort&amp;#34;: [ { &amp;#34;line_id&amp;#34;: { &amp;#34;order&amp;#34;: &amp;#34;desc&amp;#34; } } ] } 排序参数 # 参数 说明 可选值 order 排序方向 asc（升序）、desc（降序） mode 多值字段的聚合模式 min、max、avg、sum、median missing 缺失值的处理方式 _first（排最前）、_last（排最后）、自定义值 unmapped_type 未映射字段的假设类型 字段类型名（如 long、date） 多级排序 # sort 是数组，可以配置多级排序。当主排序键相同时，使用次排序键：</description></item><item><title>Search Template API</title><link>/easysearch/main/docs/features/query-dsl/search-template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/search-template/</guid><description>Search Template API # 您可以将全文查询转换为查询模板，以接受用户输入并将其动态插入到查询中。
例如，如果您使用 Easysearch 作为应用程序或网站的后端搜索引擎，则可以从搜索栏或表单字段接收用户查询，并将其作为参数传递到查询模板中。这样，创建 Easysearch 查询的语法就从最终用户那里抽象出来了。
当您编写代码将用户输入转换为 Easysearch 查询时，可以使用查询模板简化代码。如果需要将字段添加到搜索查询中，只需修改模板即可，而无需更改代码。
查询模板使用 Mustache 语言。有关所有语法选项的列表，请参阅 Mustache 手册。
相关指南（先读这些） # 查询 DSL 基础 全文搜索 创建查询模版 # 查询模版有两个组件：查询和参数。参数是放置在变量中的用户输入值。在 Mustache 符号中，变量用双括号表示。当在查询中遇到类似 {% raw %}{{var}}{% endraw %} 的变量时，Easysearch 会转到 params 部分，查找名为 var 的参数，并用指定的值替换它。
您可以编写应用程序代码，询问用户要搜索什么，然后在运行时将该值插入 params 对象中。
此命令定义了一个查询模版，用于按名称查找播放。查询中的 {% raw %}{{play_name}}{% endraw %} 被值 Henry IV 替换：
GET _search/template { &amp;#34;source&amp;#34;: { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;play_name&amp;#34;: &amp;#34;{% raw %}{{play_name}}{% endraw %}&amp;#34; } } }, &amp;#34;params&amp;#34;: { &amp;#34;play_name&amp;#34;: &amp;#34;Henry IV&amp;#34; } } 此模板在整个集群上运行搜索。</description></item><item><title>Point In Time (PIT) API</title><link>/easysearch/main/docs/features/query-dsl/pit-api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/pit-api/</guid><description>Point In Time (PIT) API # Point In Time（PIT）搜索具有与常规搜索相同的功能，不同之处在于 PIT 搜索作用于较旧的数据集，而常规搜索作用于实时数据集。PIT 搜索不绑定于特定查询，因此您可以在同一个冻结在时间点上的数据集上运行不同的查询。
您可以使用创建 PIT API 来创建 PIT。当您为一组索引创建 PIT 时，Easysearch 会锁定这些索引的一组段，使它们在时间上冻结。在底层，此 PIT 所需的资源不会被修改或删除。如果作为 PIT 一部分的段被合并，Easysearch 会在 PIT 创建时通过 keep_alive 参数指定的时间段内保留这些段的副本。
创建 PIT 操作会返回一个 PIT ID，您可以使用该 ID 在冻结的数据集上运行多个查询。即使索引继续摄取数据并修改或删除文档，PIT 引用的数据自 PIT 创建以来不会发生变化。当您的查询包含 PIT ID 时，您不需要将索引传递给搜索，因为它将使用该 PIT。使用 PIT ID 的搜索在多次运行时将产生完全相同的结果。
相关指南（先读这些） # 分页与排序 查询 DSL 基础 创建 PIT # 创建一个 PIT。查询参数 keep_alive 是必需的；它指定了保持 PIT 的时间长度。
端点 # POST /&amp;lt;target_indexes&amp;gt;/_pit?</description></item><item><title>查询重打分</title><link>/easysearch/main/docs/features/query-dsl/rescore/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/rescore/</guid><description>查询重打分（Rescore）允许你在初始查询返回 Top-N 结果后，用更复杂、更精细的查询对这些结果重新打分。这是一种二阶段打分策略：第一阶段用快速查询（如 match）粗筛，第二阶段用代价更高的查询（如 match_phrase、function_score）精排。
使用场景 # 短语精排：先用 match 召回，再用 match_phrase 提升短语完全匹配的文档 复杂评分：初始召回后，对 Top 结果做 function_score 或 script_score 精细计算 向量混排：用 BM25 召回后，对 Top-N 用 kNN 重打分 基础用法 # GET shakespeare/_search { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;text_entry&amp;#34;: &amp;#34;to be or not to be&amp;#34; } }, &amp;#34;rescore&amp;#34;: { &amp;#34;window_size&amp;#34;: 100, &amp;#34;query&amp;#34;: { &amp;#34;rescore_query&amp;#34;: { &amp;#34;match_phrase&amp;#34;: { &amp;#34;text_entry&amp;#34;: { &amp;#34;query&amp;#34;: &amp;#34;to be or not to be&amp;#34;, &amp;#34;slop&amp;#34;: 2 } } }, &amp;#34;query_weight&amp;#34;: 0.</description></item><item><title>结果折叠</title><link>/easysearch/main/docs/features/query-dsl/collapse/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/collapse/</guid><description>结果折叠（Field Collapsing）允许你按某个字段的值对搜索结果进行分组去重，每组只返回最相关的一条（或通过 inner_hits 展开多条）。常用于：
商品搜索：同一品牌/店铺只展示最相关的一个商品 新闻搜索：同一来源的新闻只展示一条 日志分析：按主机名折叠，每台机器只显示最新的一条 基础用法 # GET products/_search { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;title&amp;#34;: &amp;#34;手机&amp;#34; } }, &amp;#34;collapse&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;brand.keyword&amp;#34; }, &amp;#34;sort&amp;#34;: [{ &amp;#34;_score&amp;#34;: &amp;#34;desc&amp;#34; }] } 每个 brand.keyword 值只返回分数最高的一条文档。
字段要求：collapse 字段必须是 keyword 或数值类型，且必须启用 doc_values。
参数说明 # 参数 类型 默认值 说明 field String 必填 用于折叠的字段名（keyword 或数值类型，需有 doc_values） inner_hits Object 或 Array 空 展开折叠组，返回组内的多条文档 max_concurrent_group_searches Integer 0（不限制） 内部 inner_hits 请求的最大并发数 使用 inner_hits 展开 # 默认每组只返回一条文档。通过 inner_hits 可以展开每组，返回组内的 Top-N 文档：</description></item><item><title>高亮</title><link>/easysearch/main/docs/features/query-dsl/highlight/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/query-dsl/highlight/</guid><description>高亮用于在返回结果中突出显示命中的查询词，方便用户快速定位关键信息。
相关指南 # 高亮 基础用法 # 在查询体中添加 highlight 段即可启用：
GET shakespeare/_search { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;text_entry&amp;#34;: &amp;#34;life&amp;#34; } }, &amp;#34;highlight&amp;#34;: { &amp;#34;fields&amp;#34;: { &amp;#34;text_entry&amp;#34;: {} } } } 响应中每条命中文档会带一个 highlight 对象，默认使用 &amp;lt;em&amp;gt; 标签包裹：
&amp;#34;highlight&amp;#34;: { &amp;#34;text_entry&amp;#34;: [ &amp;#34;my &amp;lt;em&amp;gt;life&amp;lt;/em&amp;gt;, except my &amp;lt;em&amp;gt;life&amp;lt;/em&amp;gt;.&amp;#34; ] } 自定义标签 # 通过 pre_tags / post_tags 自定义包裹标签：
GET shakespeare/_search { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;play_name&amp;#34;: &amp;#34;Henry IV&amp;#34; } }, &amp;#34;highlight&amp;#34;: { &amp;#34;pre_tags&amp;#34;: [&amp;#34;&amp;lt;strong&amp;gt;&amp;#34;], &amp;#34;post_tags&amp;#34;: [&amp;#34;&amp;lt;/strong&amp;gt;&amp;#34;], &amp;#34;fields&amp;#34;: { &amp;#34;play_name&amp;#34;: {} } } } 也可以使用 &amp;quot;tags_schema&amp;quot;: &amp;quot;styled&amp;quot; 启用内置的多级标签样式（&amp;lt;em class=&amp;quot;hlt1&amp;quot;&amp;gt;、&amp;lt;em class=&amp;quot;hlt2&amp;quot;&amp;gt; 等）。</description></item></channel></rss>