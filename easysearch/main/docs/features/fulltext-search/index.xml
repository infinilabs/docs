<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>全文搜索 on INFINI Easysearch (main)</title><link>/easysearch/main/docs/features/fulltext-search/</link><description>Recent content in 全文搜索 on INFINI Easysearch (main)</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/main/docs/features/fulltext-search/index.xml" rel="self" type="application/rss+xml"/><item><title>全文检索</title><link>/easysearch/main/docs/features/fulltext-search/fulltext-search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/fulltext-search/fulltext-search/</guid><description>全文检索的核心特点是：对 text 字段做分词与评分，用“相关性”来排序结果。本页只关注最常用的几类查询及常见坑。
前提：字段必须是可分析（text）类型 # 全文查询（match/match_phrase/multi_match 等）应该作用在 text 字段 上：
写入时会通过 analyzer 做分词、归一化（大小写、同义词等） 查询时会用同一个 analyzer 处理查询词，再去匹配倒排索引 如果字段是 keyword/数值/日期，更适合使用 Term 级别查询。
match：最常用的全文查询 # match 会：
对查询字符串分词 按字段的 analyzer 处理 把多个词项组合成一个全文查询，并参与 _score 计算 示例：
{ &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;title&amp;#34;: &amp;#34;分布式 搜索 引擎&amp;#34; } } } 常见参数：
operator：or（默认）或 and minimum_should_match：要求最少命中多少词 一个直觉对比：
operator: &amp;quot;and&amp;quot;：所有词都必须出现，召回会明显变少，但结果通常更“干净” minimum_should_match: &amp;quot;75%&amp;quot;：允许部分词缺失，在“可搜到”和“不要太多噪声”之间找折中 示例（用户搜索“分布式 搜索 引擎 调优”）：
{ &amp;#34;match&amp;#34;: { &amp;#34;title&amp;#34;: { &amp;#34;query&amp;#34;: &amp;#34;分布式 搜索 引擎 调优&amp;#34;, &amp;#34;minimum_should_match&amp;#34;: &amp;#34;75%&amp;#34; } } } 这样“差一个词”的结果还能被召回，但完全不相关的长条内容会被剪掉。</description></item><item><title>部分匹配</title><link>/easysearch/main/docs/features/fulltext-search/partial-matching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/fulltext-search/partial-matching/</guid><description>部分匹配允许用户输入“词的一部分”，并找出包含该片段的词项。全文检索很多时候并不需要它（分析器已经做了词干/同义词等处理），但在权威指南总结的几类场景中，部分匹配非常有价值：
精确值字段：邮编、产品序列号等以固定前缀/模式出现的值 输入即搜索（search-as-you-type）：用户还没输完就给出候选结果 复合词语言：德语/荷兰语等将多个词组合成长词 本页按“查询时方案 → 索引时优化”的顺序展开，并重点强调性能与可控性。
查询时方案 1：prefix 前缀查询 # 查找所有以 W1 开头的邮编：
GET /my_index/_search { &amp;#34;query&amp;#34;: { &amp;#34;prefix&amp;#34;: { &amp;#34;postcode&amp;#34;: &amp;#34;W1&amp;#34; } } } prefix 是词项级查询，不会分析输入，它做的事情近似于：
扫描倒排词典（有序词列表），找到第一个以 W1 开头的词 收集该词对应的文档 ID 向后移动，继续收集所有以 W1 开头的词，直到遇到不再匹配的词 重要的性能结论（权威指南强调）：前缀越短，扫描的词越多；当唯一词很多时，前缀查询的伸缩性并不好。尽量使用更长的前缀，或者转向索引时优化方案（见下文）。
查询时方案 2：wildcard / regexp（更灵活，也更危险） # 通配符查询（? 匹配一个字符，* 匹配 0 或多个字符）：
GET /my_index/_search { &amp;#34;query&amp;#34;: { &amp;#34;wildcard&amp;#34;: { &amp;#34;postcode&amp;#34;: &amp;#34;W?F*HW&amp;#34; } } } 正则表达式查询：
GET /my_index/_search { &amp;#34;query&amp;#34;: { &amp;#34;regexp&amp;#34;: { &amp;#34;postcode&amp;#34;: &amp;#34;W[0-9].</description></item><item><title>邻近匹配</title><link>/easysearch/main/docs/features/fulltext-search/proximity-matching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/fulltext-search/proximity-matching/</guid><description>标准全文检索可以把字段视为“一袋词”（bag of words）：match 能告诉你这些词是否存在，但无法表达词与词之间的顺序与距离。这会导致一些明显不合理的匹配：
Sue ate the alligator. The alligator ate Sue. Sue never goes anywhere without her alligator-skin purse. 搜索 sue alligator 时，上面三句都会被 match 命中，但它们的语义完全不同。邻近匹配（proximity matching）并不能“理解语义”，但它能利用位置信息来判断词项是否相邻、是否接近，从而让结果更符合直觉。
match_phrase：短语匹配 # match_phrase 是最常用的位置敏感查询：要求词项按顺序出现，并且位置相邻。
GET /my_index/_search { &amp;#34;query&amp;#34;: { &amp;#34;match_phrase&amp;#34;: { &amp;#34;title&amp;#34;: &amp;#34;quick brown fox&amp;#34; } } } 它的核心逻辑是：查询字符串先被分析为词项列表，然后只保留那些同时包含全部词项，且词项位置关系一致的文档。
词项位置（position）从哪来？ # 分词不仅会产出 tokens，还会产出 position。你可以用 _analyze 观察：
GET /_analyze { &amp;#34;analyzer&amp;#34;: &amp;#34;standard&amp;#34;, &amp;#34;text&amp;#34;: &amp;#34;Quick brown fox&amp;#34; } 典型输出会包含 position（示意）：
quick：position 1 brown：position 2 fox：position 3 短语 quick brown fox 能匹配的条件就是：</description></item><item><title>多字段搜索</title><link>/easysearch/main/docs/features/fulltext-search/multi-field-search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/fulltext-search/multi-field-search/</guid><description>真实的搜索很少是单个字段的 match。更常见的是：
同一条查询要在多个字段上执行（标题/正文/标签） 不同的查询片段要映射到不同字段（标题 vs 作者） 多个字段共同组成一个“实体”（姓名、地址），每个词可能落在不同字段里 难点在于：匹配结果怎么合并、相关性怎么计算。这一页会按权威指南的三种典型场景，给出可直接落地的查询结构。
场景 1：多字符串、多字段（你知道每个词该搜哪个字段） # 例如你要找作者 Leo Tolstoy 写的《War and Peace》：
GET /_search { &amp;#34;query&amp;#34;: { &amp;#34;bool&amp;#34;: { &amp;#34;should&amp;#34;: [ { &amp;#34;match&amp;#34;: { &amp;#34;title&amp;#34;: &amp;#34;War and Peace&amp;#34; } }, { &amp;#34;match&amp;#34;: { &amp;#34;author&amp;#34;: &amp;#34;Leo Tolstoy&amp;#34; } } ] } } } bool 查询采用“匹配越多越好”的策略：匹配到更多 should 子句的文档会得到更高 _score。
语句优先级：用 boost 做权重分配 # 当有些子句更重要（例如标题、作者比译者更重要），可以给关键子句加 boost：
GET /_search { &amp;#34;query&amp;#34;: { &amp;#34;bool&amp;#34;: { &amp;#34;should&amp;#34;: [ { &amp;#34;match&amp;#34;: { &amp;#34;title&amp;#34;: { &amp;#34;query&amp;#34;: &amp;#34;War and Peace&amp;#34;, &amp;#34;boost&amp;#34;: 2 } } }, { &amp;#34;match&amp;#34;: { &amp;#34;author&amp;#34;: { &amp;#34;query&amp;#34;: &amp;#34;Leo Tolstoy&amp;#34;, &amp;#34;boost&amp;#34;: 2 } } }, { &amp;#34;bool&amp;#34;: { &amp;#34;should&amp;#34;: [ { &amp;#34;match&amp;#34;: { &amp;#34;translator&amp;#34;: &amp;#34;Constance Garnett&amp;#34; } }, { &amp;#34;match&amp;#34;: { &amp;#34;translator&amp;#34;: &amp;#34;Louise Maude&amp;#34; } } ] } } ] } } } 经验：boost 往往不需要非常大。通常从 1~10 试起，配合真实样本不断调试更可靠。</description></item><item><title>分页与排序</title><link>/easysearch/main/docs/features/fulltext-search/pagination-and-sorting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/fulltext-search/pagination-and-sorting/</guid><description>分页与排序看似简单，但在分布式搜索里细节很多。本页聚焦几种常见分页方式的适用场景，以及排序字段选择上的坑。
from/size：小页场景的首选 # from + size 适合：
页码较小（例如前几十页以内）的分页 结果集总量不特别大 特点：
使用简单，语义直观（类似 SQL 的 OFFSET/LIMIT） 页码越大，开销越大（需要跳过前面的结果） 参数说明：
size：显示应该返回的结果数量，默认是 10 from：显示应该跳过的初始结果数量，默认是 0 如果每页展示 5 条结果，可以用下面方式请求得到 1 到 3 页的结果：
GET /_search?size=5 GET /_search?size=5&amp;amp;from=5 GET /_search?size=5&amp;amp;from=10 深度分页的问题 # 理解为什么深度分页是有问题的，我们可以假设在一个有 5 个主分片的索引中搜索。
当我们请求结果的第一页（结果从 1 到 10），每一个分片产生前 10 的结果，并且返回给协调节点，协调节点对 50 个结果排序得到全部结果的前 10 个。
现在假设我们请求第 1000 页——结果从 10001 到 10010。所有都以相同的方式工作，除了每个分片不得不产生前 10010 个结果以外。然后协调节点对全部 50050 个结果排序，最后丢弃掉这些结果中的 50040 个结果。
可以看到，在分布式系统中，对结果排序的成本随分页的深度成线性上升。这就是为什么 web 搜索引擎对任何查询都不要返回超过 1000 个结果的原因。</description></item><item><title>高亮</title><link>/easysearch/main/docs/features/fulltext-search/highlighting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/fulltext-search/highlighting/</guid><description>高亮用于在返回结果中标记命中的文本片段，提升可读性。Easysearch 在搜索阶段记录哪些文本片段匹配了查询，在返回阶段根据这些信息对原文做截取与包裹（例如 &amp;lt;em&amp;gt;...&amp;lt;/em&amp;gt; 标签）。
基本用法 # GET /articles/_search { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;content&amp;#34;: &amp;#34;搜索 引擎&amp;#34; } }, &amp;#34;highlight&amp;#34;: { &amp;#34;fields&amp;#34;: { &amp;#34;content&amp;#34;: {} } } } 返回结果中每条命中文档会包含 highlight 字段：
{ &amp;#34;hits&amp;#34;: { &amp;#34;hits&amp;#34;: [ { &amp;#34;_source&amp;#34;: { &amp;#34;content&amp;#34;: &amp;#34;Easysearch 是一款高性能的搜索引擎...&amp;#34; }, &amp;#34;highlight&amp;#34;: { &amp;#34;content&amp;#34;: [ &amp;#34;Easysearch 是一款高性能的&amp;lt;em&amp;gt;搜索&amp;lt;/em&amp;gt;&amp;lt;em&amp;gt;引擎&amp;lt;/em&amp;gt;...&amp;#34; ] } } ] } } 三种高亮器类型 # Easysearch 支持三种高亮器，通过 type 参数指定：
类型 说明 优缺点 unified（默认） 基于 Lucene Unified Highlighter，使用 BM25 对片段评分 推荐首选。支持所有字段类型，性能与准确性平衡最佳 plain 基于标准 Lucene Highlighter，逐词高亮 小文本场景尚可，大文本或复杂查询时性能较差 fvh Fast Vector Highlighter，需要 term_vector 设置为 with_positions_offsets 大文本高亮最快，但需要额外索引存储 使用 FVH 高亮器 # PUT /articles { &amp;#34;mappings&amp;#34;: { &amp;#34;properties&amp;#34;: { &amp;#34;content&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;text&amp;#34;, &amp;#34;term_vector&amp;#34;: &amp;#34;with_positions_offsets&amp;#34; } } } } GET /articles/_search { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;content&amp;#34;: &amp;#34;搜索 引擎&amp;#34; } }, &amp;#34;highlight&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;fvh&amp;#34;, &amp;#34;fields&amp;#34;: { &amp;#34;content&amp;#34;: {} } } } 常用参数 # GET /articles/_search { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;content&amp;#34;: &amp;#34;搜索 引擎&amp;#34; } }, &amp;#34;highlight&amp;#34;: { &amp;#34;pre_tags&amp;#34;: [&amp;#34;&amp;lt;strong&amp;gt;&amp;#34;], &amp;#34;post_tags&amp;#34;: [&amp;#34;&amp;lt;/strong&amp;gt;&amp;#34;], &amp;#34;fields&amp;#34;: { &amp;#34;content&amp;#34;: { &amp;#34;fragment_size&amp;#34;: 150, &amp;#34;number_of_fragments&amp;#34;: 3, &amp;#34;no_match_size&amp;#34;: 100 }, &amp;#34;title&amp;#34;: { &amp;#34;number_of_fragments&amp;#34;: 0 } } } } 参数速查 # 参数 类型 默认值 说明 pre_tags String[] [&amp;quot;&amp;lt;em&amp;gt;&amp;quot;] 高亮前标签 post_tags String[] [&amp;quot;&amp;lt;/em&amp;gt;&amp;quot;] 高亮后标签 fragment_size Integer 100 每个片段的字符数 number_of_fragments Integer 5 每字段返回的最大片段数。设为 0 返回整个字段 no_match_size Integer 0 无匹配时从字段开头返回的字符数 type String &amp;quot;unified&amp;quot; 高亮器类型：unified、plain、fvh order String - 设为 &amp;quot;score&amp;quot; 按相关性排序片段 require_field_match Boolean true 只高亮查询匹配到的字段 encoder String &amp;quot;default&amp;quot; &amp;quot;default&amp;quot; 或 &amp;quot;html&amp;quot;（对 HTML 特殊字符编码） highlight_query Object - 使用不同于搜索查询的查询来做高亮 boundary_scanner String &amp;quot;sentence&amp;quot;（unified）/ &amp;quot;chars&amp;quot;（plain/fvh） 边界扫描器：chars、word、sentence boundary_chars String &amp;quot;.</description></item><item><title>排名评估（Rank Eval）</title><link>/easysearch/main/docs/features/fulltext-search/rank-eval/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/fulltext-search/rank-eval/</guid><description>排名评估（Rank Eval） # 排名评估 API（_rank_eval）允许您使用一组预定义的查询和已知相关文档来评估搜索结果的排名质量。这对于调优搜索相关性、对比不同查询策略的效果非常有用。
基本概念 # 排名评估的核心流程：
定义请求集：一组代表性的搜索查询 标注相关文档：为每个查询标注哪些文档是相关的（及其相关程度） 选择评估指标：如 Precision、Recall、DCG 等 执行评估：Easysearch 运行查询并根据标注计算指标得分 基本用法 # GET my_index/_rank_eval { &amp;#34;requests&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;query_1&amp;#34;, &amp;#34;request&amp;#34;: { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;title&amp;#34;: &amp;#34;搜索引擎&amp;#34; } } }, &amp;#34;ratings&amp;#34;: [ { &amp;#34;_index&amp;#34;: &amp;#34;my_index&amp;#34;, &amp;#34;_id&amp;#34;: &amp;#34;doc1&amp;#34;, &amp;#34;rating&amp;#34;: 3 }, { &amp;#34;_index&amp;#34;: &amp;#34;my_index&amp;#34;, &amp;#34;_id&amp;#34;: &amp;#34;doc2&amp;#34;, &amp;#34;rating&amp;#34;: 2 }, { &amp;#34;_index&amp;#34;: &amp;#34;my_index&amp;#34;, &amp;#34;_id&amp;#34;: &amp;#34;doc3&amp;#34;, &amp;#34;rating&amp;#34;: 0 } ] }, { &amp;#34;id&amp;#34;: &amp;#34;query_2&amp;#34;, &amp;#34;request&amp;#34;: { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;title&amp;#34;: &amp;#34;全文检索&amp;#34; } } }, &amp;#34;ratings&amp;#34;: [ { &amp;#34;_index&amp;#34;: &amp;#34;my_index&amp;#34;, &amp;#34;_id&amp;#34;: &amp;#34;doc4&amp;#34;, &amp;#34;rating&amp;#34;: 3 }, { &amp;#34;_index&amp;#34;: &amp;#34;my_index&amp;#34;, &amp;#34;_id&amp;#34;: &amp;#34;doc5&amp;#34;, &amp;#34;rating&amp;#34;: 1 } ] } ], &amp;#34;metric&amp;#34;: { &amp;#34;precision&amp;#34;: { &amp;#34;k&amp;#34;: 10, &amp;#34;relevant_rating_threshold&amp;#34;: 1 } } } 请求参数说明 # 字段 说明 requests 评估请求数组 requests[].</description></item><item><title>建议与纠错</title><link>/easysearch/main/docs/features/fulltext-search/suggestions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/fulltext-search/suggestions/</guid><description>Easysearch 提供三种 Suggester（建议器），覆盖&amp;quot;拼写纠正→短语纠正→前缀补全&amp;quot;三个典型场景：
Suggester 用途 工作方式 Term Suggester 单词拼写纠正 基于编辑距离，对每个词项找索引中相似的词 Phrase Suggester 短语级纠正（&amp;ldquo;Did you mean …?&amp;quot;） 使用 N-gram 语言模型对整个短语做纠正 Completion Suggester 前缀自动补全 基于 FST 数据结构常驻内存，毫秒级响应 所有 Suggester 通过 _search 请求的 suggest 参数调用，可以与 query 同时使用。
Term Suggester（单词纠正） # 对单个词项，基于编辑距离在索引中查找相似候选词。
GET /articles/_search { &amp;#34;suggest&amp;#34;: { &amp;#34;spell-check&amp;#34;: { &amp;#34;text&amp;#34;: &amp;#34;quer&amp;#34;, &amp;#34;term&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;content&amp;#34;, &amp;#34;suggest_mode&amp;#34;: &amp;#34;popular&amp;#34; } } } } 返回示例：</description></item></channel></rss>