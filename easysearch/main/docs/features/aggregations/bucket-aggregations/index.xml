<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>桶聚合 on INFINI Easysearch</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/</link><description>Recent content in 桶聚合 on INFINI Easysearch</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/main/docs/features/aggregations/bucket-aggregations/index.xml" rel="self" type="application/rss+xml"/><item><title>IP 范围聚合（IP Range）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/ip-range/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/ip-range/</guid><description>IP 范围聚合 # ip_range 聚合用于 IP 地址。它适用于 ip 类型字段。您可以在 CIDR 表示法中定义 IP 范围和掩码。
相关指南（先读这些） # 聚合基础 聚合场景实践 GET sample_data_logs/_search { &amp;#34;size&amp;#34;: 0, &amp;#34;aggs&amp;#34;: { &amp;#34;access&amp;#34;: { &amp;#34;ip_range&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;ip&amp;#34;, &amp;#34;ranges&amp;#34;: [ { &amp;#34;from&amp;#34;: &amp;#34;1.0.0.0&amp;#34;, &amp;#34;to&amp;#34;: &amp;#34;126.158.155.183&amp;#34; }, { &amp;#34;mask&amp;#34;: &amp;#34;1.0.0.0/8&amp;#34; } ] } } } } 返回内容
... &amp;#34;aggregations&amp;#34; : { &amp;#34;access&amp;#34; : { &amp;#34;buckets&amp;#34; : [ { &amp;#34;key&amp;#34; : &amp;#34;1.0.0.0/8&amp;#34;, &amp;#34;from&amp;#34; : &amp;#34;1.</description></item><item><title>全局聚合（Global）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/global/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/global/</guid><description>全局聚合 # global 聚合让你能跳出过滤聚合的聚合上下文。即使你包含了一个缩小文档集的过滤查询，global 聚合仍然对所有文档进行聚合，就好像过滤查询不存在一样。它忽略 filter 聚合，并隐式地假设 match_all 查询。
相关指南（先读这些） # 聚合基础 聚合场景实践 以下示例返回索引中所有文档的 taxful_total_price 字段的 avg 值：
GET sample_data_ecommerce/_search { &amp;#34;size&amp;#34;: 0, &amp;#34;query&amp;#34;: { &amp;#34;range&amp;#34;: { &amp;#34;taxful_total_price&amp;#34;: { &amp;#34;lte&amp;#34;: 50 } } }, &amp;#34;aggs&amp;#34;: { &amp;#34;total_avg_amount&amp;#34;: { &amp;#34;global&amp;#34;: {}, &amp;#34;aggs&amp;#34;: { &amp;#34;avg_price&amp;#34;: { &amp;#34;avg&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;taxful_total_price&amp;#34; } } } } } } 返回内容
... &amp;#34;aggregations&amp;#34; : { &amp;#34;total_avg_amount&amp;#34; : { &amp;#34;doc_count&amp;#34; : 4675, &amp;#34;avg_price&amp;#34; : { &amp;#34;value&amp;#34; : 75.</description></item><item><title>反向嵌套聚合（Reverse Nested）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/reverse-nested/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/reverse-nested/</guid><description>反向嵌套聚合 # 您可以将嵌套文档中的值聚合到其父文档中；这种聚合称为 reverse_nested。您可以使用 reverse_nested 在按嵌套对象中的字段分组后，聚合父文档中的字段。reverse_nested 聚合将&amp;quot;连接回&amp;quot;根页面，并为您的各种变体获取 load_time。
reverse_nested 聚合是嵌套聚合中的一个子聚合。它接受一个名为 path 的选项。此选项定义 Easysearch 在计算聚合时在文档层次结构中向后退多少步。
相关指南（先读这些） # 聚合基础 Nested 建模 聚合场景实践 GET logs/_search { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;response&amp;#34;: &amp;#34;200&amp;#34; } }, &amp;#34;aggs&amp;#34;: { &amp;#34;pages&amp;#34;: { &amp;#34;nested&amp;#34;: { &amp;#34;path&amp;#34;: &amp;#34;pages&amp;#34; }, &amp;#34;aggs&amp;#34;: { &amp;#34;top_pages_per_load_time&amp;#34;: { &amp;#34;terms&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;pages.load_time&amp;#34; }, &amp;#34;aggs&amp;#34;: { &amp;#34;comment_to_logs&amp;#34;: { &amp;#34;reverse_nested&amp;#34;: {}, &amp;#34;aggs&amp;#34;: { &amp;#34;min_load_time&amp;#34;: { &amp;#34;min&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;pages.load_time&amp;#34; } } } } } } } } } } 返回内容</description></item><item><title>可变宽度直方图聚合（Variable Width Histogram）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/variable-width-histogram/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/variable-width-histogram/</guid><description>可变宽度直方图聚合 # variable_width_histogram 聚合与标准 histogram 聚合类似，但它会自动调整每个桶的宽度，使数据点在各桶之间尽可能均匀分布。该聚合使用聚类算法，根据数据的实际分布动态确定最优的桶边界，而不是使用固定间隔。
这在数据分布不均匀时特别有用 —— 例如，大部分值集中在某个范围内，但也有少量离群值。使用固定间隔的 histogram 可能导致大量空桶或单个桶内文档过多，而 variable_width_histogram 能自适应地解决这些问题。
相关指南（先读这些） # 聚合基础 聚合场景实践 直方图聚合（固定宽度版本） 参数说明 # 参数 必需/可选 数据类型 描述 field 必填 String 要聚合的数值字段。必须为数值类型。也可使用 script 替代。 buckets 可选 Integer 期望的桶数量。实际返回的桶数量可能小于或等于此值。默认 10。必须大于 0。 shard_size 可选 Integer 每个分片上用于聚类的文档数量。值越大结果越精确，但内存消耗越大。默认为 buckets * 50。必须大于 1。 initial_buffer 可选 Integer 初始缓冲区大小，用于收集初始数据点以启动聚类算法。默认为 min(10 * shard_size, 50000)。必须大于 0 且不小于 buckets。 script 可选 Object 使用脚本动态生成聚合值。 missing 可选 Numeric 缺少字段值的文档所使用的替代值。 基本用法 # 以下示例将商品价格分成 5 个自适应宽度的桶：</description></item><item><title>地理距离聚合（Geo Distance）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/geo-distance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/geo-distance/</guid><description>地理距离聚合 # geo_distance 聚合根据与一个起始 geo_point 字段距离将文档分组到同心圆中。它与 range 聚合相同，只是它作用于地理位置。
相关指南（先读这些） # 聚合基础 地理位置搜索 Geo 场景实践 例如，你可以使用 geo_distance 聚合来查找你 1 公里范围内的所有披萨店。搜索结果仅限于你指定的 1 公里半径范围内，但你还可以添加另一个在 2 公里范围内找到的结果。
您只能对映射为 geo_point 的字段使用 geo_distance 聚合。
点是一个单一的地理坐标，例如您智能手机显示的当前位置。在 Easysearch 中，点表示如下：
{ &amp;#34;location&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;point&amp;#34;, &amp;#34;coordinates&amp;#34;: { &amp;#34;lat&amp;#34;: 83.76, &amp;#34;lon&amp;#34;: -81.2 } } } 您还可以将纬度和经度指定为数组 [-81.20, 83.76] 或字符串 &amp;quot;83.76, -81.20&amp;quot;
此表列出了 geo_distance 聚合的相关字段：
字段 必需/可选 描述 field 必需 指定您要处理的地理点字段。 origin 必需 指定用于计算距离的地理点。 ranges 必需 指定一组范围，根据文档与目标点的距离收集文档。 unit 可选 定义 ranges 数组中使用的单位。 unit 默认为 m （米），但你可以切换到其他单位，如 km （千米）、 mi （英里）、 in （英寸）、 yd （码）、 cm （厘米）和 mm （毫米）。 distance_type 可选 指定 Easysearch 如何计算距离。默认值为 sloppy_arc （更快但精度较低），也可以设置为 arc （较慢但最精确）或 plane （最快但精度最低）。由于误差范围较大，仅适用于小地理区域使用 plane 。 语法如下：</description></item><item><title>复合聚合（Composite）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/composite/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/composite/</guid><description>复合聚合 # composite 聚合基于一个或多个文档字段或源创建分组。composite 聚合为每个单独源值的组合创建一个分组。默认情况下，如果一个或多个字段中缺少值，则这些组合会从结果中省略。
相关指南（先读这些） # 聚合基础 聚合场景实践 每个源有四种类型的聚合之一：
terms 类型按唯一（通常是 String ）值分组。 histogram 类型按指定宽度数值分组。 date_histogram 类型按指定宽度的日期或时间范围分组。 geotile_grid 类型按指定分辨率将地理点分组到网格中。 composite 聚合通过将其源键组合到分组中来工作。生成的分组是有序的，跨源(Across)和源内部(Within)都是：
Across：分组按聚合请求中源的顺序嵌套。 Within:每个源中值的顺序决定了该源的分组顺序。排序方式根据源类型适当选择，可以是字母顺序、数字顺序、日期时间顺序或地理切片顺序。 考虑一下来自马拉松参与者索引的这些字段：
{... &amp;#34;city&amp;#34;: &amp;#34;Albuquerque&amp;#34;, &amp;#34;place&amp;#34;: &amp;#34;Bronze&amp;#34; ...} {... &amp;#34;city&amp;#34;: &amp;#34;Boston&amp;#34;, ...} {... &amp;#34;city&amp;#34;: &amp;#34;Chicago&amp;#34;, &amp;#34;place&amp;#34;: &amp;#34;Bronze&amp;#34; ...} {... &amp;#34;city&amp;#34;: &amp;#34;Albuquerque&amp;#34;, &amp;#34;place&amp;#34;: &amp;#34;Gold&amp;#34; ...} {... &amp;#34;city&amp;#34;: &amp;#34;Chicago&amp;#34;, &amp;#34;place&amp;#34;: &amp;#34;Silver&amp;#34; ...} {... &amp;#34;city&amp;#34;: &amp;#34;Boston&amp;#34;, &amp;#34;place&amp;#34;: &amp;#34;Bronze&amp;#34; ...} {... &amp;#34;city&amp;#34;: &amp;#34;Chicago&amp;#34;, &amp;#34;place&amp;#34;: &amp;#34;Gold&amp;#34; .</description></item><item><title>多样性采样聚合（Diversified Sampler）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/diversified-sampler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/diversified-sampler/</guid><description>多样性采样聚合 # diversified_sampler 聚合允许你通过去重包含相同 field 的文档来减少样本池分布的偏差。它通过使用 max_docs_per_value 和 field 设置来实现，这些设置限制了在分片上收集的 field 的最大文档数。max_docs_per_value 设置是一个可选参数，用于确定每个 field 将返回的最大文档数。此设置的默认值为 1。
与 sampler 聚合类似，你可以使用 shard_size 设置来控制在任何单个分片上收集的最大文档数，如下面的示例所示：
相关指南（先读这些） # 聚合基础 聚合性能优化 聚合场景实践 GET sample_data_logs/_search { &amp;#34;size&amp;#34;: 0, &amp;#34;aggs&amp;#34;: { &amp;#34;sample&amp;#34;: { &amp;#34;diversified_sampler&amp;#34;: { &amp;#34;shard_size&amp;#34;: 1000, &amp;#34;field&amp;#34;: &amp;#34;response.keyword&amp;#34; }, &amp;#34;aggs&amp;#34;: { &amp;#34;terms&amp;#34;: { &amp;#34;terms&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;agent.keyword&amp;#34; } } } } } } 返回内容
... &amp;#34;aggregations&amp;#34; : { &amp;#34;sample&amp;#34; : { &amp;#34;doc_count&amp;#34; : 3, &amp;#34;terms&amp;#34; : { &amp;#34;doc_count_error_upper_bound&amp;#34; : 0, &amp;#34;sum_other_doc_count&amp;#34; : 0, &amp;#34;buckets&amp;#34; : [ { &amp;#34;key&amp;#34; : &amp;#34;Mozilla/5.</description></item><item><title>多过滤器聚合（Filters）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/filters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/filters/</guid><description>多过滤器聚合 # filters 聚合与 filter 聚合相同，但它允许你使用多个过滤器聚合。filter 聚合结果为一个分组，而 filters 聚合会返回多个分组，每个定义的过滤器对应一个分组。
相关指南（先读这些） # 聚合基础 聚合场景实践 要为所有未匹配任何过滤器查询的文档创建一个分组，将 other_bucket 属性设置为 true ：
GET sample_data_logs/_search { &amp;#34;size&amp;#34;: 0, &amp;#34;aggs&amp;#34;: { &amp;#34;200_os&amp;#34;: { &amp;#34;filters&amp;#34;: { &amp;#34;other_bucket&amp;#34;: true, &amp;#34;filters&amp;#34;: [ { &amp;#34;term&amp;#34;: { &amp;#34;response.keyword&amp;#34;: &amp;#34;200&amp;#34; } }, { &amp;#34;term&amp;#34;: { &amp;#34;machine.os.keyword&amp;#34;: &amp;#34;osx&amp;#34; } } ] }, &amp;#34;aggs&amp;#34;: { &amp;#34;avg_amount&amp;#34;: { &amp;#34;avg&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;bytes&amp;#34; } } } } } } 返回内容</description></item><item><title>子文档聚合（Children）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/children/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/children/</guid><description>子文档聚合 # children 聚合是一种存储分组聚合，它根据索引中定义的父子关系创建包含子文档的单个存储分组。
children 聚合与 join 字段类型配合使用，以聚合与父文档关联的子文档。
children 聚合标识与特定子关系名称匹配的子文档，而 parent 聚合标识具有匹配子文档的父文档。这两个聚合都采用子关系名称作为输入。
相关指南（先读这些） # 聚合基础 Parent-Child 建模 聚合场景实践 参数说明 # children 聚合采用以下参数。
参数 必需/可选 数据类型 描述 type 必填 String join 字段中的子类型的名称。这标识了要使用的父子关系。 参考样例 # 以下示例构建一个包含三名员工的小型公司数据库。每个员工记录都与父部门记录具有子联接关系。
首先，创建一个 company 索引，其中包含一个将部门（父级）映射到员工（子级）的联接字段：
PUT /company { &amp;#34;mappings&amp;#34;: { &amp;#34;properties&amp;#34;: { &amp;#34;join_field&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;join&amp;#34;, &amp;#34;relations&amp;#34;: { &amp;#34;department&amp;#34;: &amp;#34;employee&amp;#34; } }, &amp;#34;department_name&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;keyword&amp;#34; }, &amp;#34;employee_name&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;keyword&amp;#34; }, &amp;#34;salary&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;double&amp;#34; }, &amp;#34;hire_date&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;date&amp;#34; } } } } 接下来，使用三个部门和三名员工填充数据。下表显示了父子分配。</description></item><item><title>嵌套聚合（Nested）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/nested/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/nested/</guid><description>嵌套聚合 # nested 聚合让你能够对嵌套对象内的字段进行聚合。nested 类型是对象数据类型的特殊版本，它允许对象数组以独立于彼此的方式进行索引，从而可以独立于彼此进行查询。
相关指南（先读这些） # 聚合基础 Nested 建模 聚合场景实践 使用 object 类型，所有数据都存储在同一个文档中，因此搜索匹配可以跨越子文档。例如，想象一个 logs 索引，其中 pages 映射为 object 数据类型：
PUT logs/_doc/0 { &amp;#34;response&amp;#34;: &amp;#34;200&amp;#34;, &amp;#34;pages&amp;#34;: [ { &amp;#34;page&amp;#34;: &amp;#34;landing&amp;#34;, &amp;#34;load_time&amp;#34;: 200 }, { &amp;#34;page&amp;#34;: &amp;#34;blog&amp;#34;, &amp;#34;load_time&amp;#34;: 500 } ] } Easysearch 合并所有看起来像这样的实体关系的子属性：
{ &amp;#34;logs&amp;#34;: { &amp;#34;pages&amp;#34;: [&amp;#34;landing&amp;#34;, &amp;#34;blog&amp;#34;], &amp;#34;load_time&amp;#34;: [&amp;#34;200&amp;#34;, &amp;#34;500&amp;#34;] } } 所以，如果你想要用 pages=landing 和 load_time=500 搜索这个索引，即使 load_time 的 landing 值为 200，这个文档也符合条件。</description></item><item><title>日期直方图聚合（Date Histogram）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/date-histogram/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/date-histogram/</guid><description>日期直方图聚合 # date_histogram 聚合使用日期计算来为时间序列数据生成直方图。
相关指南（先读这些） # 聚合基础 聚合场景实践 时间序列建模 例如，您可以找到您的网站每月有多少次访问：
GET sample_data_logs/_search { &amp;#34;size&amp;#34;: 0, &amp;#34;aggs&amp;#34;: { &amp;#34;logs_per_month&amp;#34;: { &amp;#34;date_histogram&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;@timestamp&amp;#34;, &amp;#34;interval&amp;#34;: &amp;#34;month&amp;#34; } } } } 返回内容
... &amp;#34;aggregations&amp;#34; : { &amp;#34;logs_per_month&amp;#34; : { &amp;#34;buckets&amp;#34; : [ { &amp;#34;key_as_string&amp;#34; : &amp;#34;2020-10-01T00:00:00.000Z&amp;#34;, &amp;#34;key&amp;#34; : 1601510400000, &amp;#34;doc_count&amp;#34; : 1635 }, { &amp;#34;key_as_string&amp;#34; : &amp;#34;2020-11-01T00:00:00.000Z&amp;#34;, &amp;#34;key&amp;#34; : 1604188800000, &amp;#34;doc_count&amp;#34; : 6844 }, { &amp;#34;key_as_string&amp;#34; : &amp;#34;2020-12-01T00:00:00.</description></item><item><title>日期范围聚合（Date Range）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/date-range/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/date-range/</guid><description>日期范围聚合 # date_range 聚合在概念上与 range 聚合相同，只是它允许执行日期计算。例如，你可以获取过去 10 天内的所有文档。为了使日期更易读，可以使用 format 参数包含格式：
相关指南（先读这些） # 聚合基础 聚合场景实践 时间序列建模 GET sample_data_logs/_search { &amp;#34;size&amp;#34;: 0, &amp;#34;aggs&amp;#34;: { &amp;#34;number_of_bytes&amp;#34;: { &amp;#34;date_range&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;@timestamp&amp;#34;, &amp;#34;format&amp;#34;: &amp;#34;MM-yyyy&amp;#34;, &amp;#34;ranges&amp;#34;: [ { &amp;#34;from&amp;#34;: &amp;#34;now-10d/d&amp;#34;, &amp;#34;to&amp;#34;: &amp;#34;now&amp;#34; } ] } } } } 返回内容
... &amp;#34;aggregations&amp;#34; : { &amp;#34;number_of_bytes&amp;#34; : { &amp;#34;buckets&amp;#34; : [ { &amp;#34;key&amp;#34; : &amp;#34;03-2021-03-2021&amp;#34;, &amp;#34;from&amp;#34; : 1.6145568E12, &amp;#34;from_as_string&amp;#34; : &amp;#34;03-2021&amp;#34;, &amp;#34;to&amp;#34; : 1.</description></item><item><title>显著文本聚合（Significant Text）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/significant-text/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/significant-text/</guid><description>显著文本聚合 # significant_text 聚合与 significant_terms 聚合类似，但它适用于原始文本字段。重要文本通过统计分析测量前景集和背景集之间流行度的变化。例如，当你搜索其股票缩写 TSLA 时，它可能会建议 Tesla。
significant_text 聚合会动态重新分析源文本，过滤掉重复段落、模板化的页眉和页脚等噪声数据，这些数据可能会扭曲结果。
重新分析高基数数据集可能是一项非常耗费 CPU 的操作。我们建议在采样聚合中使用 significant_text 聚合来将分析限制在少量最匹配文档中，例如 200。
相关指南（先读这些） # 聚合基础 聚合性能优化 聚合场景实践 您可以设置以下参数：
size - 返回的最大桶数量。默认 10。 min_doc_count - 返回匹配超过配置数量的 Top Hits 结果。我们不建议将 min_doc_count 设置为 1，因为它倾向于返回拼写错误或错别字。找到一个以上的词项实例有助于加强显著性不是偶然事件的结果。默认值 3 用于提供最小证据权重。 shard_size - 设置高值会增加稳定性（和准确性），但会牺牲计算性能。 shard_min_doc_count - 如果你的文本包含许多低频词，而你又不关心这些词（例如拼写错误），那么你可以将 shard_min_doc_count 参数设置为在分片级别上过滤候选词，以合理地确保即使合并本地显著文本频率也不会达到所需的 min_doc_count 。默认值为 1，直到你显式设置它之前没有影响。我们建议将此值设置得远低于 min_doc_count 值。 filter_duplicate_text - 是否过滤掉重复的文本段落（如模板化页眉/页脚）。默认 true。设为 false 可提升性能，但可能引入噪声。 假设你在一个 Easysearch 集群中索引了莎士比亚的全部作品。你可以在 text_entry 字段中找到与“breathe”相关的显著文本：</description></item><item><title>显著词项聚合（Significant Terms）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/significant-terms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/significant-terms/</guid><description>显著词项聚合 # significant_terms 聚合可以帮助你在相对于索引中其他数据的过滤子集中识别不寻常或有趣的分组出现情况。
前景集是指你进行过滤的文档集合，背景集是指索引中所有文档的集合。significant_terms 聚合会检查前景集中的所有文档，并与背景集中的文档进行对比，从而为重要出现情况找到相应的分数。
相关指南（先读这些） # 聚合基础 聚合场景实践 在示例网络日志数据中，每个文档都有一个包含访客 user-agent 的字段。此示例搜索来自 iOS 操作系统的所有请求。对这一前景集进行常规的 terms 聚合返回 Firefox，因为它在这个分组内有最多的文档数量。另一方面， significant_terms 聚合返回 Internet Explorer（IE），因为 IE 在前景集中的出现频率显著高于背景集。
GET sample_data_logs/_search { &amp;#34;size&amp;#34;: 0, &amp;#34;query&amp;#34;: { &amp;#34;terms&amp;#34;: { &amp;#34;machine.os.keyword&amp;#34;: [ &amp;#34;ios&amp;#34; ] } }, &amp;#34;aggs&amp;#34;: { &amp;#34;significant_response_codes&amp;#34;: { &amp;#34;significant_terms&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;agent.keyword&amp;#34; } } } } 返回内容
... &amp;#34;aggregations&amp;#34; : { &amp;#34;significant_response_codes&amp;#34; : { &amp;#34;doc_count&amp;#34; : 2737, &amp;#34;bg_count&amp;#34; : 14074, &amp;#34;buckets&amp;#34; : [ { &amp;#34;key&amp;#34; : &amp;#34;Mozilla/4.</description></item><item><title>父文档聚合（Parent）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/parent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/parent/</guid><description>父文档聚合 # parent 聚合是一个分组聚合，根据您索引中定义的父子关系创建一个包含父级文档的分组。此聚合使您能够对具有相同匹配子级文档的父级文档执行分析，从而实现强大的层次结构数据分析。
parent 聚合与 join 字段类型一起工作，该字段类型在同一个索引中的文档内建立父子关系。
parent 聚合识别具有匹配子文档的父文档，而 children 聚合识别匹配特定子关系的子文档。这两种聚合都使用子关系名称作为输入。
相关指南（先读这些） # 聚合基础 Parent-Child 建模 聚合场景实践 参数说明 # parent 聚合具有以下参数：
参数 必需/可选 数据类型 描述 type 必填 String join 字段中的子类型名称。 参考样例 # 以下示例构建了一个包含三名员工的小公司数据库。每个员工记录都与一个父部门记录存在 join 子关系。
首先，创建一个 company 索引，其中包含一个 join 字段，该字段将部门（父级）映射到员工（子级）：
PUT /company { &amp;#34;mappings&amp;#34;: { &amp;#34;properties&amp;#34;: { &amp;#34;join_field&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;join&amp;#34;, &amp;#34;relations&amp;#34;: { &amp;#34;department&amp;#34;: &amp;#34;employee&amp;#34; } }, &amp;#34;department_name&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;keyword&amp;#34; }, &amp;#34;employee_name&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;keyword&amp;#34; }, &amp;#34;salary&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;double&amp;#34; }, &amp;#34;hire_date&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;date&amp;#34; } } } } 接下来，用三个部门和三个员工填充数据。父子关系在以下表格中展示。</description></item><item><title>直方图聚合（Histogram）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/histogram/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/histogram/</guid><description>直方图聚合 # histogram 聚合根据指定的间隔对文档进行分组。
使用 histogram 聚合，您可以非常轻松地可视化给定范围内文档中值的分布。
相关指南（先读这些） # 聚合基础 聚合场景实践 以下示例将 number_of_bytes 字段按 10,000 个间隔进行分组：
GET sample_data_logs/_search { &amp;#34;size&amp;#34;: 0, &amp;#34;aggs&amp;#34;: { &amp;#34;number_of_bytes&amp;#34;: { &amp;#34;histogram&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;bytes&amp;#34;, &amp;#34;interval&amp;#34;: 10000 } } } } 返回内容
... &amp;#34;aggregations&amp;#34; : { &amp;#34;number_of_bytes&amp;#34; : { &amp;#34;buckets&amp;#34; : [ { &amp;#34;key&amp;#34; : 0.0, &amp;#34;doc_count&amp;#34; : 13372 }, { &amp;#34;key&amp;#34; : 10000.0, &amp;#34;doc_count&amp;#34; : 702 } ] } } 参数说明 # histogram 聚合支持以下参数。</description></item><item><title>稀有词项聚合（Rare Terms）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/rare-terms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/rare-terms/</guid><description>稀有词项聚合 # rare_terms 聚合是一个分组聚合，用于识别数据集中的不常见词项。与 terms 聚合（查找最常见的词项）不同，rare_terms 聚合查找出现频率最低的词项。rare_terms 聚合适用于异常检测、长尾分析和异常报告等应用。
相关指南（先读这些） # 聚合基础 聚合场景实践 可以使用 terms 通过按升序计数排序（ &amp;ldquo;order&amp;rdquo;: {&amp;ldquo;count&amp;rdquo;: &amp;ldquo;asc&amp;rdquo;} ）来搜索不常见的值。然而，我们强烈不建议这种做法，因为在涉及多个分片时，它可能导致不准确的结果。一个全局上不常见的词项可能不会在每个单个分片上显得不常见，或者可能完全不在某些分片返回的最不常见结果中。相反，一个在某个分片上出现频率较低的词项可能在另一个分片上很常见。在这两种情况下，分片级别的聚合可能会遗漏稀有词项，导致整体结果不正确。我们建议使用 rare_terms 聚合代替 terms 聚合，它专门设计用于更准确地处理这些情况。
近似结果 # 计算 rare_terms 聚合的精确结果需要编译所有分片上的值完整映射，这需要过多的运行时内存。因此， rare_terms 聚合结果被近似处理。
rare_terms 计算中的大多数错误是假阴性或“遗漏”的值，这些值定义了聚合检测测试的灵敏度。 rare_terms 聚合使用 CuckooFilter 算法以实现适当的灵敏度和可接受的内存使用平衡。有关 CuckooFilter 算法的描述，请参阅这篇论文。
控制灵敏度 # rare_terms 聚合算法中的灵敏度误差被衡量为被遗漏的稀有值的比例，或 false negatives/target values 。例如，如果聚合在包含 5,000 个稀有值的数据集中遗漏了 100 个稀有值，灵敏度误差为 100/5000 = 0.02 ，或 2%。
您可以调整 precision 参数在 rare_terms 聚合中来控制灵敏度和内存使用之间的权衡。</description></item><item><title>缺失值聚合（Missing）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/missing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/missing/</guid><description>缺失值聚合 # 如果你的索引中的文档完全不包含聚合字段，或者聚合字段的值为 null，请使用 missing 参数指定这些文档应该放入的分组的名称。
相关指南（先读这些） # 聚合基础 聚合场景实践 以下示例将任何缺失的值添加到名为“N/A”的分组中：
GET sample_data_logs/_search { &amp;#34;size&amp;#34;: 0, &amp;#34;aggs&amp;#34;: { &amp;#34;response_codes&amp;#34;: { &amp;#34;terms&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;response.keyword&amp;#34;, &amp;#34;size&amp;#34;: 10, &amp;#34;missing&amp;#34;: &amp;#34;N/A&amp;#34; } } } } 由于 min_doc_count 参数的默认值为 1， missing 参数在其响应中不会返回任何分组。将 min_doc_count 参数设置为 0 以在响应中查看“N/A”分组：
GET sample_data_logs/_search { &amp;#34;size&amp;#34;: 0, &amp;#34;aggs&amp;#34;: { &amp;#34;response_codes&amp;#34;: { &amp;#34;terms&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;response.keyword&amp;#34;, &amp;#34;size&amp;#34;: 10, &amp;#34;missing&amp;#34;: &amp;#34;N/A&amp;#34;, &amp;#34;min_doc_count&amp;#34;: 0 } } } } 返回内容</description></item><item><title>自动间隔日期直方图聚合（Auto Date Histogram）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/auto-interval-date-histogram/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/auto-interval-date-histogram/</guid><description>自动间隔日期直方图聚合 # 与日期直方图聚合类似，其中你必须指定一个间隔，auto_date_histogram 是一个多分组聚合，根据你提供的分组数量和数据的时范围自动创建日期直方图分组。返回的实际分组数量总是小于或等于你指定的分组数量。当你在处理时间序列数据并希望在不同时间间隔上可视化或分析数据，而不需要手动指定间隔大小时，这种聚合特别有用。
相关指南（先读这些） # 聚合基础 聚合场景实践 时间序列建模 间隔参数 # 分组间隔是根据收集的数据选择的，以确保返回的分组数量小于或等于请求的数量。
下表列出了每个时间单位可能的返回间隔。
单位 间隔参数 Seconds 1、5、10 和 30 的倍数 Minutes 1、5、10 和 30 的倍数 Hours 1、3 和 12 的倍数 Days 1 和 7 的倍数 Months 1 和 3 的倍数 Years 1、5、10、20、50 和 100 的倍数 如果一个聚合返回的分组太多（例如，每天一个分组），Easysearch 会自动减少分组的数量以确保结果可管理。它不会返回请求的确切数量的每日分组，而是会减少大约 1/7。例如，如果你请求 70 个分组，但数据中包含太多的每日间隔，Easysearch 可能只会返回 10 个分组，将数据分组到更大的间隔（如周）中，以避免结果数量过多。这有助于优化聚合，并在数据过多时防止过多细节。</description></item><item><title>范围聚合（Range）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/range/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/range/</guid><description>范围聚合 # range 聚合允许你为每个分组定义范围。
相关指南（先读这些） # 聚合基础 聚合场景实践 例如，你可以找到在 1000 和 2000 之间、2000 和 3000 之间以及 3000 和 4000 之间的字节数。在 range 参数中，你可以将范围定义为数组对象。
GET sample_data_logs/_search { &amp;#34;size&amp;#34;: 0, &amp;#34;aggs&amp;#34;: { &amp;#34;number_of_bytes_distribution&amp;#34;: { &amp;#34;range&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;bytes&amp;#34;, &amp;#34;ranges&amp;#34;: [ { &amp;#34;from&amp;#34;: 1000, &amp;#34;to&amp;#34;: 2000 }, { &amp;#34;from&amp;#34;: 2000, &amp;#34;to&amp;#34;: 3000 }, { &amp;#34;from&amp;#34;: 3000, &amp;#34;to&amp;#34;: 4000 } ] } } } } 响应包含 from 键值，并排除 to 键值：</description></item><item><title>词项聚合（Terms）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/terms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/terms/</guid><description>词项聚合 # terms 聚合会动态为字段中的每个唯一词条创建一个分组。
相关指南（先读这些） # 聚合基础 聚合场景实践 以下示例使用 terms 聚合来查找网络日志数据中每个响应代码的文档数量：
GET sample_data_logs/_search { &amp;#34;size&amp;#34;: 0, &amp;#34;aggs&amp;#34;: { &amp;#34;response_codes&amp;#34;: { &amp;#34;terms&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;response.keyword&amp;#34;, &amp;#34;size&amp;#34;: 10 } } } } 返回内容
... &amp;#34;aggregations&amp;#34; : { &amp;#34;response_codes&amp;#34; : { &amp;#34;doc_count_error_upper_bound&amp;#34; : 0, &amp;#34;sum_other_doc_count&amp;#34; : 0, &amp;#34;buckets&amp;#34; : [ { &amp;#34;key&amp;#34; : &amp;#34;200&amp;#34;, &amp;#34;doc_count&amp;#34; : 12832 }, { &amp;#34;key&amp;#34; : &amp;#34;404&amp;#34;, &amp;#34;doc_count&amp;#34; : 801 }, { &amp;#34;key&amp;#34; : &amp;#34;503&amp;#34;, &amp;#34;doc_count&amp;#34; : 441 } ] } } } 值以 key 键返回。 doc_count 指定每个分组中的文档数量。默认情况下，分组按 doc-count 的降序排列。</description></item><item><title>过滤器聚合（Filter）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/filter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/filter/</guid><description>过滤器聚合 # filter 聚合是一个查询子句，就像一个搜索查询一样 — match 或 term 或 range。您可以使用 filter 聚合在创建分组之前将整个文档集缩小到特定的文档集。
相关指南（先读这些） # 聚合基础 聚合场景实践 以下示例展示了 avg 聚合在过滤上下文中运行的情况。 avg 聚合仅聚合与 range 查询匹配的文档：
GET sample_data_ecommerce/_search { &amp;#34;size&amp;#34;: 0, &amp;#34;aggs&amp;#34;: { &amp;#34;low_value&amp;#34;: { &amp;#34;filter&amp;#34;: { &amp;#34;range&amp;#34;: { &amp;#34;taxful_total_price&amp;#34;: { &amp;#34;lte&amp;#34;: 50 } } }, &amp;#34;aggs&amp;#34;: { &amp;#34;avg_amount&amp;#34;: { &amp;#34;avg&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;taxful_total_price&amp;#34; } } } } } } 返回内容
... &amp;#34;aggregations&amp;#34; : { &amp;#34;low_value&amp;#34; : { &amp;#34;doc_count&amp;#34; : 1633, &amp;#34;avg_amount&amp;#34; : { &amp;#34;value&amp;#34; : 38.</description></item><item><title>邻接矩阵聚合（Adjacency Matrix）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/adjacency-matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/adjacency-matrix/</guid><description>邻接矩阵聚合 # adjacency_matrix 聚合允许你定义过滤表达式，并返回一个交集矩阵，矩阵中的每个非空单元格代表一个分组。你可以找到落入任何过滤器组合中的文档数量。
使用 adjacency_matrix 聚合通过将数据可视化为图形来发现概念之间的关联。
相关指南（先读这些） # 聚合基础 聚合场景实践 例如，下面查询可以分析不同制造公司之间的关联关系：
GET sample_data_ecommerce/_search { &amp;#34;size&amp;#34;: 0, &amp;#34;aggs&amp;#34;: { &amp;#34;interactions&amp;#34;: { &amp;#34;adjacency_matrix&amp;#34;: { &amp;#34;filters&amp;#34;: { &amp;#34;grpA&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;manufacturer.keyword&amp;#34;: &amp;#34;Low Tide Media&amp;#34; } }, &amp;#34;grpB&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;manufacturer.keyword&amp;#34;: &amp;#34;Elitelligence&amp;#34; } }, &amp;#34;grpC&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;manufacturer.keyword&amp;#34;: &amp;#34;Oceanavigations&amp;#34; } } } } } } } 返回内容
{ ... &amp;#34;aggregations&amp;#34; : { &amp;#34;interactions&amp;#34; : { &amp;#34;buckets&amp;#34; : [ { &amp;#34;key&amp;#34; : &amp;#34;grpA&amp;#34;, &amp;#34;doc_count&amp;#34; : 1553 }, { &amp;#34;key&amp;#34; : &amp;#34;grpA&amp;amp;grpB&amp;#34;, &amp;#34;doc_count&amp;#34; : 590 }, { &amp;#34;key&amp;#34; : &amp;#34;grpA&amp;amp;grpC&amp;#34;, &amp;#34;doc_count&amp;#34; : 329 }, { &amp;#34;key&amp;#34; : &amp;#34;grpB&amp;#34;, &amp;#34;doc_count&amp;#34; : 1370 }, { &amp;#34;key&amp;#34; : &amp;#34;grpB&amp;amp;grpC&amp;#34;, &amp;#34;doc_count&amp;#34; : 299 }, { &amp;#34;key&amp;#34; : &amp;#34;grpC&amp;#34;, &amp;#34;doc_count&amp;#34; : 1218 } ] } } } 让我们更仔细地查看结果</description></item><item><title>采样聚合（Sampler）</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/sampler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/sampler/</guid><description>采样聚合 # 如果你正在聚合大量文档，可以使用 sampler 聚合将范围缩小到一小部分文档，从而获得更快的响应。sampler 聚合通过选择得分最高的文档来选取样本。
结果是大致的，但能很好地反映真实数据的分布。sampler 聚合显著提高了查询性能，但估计的响应并不完全可靠。
相关指南（先读这些） # 聚合基础 聚合性能优化 聚合场景实践 基本语法是：
“aggs”: { &amp;#34;SAMPLE&amp;#34;: { &amp;#34;sampler&amp;#34;: { &amp;#34;shard_size&amp;#34;: 100 }, &amp;#34;aggs&amp;#34;: {...} } } 分片大小属性 # shard_size 属性告诉 Easysearch 每个分片最多收集多少文档。
以下示例将每个分片上收集的文档数量限制为 1,000，然后使用 terms 聚合对文档进行分组：
GET sample_data_logs/_search { &amp;#34;size&amp;#34;: 0, &amp;#34;aggs&amp;#34;: { &amp;#34;sample&amp;#34;: { &amp;#34;sampler&amp;#34;: { &amp;#34;shard_size&amp;#34;: 1000 }, &amp;#34;aggs&amp;#34;: { &amp;#34;terms&amp;#34;: { &amp;#34;terms&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;agent.keyword&amp;#34; } } } } } } 返回内容</description></item><item><title>Geohash 网格聚合</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/geohash-grid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/geohash-grid/</guid><description>Geohash 网格聚合 # geohash_grid 聚合将 geo_point 值按照 Geohash 编码分组到网格单元中。这对于在地图上可视化大量地理坐标点非常有用——将密集的点聚合成可管理的网格，每个网格显示该区域的统计信息。
相关指南（先读这些） # 聚合基础教程 地理位置搜索 Geohash 编码原理 参数说明 # 参数 必需/可选 类型 说明 field 必需 String 包含 geo_point 值的字段名 precision 可选 Integer/String Geohash 精度级别（1-12）或距离字符串（如 1km）。默认 5 bounds 可选 Object 限制聚合的地理边界框，只处理该范围内的点 size 可选 Integer 返回的最大 bucket 数量。默认 10000 shard_size 可选 Integer 每个分片返回的 bucket 数量，用于提高精度。默认 max(10, size) 精度级别参考 # 精度 网格尺寸 适用场景 1 ~ 5,000km 大洲级别 2 ~ 1,250km 国家级别 3 ~ 156km 大区域 4 ~ 39km 城市群 5 ~ 4.</description></item><item><title>Geotile 网格聚合</title><link>/easysearch/main/docs/features/aggregations/bucket-aggregations/geotile-grid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/aggregations/bucket-aggregations/geotile-grid/</guid><description>Geotile 网格聚合 # geotile_grid 聚合将 geo_point 值按照地图瓦片坐标分组。与 geohash_grid 类似，但使用的是 Web 地图标准的瓦片坐标系统（x/y/zoom），这使得它与 Google Maps、OpenStreetMap、Mapbox 等瓦片地图服务的集成更加方便。
相关指南（先读这些） # 聚合基础教程 地理位置搜索 Geohash Grid 聚合 瓦片坐标系统 # Web 地图使用 Slippy Map 瓦片坐标系统：
zoom：缩放级别（0-29），级别越高网格越精细 x：水平瓦片索引（从左到右） y：垂直瓦片索引（从上到下） 瓦片标识符格式：{zoom}/{x}/{y}，如 14/8532/5765
缩放级别与覆盖范围 # Zoom 瓦片数量 每个瓦片覆盖范围 0 1 整个世界 1 4 ~ 20,000km 5 1,024 ~ 1,250km 10 ~100万 ~ 39km 15 ~10亿 ~ 1.</description></item></channel></rss>