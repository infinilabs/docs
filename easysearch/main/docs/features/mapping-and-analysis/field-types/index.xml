<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>字段类型 on INFINI Easysearch (main)</title><link>/easysearch/main/docs/features/mapping-and-analysis/field-types/</link><description>Recent content in 字段类型 on INFINI Easysearch (main)</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/main/docs/features/mapping-and-analysis/field-types/index.xml" rel="self" type="application/rss+xml"/><item><title>排名特征字段类型（Rank Feature）</title><link>/easysearch/main/docs/features/mapping-and-analysis/field-types/rank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/field-types/rank/</guid><description>Rank 字段类型 # 下表列出了 Easysearch 支持的所有 rank 字段类型。
字段数据类型 描述 rank_feature 提升或降低文档的相关性得分。 rank_features 提升或降低文档的相关性得分。用于特征列表稀疏的情况。 注意：rank_feature 和 rank_features 字段只能使用 rank_feature 查询进行查询。它们不支持聚合或排序。
相关指南（先读这些） # 映射基础 相关性：加权与调参 排序功能查询 Rank feature 字段类型 # Rank feature 字段类型使用正浮点值来提升或降低文档在 rank_feature 查询中的相关性得分。默认情况下，该值会提升相关性得分。要降低相关性得分，请将可选参数 positive_score_impact 设置为 false。
示例 # 创建一个包含 rank feature 字段的映射：
PUT chessplayers { &amp;#34;mappings&amp;#34;: { &amp;#34;properties&amp;#34;: { &amp;#34;name&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;text&amp;#34; }, &amp;#34;rating&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;rank_feature&amp;#34; }, &amp;#34;age&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;rank_feature&amp;#34;, &amp;#34;positive_score_impact&amp;#34;: false } } } } 索引三个文档，其中包含一个提升得分的 rank_feature 字段（rating）和一个降低得分的 rank_feature 字段（age）：</description></item><item><title>IP 地址字段类型（IP）</title><link>/easysearch/main/docs/features/mapping-and-analysis/field-types/ip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/field-types/ip/</guid><description>IP 地址字段类型 # IP 字段类型用于存储 IPv4 或 IPv6 格式的 IP 地址。
要表示 IP 地址范围，可以使用 IP 范围字段类型
参考代码 # 创建一个有 IP 地址的 mapping
PUT testindex { &amp;#34;mappings&amp;#34; : { &amp;#34;properties&amp;#34; : { &amp;#34;ip_address&amp;#34; : { &amp;#34;type&amp;#34; : &amp;#34;ip&amp;#34; } } } } 索引一个有 IP 地址的文档
PUT testindex/_doc/1 { &amp;#34;ip_address&amp;#34; : &amp;#34;10.24.34.0&amp;#34; } 查询一个特定 IP 地址的索引
GET testindex/_doc/1 { &amp;#34;query&amp;#34;: { &amp;#34;term&amp;#34;: { &amp;#34;ip_address&amp;#34;: &amp;#34;10.24.34.0&amp;#34; } } } 搜索 IP 地址及其关联的网络掩码 # 您可以使用无类别域间路由 (CIDR) 表示法查询索引中的 IP 地址。在 CIDR 表示法中，通过斜杠 / 分隔 IP 地址和前缀长度（0–32）。例如，前缀长度为 24 表示匹配所有具有相同前 24 位的 IP 地址。</description></item><item><title>二进制字段类型（Binary）</title><link>/easysearch/main/docs/features/mapping-and-analysis/field-types/binary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/field-types/binary/</guid><description>二进制字段类型 # 二进制字段类型包含以 Base64 编码存储的二进制值，这些值不可被搜索。
参考代码 # 创建包含二进制字段的映射
PUT testindex { &amp;#34;mappings&amp;#34; : { &amp;#34;properties&amp;#34; : { &amp;#34;binary_value&amp;#34; : { &amp;#34;type&amp;#34; : &amp;#34;binary&amp;#34; } } } } 索引一个二进制值的文档
PUT testindex/_doc/1 { &amp;#34;binary_value&amp;#34; : &amp;#34;bGlkaHQtd29rfx4=&amp;#34; } 使用 = 作为填充字符。不允许嵌入换行符。
参数说明 # 以下参数均为可选参数
参数 数据类型 默认值 描述 doc_values Boolean false 是否存储在磁盘上，用于聚合、排序或脚本。 store Boolean false 是否单独存储字段值，使其可以独立于 _source 被检索。 使用场景 # 二进制字段适合存储小型二进制数据，例如：</description></item><item><title>别名字段类型（Alias）</title><link>/easysearch/main/docs/features/mapping-and-analysis/field-types/alias/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/field-types/alias/</guid><description>Alias 别名字段类型 # 别名字段类型为现有字段创建另一个名称。您可以在搜索和字段功能的 API 操作中使用别名字段，但存在一些例外情况。要设置别名，必须在 path 参数中指定原始字段名称。
参考代码 # PUT movies { &amp;#34;mappings&amp;#34; : { &amp;#34;properties&amp;#34; : { &amp;#34;year&amp;#34; : { &amp;#34;type&amp;#34; : &amp;#34;date&amp;#34; }, &amp;#34;release_date&amp;#34; : { &amp;#34;type&amp;#34; : &amp;#34;alias&amp;#34;, &amp;#34;path&amp;#34; : &amp;#34;year&amp;#34; } } } } 参数说明 # path：指向原始字段的完整路径，包括所有父对象。例如，parent.child.field_name。此参数为必填项。 别名（Alias）字段 # 别名（Alias）字段必须遵循以下规则：
一个别名字段只能引用一个原始字段。 在嵌套对象中，别名必须与原始字段位于相同的嵌套层级。 要更改别名引用的字段，需要更新映射配置。但请注意，之前存储的 Percolator 查询中的别名仍会继续引用原始字段，不会自动更新为新的字段引用。
原始字段 # 别名的原始字段必须遵守以下规则：
原始字段必须在别名字段创建之前定义。 原始字段不能是对象类型，也不能是另一个别名字段。 可以使用别名字段的搜索 API # 您可以在以下搜索 API 的只读操作中使用别名：</description></item><item><title>向量字段类型（K-NN）</title><link>/easysearch/main/docs/features/mapping-and-analysis/field-types/knn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/field-types/knn/</guid><description>K-NN 向量字段类型 # 相关指南（先读这些） # 向量搜索 向量字段建模 映射基础 关于向量 # 在索引文档和运行查询时都需要指定向量类型。在这两种情况下，您都使用相同的 JSON 结构来定义向量类型。每个向量类型还有一个简写形式，这在使用不支持嵌套文档的工具时会很方便。以下示例展示了如何在索引向量时指定它们。
knn_dense_float_vector 密集向量类型 # 假设您已经定义了一个映射，其中 my_vec 的类型为 knn_dense_float_vector。
POST /my-index/_doc { &amp;#34;my_vec&amp;#34;: { &amp;#34;values&amp;#34;: [0.1, 0.2, 0.3, ...] # 1 } } POST /my-index/_doc { &amp;#34;my_vec&amp;#34;: [0.1, 0.2, 0.3, ...] # 2 } 说明 # 1 向量中所有浮点值的 JSON 列表。长度应与映射中的dims匹配。 2 #1 的简写形式。
knn_sparse_bool_vector 稀疏向量类型 # 假设您已经定义了一个映射，其中 my_vec 的类型为 knn_sparse_bool_vector。</description></item><item><title>布尔字段类型（Boolean）</title><link>/easysearch/main/docs/features/mapping-and-analysis/field-types/boolean/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/field-types/boolean/</guid><description>布尔字段类型 # 布尔字段类型接受 true 或 false 值，也支持字符串形式的 &amp;ldquo;true&amp;rdquo; 或 &amp;ldquo;false&amp;rdquo;。此外，还可以使用空字符串 &amp;quot;&amp;quot; 表示 false 值。
参考代码 # 创建一个由 a,b,c 三个布尔字段组成的 mapping
PUT testindex { &amp;#34;mappings&amp;#34; : { &amp;#34;properties&amp;#34; : { &amp;#34;a&amp;#34; : { &amp;#34;type&amp;#34; : &amp;#34;boolean&amp;#34; }, &amp;#34;b&amp;#34; : { &amp;#34;type&amp;#34; : &amp;#34;boolean&amp;#34; }, &amp;#34;c&amp;#34; : { &amp;#34;type&amp;#34; : &amp;#34;boolean&amp;#34; } } } } 索引由布尔值组成的文档
PUT testindex/_doc/1 { &amp;#34;a&amp;#34; : true, &amp;#34;b&amp;#34; : &amp;#34;true&amp;#34;, &amp;#34;c&amp;#34; : &amp;#34;&amp;#34; } 因此，字段 a 和 b 将被设置为 true，而字段 c 将被设置为 false。</description></item><item><title>数值字段类型（Numeric）</title><link>/easysearch/main/docs/features/mapping-and-analysis/field-types/numeric-field/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/field-types/numeric-field/</guid><description>Numeric 字段类型 # 下表列出了 Easysearch 支持的所有数字字段类型。
字段数据类型 描述 byte 有符号的 8 位整数。最小值为 -128，最大值为 127。 double 双精度 64 位 IEEE 754 浮点数。最小值为 2^−1074，最大值为 (2 − 2^−52) · 2^1023。有效位数为 53，有效数字位为 15.95。 float 单精度 32 位 IEEE 754 浮点数。最小值为 2^−149，最大值为 (2 − 2^−23) · 2^127。有效位数为 24，有效数字位为 7.22。 half_float 半精度 16 位 IEEE 754 浮点数。最小值为 2^−24，最大值为 65504。有效位数为 11，有效数字位为 3.31。 integer 有符号的 32 位整数。最小值为 -2^31，最大值为 2^31 - 1。 long 有符号的 64 位整数。最小值为 -2^63，最大值为 2^63 - 1。 short 有符号的 16 位整数。最小值为 -2^15，最大值为 2^15 - 1。 scaled_float 一个浮点值，它会被乘以双精度缩放因子并存储为长整型值。 Integer、long、float 和 double 字段类型都有对应的 范围字段类型。</description></item><item><title>渗滤器字段类型（Percolator）</title><link>/easysearch/main/docs/features/mapping-and-analysis/field-types/percolator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/field-types/percolator/</guid><description>Percolator 字段类型 # percolator 字段类型将该字段视为查询处理。任何 JSON 对象字段都可以标记为 percolator 字段。通常，文档被索引并用于搜索，而 percolator 字段存储搜索条件，稍后通过 Percolate 查询将匹配文档到该条件。
相关指南（先读这些） # 映射基础 渗透查询 参考代码 # 客户正在搜索价格在 400 美元或以下的桌子，并希望为此搜索创建警报。 创建一个映射，为查询字段分配一个 percolator 字段类型：
PUT testindex1 { &amp;#34;mappings&amp;#34;: { &amp;#34;properties&amp;#34;: { &amp;#34;search&amp;#34;: { &amp;#34;properties&amp;#34;: { &amp;#34;query&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;percolator&amp;#34; } } }, &amp;#34;price&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;float&amp;#34; }, &amp;#34;item&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;text&amp;#34; } } } } 索引一个查询
PUT testindex1/_doc/1 { &amp;#34;search&amp;#34;: { &amp;#34;query&amp;#34;: { &amp;#34;bool&amp;#34;: { &amp;#34;filter&amp;#34;: [ { &amp;#34;match&amp;#34;: { &amp;#34;item&amp;#34;: { &amp;#34;query&amp;#34;: &amp;#34;table&amp;#34; } } }, { &amp;#34;range&amp;#34;: { &amp;#34;price&amp;#34;: { &amp;#34;lte&amp;#34;: 400.</description></item><item><title>纯匹配文本字段类型（Match Only Text）</title><link>/easysearch/main/docs/features/mapping-and-analysis/field-types/match_only_text/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/field-types/match_only_text/</guid><description>match_only_text 字段类型 # Introduced 1.10.0
简介 # match_only_text 是一个为全文搜索优化的字段类型，是 text 类型的变体。它通过省略词条位置、词频和规范化信息来减少存储需求,适合对存储成本敏感但仍需要基本全文搜索功能的场景。
主要特点 # 存储优化:
不存储位置信息 不存储词频信息 不存储规范化信息 显著减少索引大小 评分机制:
禁用评分计算 所有匹配文档得分统一为 1.0 查询支持:
支持大多数查询类型 不支持 interval 查询 不支持 span 查询 支持但不优化短语查询 使用场景 # 适合用于:
需要快速查找包含特定词条的文档 对存储成本敏感的大数据集 不需要复杂相关性排序的场景 不适合用于:
需要基于相关性排序的查询 依赖词条位置或顺序的查询 需要精确短语匹配的场景 映射示例 # PUT my_index { &amp;#34;mappings&amp;#34;: { &amp;#34;properties&amp;#34;: { &amp;#34;title&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;match_only_text&amp;#34; } } } } 参数配置 # 参数 说明 默认值 analyzer 分析器设置 standard boost 评分提升因子 1.</description></item><item><title>范围字段类型（Range）</title><link>/easysearch/main/docs/features/mapping-and-analysis/field-types/range-field-type/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/field-types/range-field-type/</guid><description>Range 字段类型 # 以下表格列出了 Easysearch 支持的所有范围字段类型。
字段数据类型 描述 integer_range 整数值范围。 long_range 长整型值范围。 double_range 双精度浮点值范围。 float_range 浮点值范围。 ip_range IPv4 或 IPv6 地址范围，起始和结束地址可使用不同格式。 date_range 日期值范围，起始和结束日期可采用不同格式。内部以 64 位无符号整数存储，自纪元以来的毫秒数表示。 相关指南（先读这些） # 映射基础 结构化搜索 参考代码 # 创建一个有双精度浮点数范围字段和日期范围字段的映射
PUT testindex { &amp;#34;mappings&amp;#34; : { &amp;#34;properties&amp;#34; : { &amp;#34;gpa&amp;#34; : { &amp;#34;type&amp;#34; : &amp;#34;double_range&amp;#34; }, &amp;#34;graduation_date&amp;#34; : { &amp;#34;type&amp;#34; : &amp;#34;date_range&amp;#34;, &amp;#34;format&amp;#34; : &amp;#34;strict_year_month||strict_year_month_day&amp;#34; } } } } 索引一个包含这两个字段的文档</description></item><item><title>通配符字段类型（Wildcard）</title><link>/easysearch/main/docs/features/mapping-and-analysis/field-types/wildcard/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/field-types/wildcard/</guid><description>Wildcard 字段类型 # wildcard 字段是 keyword 字段的一种变体，专为任意子字符串和正则表达式匹配而设计。
当您的内容由&amp;quot;字符串&amp;quot;而非&amp;quot;文本&amp;quot;组成时，应使用 wildcard 字段。示例包括非结构化日志行和计算机代码。
wildcard 字段类型的索引方式与 keyword 字段类型不同。keyword 字段将原始字段值写入索引，而 wildcard 字段类型则将字段值拆分为长度小于或等于 3 的子字符串，并将这些子字符串写入索引。例如，字符串 test 被拆分为 t、te、tes、e、es 和 est 这些子字符串。
在搜索时，将查询模式中所需的子字符串与索引进行匹配以生成候选文档，然后根据查询中的模式对这些文档进行过滤。例如，对于搜索词 test，Easysearch 执行索引搜索 tes AND est。如果搜索词包含少于三个字符，Easysearch 会使用长度为一或二的字符子字符串。对于每个匹配的文档，如果源值为 test，则该文档将出现在结果中。这样可以排除误报值，如 nikola tesla felt alternating current was best。
通常，精确匹配查询（如 term 或 terms 查询）在 wildcard 字段上的表现不如在 keyword 字段上有效，而 wildcard、 prefix 和 regexp 查询在 wildcard 字段上表现更好。
相关指南（先读这些） # 映射基础 部分匹配 结构化搜索 示例 # 创建带有 wildcard 字段的映射：</description></item><item><title>扁平对象字段类型（Flat Object）</title><link>/easysearch/main/docs/features/mapping-and-analysis/field-types/flat-object/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/field-types/flat-object/</guid><description>扁平对象字段类型（Flat Object） # flat_object（也称为 flattened 类型）将整个 JSON 对象作为单个扁平化字段存储。它会将 JSON 对象中所有叶子节点的值提取为关键字（keyword），并支持对这些值进行基本查询。
适用场景 # flat_object 特别适合以下场景：
标签/标注数据：如 Kubernetes 的 labels、annotations 等动态键值对 防止 mapping explosion：当字段名不可预知或数量极多时，避免为每个子字段创建独立的映射条目 半结构化 JSON：存储结构不固定的 JSON 数据，同时保持可搜索性 日志元数据：存储动态的日志属性或自定义元数据 与其他类型对比 # 类型 动态字段支持 查询能力 Mapping 条目 性能 object ✅ 每个子字段独立映射 完整（全文、范围等） 多（每子字段一条） 高（独立索引） nested ✅ 每个子字段独立映射 完整 + 对象关联性 多 + 隐藏文档 中 flat_object ✅ 无需预定义 基本（term、prefix、range） 仅一条 中 创建映射 # PUT my_index { &amp;#34;mappings&amp;#34;: { &amp;#34;properties&amp;#34;: { &amp;#34;labels&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;flat_object&amp;#34; } } } } flat_object 使用默认配置即可，不需要额外的映射参数。</description></item><item><title>标注文本字段类型（Annotated Text）</title><link>/easysearch/main/docs/features/mapping-and-analysis/field-types/annotated-text/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/field-types/annotated-text/</guid><description>标注文本字段类型（Annotated Text） # annotated_text 字段类型是 text 字段的扩展，允许在文本中嵌入标注标记（annotation tokens）。标注标记会在索引时注入到文本的词元流（token stream）中，可以像普通词语一样被搜索。
适用场景 # 命名实体识别（NER）：将文本中识别出的实体（人名、地名、组织名等）作为标注嵌入 文本分类标记：在文本中标记特定类别或主题 知识图谱关联：将文本中的实体链接到知识图谱的节点 自定义标签注入：在索引时为文本添加额外的可搜索标签 前置条件 # annotated_text 字段类型由 mapper-annotated-text 插件提供，需要确认插件已安装：
bin/easysearch-plugin list # 应包含 mapper-annotated-text 创建映射 # PUT my_index { &amp;#34;mappings&amp;#34;: { &amp;#34;properties&amp;#34;: { &amp;#34;content&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;annotated_text&amp;#34; } } } } annotated_text 支持与 text 字段相同的映射参数，如 analyzer、search_analyzer 等。
标注语法 # 标注使用特殊的标记语法嵌入在文本中。标注的格式为：
[被标注的文本](标注值) 示例 # 原始文本：
&amp;#34;昨天在北京召开了搜索技术大会&amp;#34; 带标注的文本：
&amp;#34;昨天在[北京](LOC=北京&amp;amp;wiki=Q956)召开了[搜索技术大会](EVENT=搜索技术大会)&amp;#34; 索引带标注的文档 # PUT my_index/_doc/1 { &amp;#34;content&amp;#34;: &amp;#34;昨天[极限实验室](ORG=极限实验室)发布了[Easysearch](PRODUCT=Easysearch) 的新版本&amp;#34; } PUT my_index/_doc/2 { &amp;#34;content&amp;#34;: &amp;#34;[张三](PERSON=张三)在[上海](LOC=上海)参加了技术峰会&amp;#34; } 查询 # 搜索标注值 # 标注值作为词元注入到了索引中，可以直接搜索：</description></item><item><title>词元计数字段类型（Token Count）</title><link>/easysearch/main/docs/features/mapping-and-analysis/field-types/token-count/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/field-types/token-count/</guid><description>词元计数字段类型（Token Count） # token_count 是一个特殊的整数字段类型，它在索引时自动计算文本经过分析器处理后产生的词元（token）数量，并将该数量作为字段值存储。这使您可以根据文本的词元数量进行过滤、排序和聚合。
适用场景 # 按内容长度过滤：过滤词元数量在指定范围内的文档（如至少 100 个词的文章） 内容质量评估：短文本可能质量较低，可按词元数量排序 分析器效果评估：了解不同分析器对同一文本产生的词元数量差异 创建映射 # PUT my_index { &amp;#34;mappings&amp;#34;: { &amp;#34;properties&amp;#34;: { &amp;#34;title&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;text&amp;#34;, &amp;#34;fields&amp;#34;: { &amp;#34;length&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;token_count&amp;#34;, &amp;#34;analyzer&amp;#34;: &amp;#34;standard&amp;#34; } } } } } } 映射参数 # 参数 必填 说明 analyzer ✅ 是 用于分析文本的分析器名称。使用该分析器产生的词元数量作为字段值 enable_position_increments 否 是否计算位置增量。默认 true。设为 false 后，停用词等位置增量不计入总数 doc_values 否 默认 true，启用 doc values 以支持排序和聚合 index 否 默认 true，是否索引该字段 null_value 否 当原始文本为 null 时使用的替代值 store 否 默认 false，是否单独存储字段值 索引文档 # PUT my_index/_doc/1 { &amp;#34;title&amp;#34;: &amp;#34;快速入门 Easysearch 搜索引擎&amp;#34; } PUT my_index/_doc/2 { &amp;#34;title&amp;#34;: &amp;#34;Easysearch&amp;#34; } PUT my_index/_doc/3 { &amp;#34;title&amp;#34;: &amp;#34;深入理解 Easysearch 的分布式架构设计与高可用方案&amp;#34; } 查询示例 # 过滤词元数量 # 查找标题至少有 3 个词元的文档：</description></item><item><title>哈希字段类型（Murmur3）</title><link>/easysearch/main/docs/features/mapping-and-analysis/field-types/murmur3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/field-types/murmur3/</guid><description>哈希字段类型（Murmur3） # murmur3 字段类型在索引时计算字段值的 MurmurHash3 128 位哈希值，并将哈希值存储为 doc values。这在 cardinality 聚合中可以提供更高的精度，因为直接使用预计算的哈希值而非运行时计算。
前置条件 # murmur3 字段类型由 mapper-murmur3 插件提供，需要确认插件已安装：
bin/easysearch-plugin list # 应包含 mapper-murmur3 创建映射 # PUT my_index { &amp;#34;mappings&amp;#34;: { &amp;#34;properties&amp;#34;: { &amp;#34;user_id&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;keyword&amp;#34;, &amp;#34;fields&amp;#34;: { &amp;#34;hash&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;murmur3&amp;#34; } } } } } } 使用示例 # Cardinality 聚合优化 # 使用 murmur3 子字段进行基数统计，可以获得更高的精度：
GET my_index/_search { &amp;#34;size&amp;#34;: 0, &amp;#34;aggs&amp;#34;: { &amp;#34;unique_users&amp;#34;: { &amp;#34;cardinality&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;user_id.</description></item></channel></rss>