<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>元数据字段 on INFINI Easysearch</title><link>/easysearch/main/docs/features/mapping-and-analysis/metadata-field/</link><description>Recent content in 元数据字段 on INFINI Easysearch</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/main/docs/features/mapping-and-analysis/metadata-field/index.xml" rel="self" type="application/rss+xml"/><item><title>元信息字段（_meta）</title><link>/easysearch/main/docs/features/mapping-and-analysis/metadata-field/meta/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/metadata-field/meta/</guid><description>_meta 元数据字段 # _meta 字段是一个映射属性，允许您为索引映射附加自定义元数据。您的应用程序可以使用这些元数据来存储与您的用例相关的信息，如版本控制、所有权、分类或审计。
相关指南（先读这些） # 映射基础 元数据字段 用法 # 您可以在创建新索引或更新现有索引的映射时定义 _meta 字段，如以下示例所示：
PUT my-index { &amp;#34;mappings&amp;#34;: { &amp;#34;_meta&amp;#34;: { &amp;#34;application&amp;#34;: &amp;#34;MyApp&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.2.3&amp;#34;, &amp;#34;author&amp;#34;: &amp;#34;John Doe&amp;#34; }, &amp;#34;properties&amp;#34;: { &amp;#34;title&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;text&amp;#34; }, &amp;#34;description&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;text&amp;#34; } } } } 在此示例中，添加了三个自定义元数据字段：application、version 和 author。您的应用程序可以使用这些字段来存储有关索引的任何相关信息，例如它所属的应用程序、应用程序版本或索引的作者。
您可以使用 Put Mapping API 操作更新 _meta 字段，如以下示例所示：
PUT my-index/_mapping { &amp;#34;_meta&amp;#34;: { &amp;#34;application&amp;#34;: &amp;#34;MyApp&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.3.0&amp;#34;, &amp;#34;author&amp;#34;: &amp;#34;Jane Smith&amp;#34; } } 检索元数据信息 # 您可以使用 Get Mapping API 操作检索索引的 _meta 信息，如以下示例所示：</description></item><item><title>字段名称元数据字段（_field_names）</title><link>/easysearch/main/docs/features/mapping-and-analysis/metadata-field/field-names/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/metadata-field/field-names/</guid><description>_field_names 元数据字段 # _field_names 字段索引包含非空值的字段名称。可以使用 exists 查询来识别指定字段是否具有非空值的文档。
但是，只有当 doc_values 和 norms 都被禁用时，_field_names 才会索引字段名称。如果启用了 doc_values 或 norms 中的任何一个，则 exists 查询仍然可以工作，但不会依赖 _field_names 字段。
相关指南（先读这些） # 映射基础 元数据字段 映射示例 # PUT testindex { &amp;#34;mappings&amp;#34;: { &amp;#34;_field_names&amp;#34;: { &amp;#34;enabled&amp;#34;: true }, &amp;#34;properties&amp;#34;: { &amp;#34;title&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;text&amp;#34;, &amp;#34;norms&amp;#34;: false }, &amp;#34;description&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;text&amp;#34; }, &amp;#34;price&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;float&amp;#34;, &amp;#34;doc_values&amp;#34;: false } } } }</description></item><item><title>忽略字段元数据字段（_ignored）</title><link>/easysearch/main/docs/features/mapping-and-analysis/metadata-field/ignored/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/metadata-field/ignored/</guid><description>_ignored 元数据字段 # _ignored 字段帮助您管理文档中与格式错误数据相关的问题。由于在 索引映射中启用了 ignore_malformed 设置，此字段用于存储在数据索引过程中被忽略的字段名称。
_ignored 字段允许您搜索和识别包含被忽略字段的文档，以及被忽略的具体字段名称。这对于故障排除很有用。
您可以使用 term、terms 和 exists 查询来查询 _ignored 字段。
注意：只有当索引映射中启用了 ignore_malformed 设置时，才会填充 _ignored 字段。如果 ignore_malformed 设置为 false（默认值），则格式错误的字段将导致整个文档被拒绝，并且不会填写 _ignored 字段。
相关指南（先读这些） # 映射基础 元数据字段 以下示例展示了如何使用 _ignored 字段：
GET _search { &amp;#34;query&amp;#34;: { &amp;#34;exists&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;_ignored&amp;#34; } } } 使用 _ignored 字段的索引请求示例 # 以下示例向 test-ignored 索引添加一个新文档，其中 ignore_malformed 设置为 true，这样在数据索引时不会抛出错误：
PUT test-ignored { &amp;#34;mappings&amp;#34;: { &amp;#34;properties&amp;#34;: { &amp;#34;title&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;text&amp;#34; }, &amp;#34;length&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;long&amp;#34;, &amp;#34;ignore_malformed&amp;#34;: true } } } } POST test-ignored/_doc { &amp;#34;title&amp;#34;: &amp;#34;correct text&amp;#34;, &amp;#34;length&amp;#34;: &amp;#34;not a number&amp;#34; } GET test-ignored/_search { &amp;#34;query&amp;#34;: { &amp;#34;exists&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;_ignored&amp;#34; } } } 示例返回内容 # { &amp;#34;took&amp;#34;: 42, &amp;#34;timed_out&amp;#34;: false, &amp;#34;_shards&amp;#34;: { &amp;#34;total&amp;#34;: 1, &amp;#34;successful&amp;#34;: 1, &amp;#34;skipped&amp;#34;: 0, &amp;#34;failed&amp;#34;: 0 }, &amp;#34;hits&amp;#34;: { &amp;#34;total&amp;#34;: { &amp;#34;value&amp;#34;: 1, &amp;#34;relation&amp;#34;: &amp;#34;eq&amp;#34; }, &amp;#34;max_score&amp;#34;: 1, &amp;#34;hits&amp;#34;: [ { &amp;#34;_index&amp;#34;: &amp;#34;test-ignored&amp;#34;, &amp;#34;_id&amp;#34;: &amp;#34;qcf0wZABpEYH7Rw9OT7F&amp;#34;, &amp;#34;_score&amp;#34;: 1, &amp;#34;_ignored&amp;#34;: [ &amp;#34;length&amp;#34; ], &amp;#34;_source&amp;#34;: { &amp;#34;title&amp;#34;: &amp;#34;correct text&amp;#34;, &amp;#34;length&amp;#34;: &amp;#34;not a number&amp;#34; } } ] } } 忽略指定字段 # 您可以使用 term 查询来查找特定字段被忽略的文档，如以下示例请求所示：</description></item><item><title>文档 ID 元数据字段（_id）</title><link>/easysearch/main/docs/features/mapping-and-analysis/metadata-field/id/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/metadata-field/id/</guid><description>_id 元数据字段 # Easysearch 中的每个文档都有一个唯一的 _id 字段。此字段已被索引，允许你使用 GET API 或 ids 查询 检索文档。
注意：如果您未提供 _id 值，则 Easysearch 会自动为文档生成一个。
相关指南（先读这些） # 映射基础 元数据字段 以下示例请求创建一个名为 test-index1 的索引，并添加两个具有不同 _id 值的文档：
PUT test-index1/_doc/1 { &amp;#34;text&amp;#34;: &amp;#34;Document with ID 1&amp;#34; } PUT test-index1/_doc/2?refresh=true { &amp;#34;text&amp;#34;: &amp;#34;Document with ID 2&amp;#34; } 您可以使用 _id 字段查询文档，如以下示例请求所示：
GET test-index1/_search { &amp;#34;query&amp;#34;: { &amp;#34;terms&amp;#34;: { &amp;#34;_id&amp;#34;: [&amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;] } } } 返回 _id 值为 1 和 2 的两个文档：</description></item><item><title>源数据元数据字段（_source）</title><link>/easysearch/main/docs/features/mapping-and-analysis/metadata-field/source/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/metadata-field/source/</guid><description>_source 元数据字段 # _source 字段包含已索引的原始 JSON 文档主体。虽然此字段不可搜索，但它会被存储，以便在执行获取请求（如 get 和 search）时可以返回完整文档。
禁用 _source # 您可以通过将 enabled 参数设置为 false 来禁用 _source 字段，如以下示例所示：
PUT sample-index1 { &amp;#34;mappings&amp;#34;: { &amp;#34;_source&amp;#34;: { &amp;#34;enabled&amp;#34;: false } } } 注意：禁用 _source 字段可能会影响某些功能的可用性，例如 update、update_by_query 和 reindex API，以及使用原始索引文档查询或聚合的能力。
相关指南（先读这些） # 映射基础 元数据字段 包含或排除某些字段 # 您可以使用 includes 和 excludes 参数选择 _source 字段的内容。如以下示例：
PUT logs { &amp;#34;mappings&amp;#34;: { &amp;#34;_source&amp;#34;: { &amp;#34;includes&amp;#34;: [ &amp;#34;*.</description></item><item><title>索引名称元数据字段（_index）</title><link>/easysearch/main/docs/features/mapping-and-analysis/metadata-field/index-field/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/metadata-field/index-field/</guid><description>_index 元数据字段 # 当跨多个索引进行查询时，您可能需要根据文档所在的索引来过滤结果。_index 字段根据文档的索引来匹配文档。
相关指南（先读这些） # 映射基础 元数据字段 以下示例创建两个索引，products 和 customers，并向每个索引添加一个文档：
PUT products/_doc/1 { &amp;#34;name&amp;#34;: &amp;#34;Widget X&amp;#34; } PUT customers/_doc/2 { &amp;#34;name&amp;#34;: &amp;#34;John Doe&amp;#34; } 然后，您可以查询这两个索引，并使用 _index 属性过滤结果，如以下示例请求所示：
GET products,customers/_search { &amp;#34;query&amp;#34;: { &amp;#34;terms&amp;#34;: { &amp;#34;_index&amp;#34;: [&amp;#34;products&amp;#34;, &amp;#34;customers&amp;#34;] } }, &amp;#34;aggs&amp;#34;: { &amp;#34;index_groups&amp;#34;: { &amp;#34;terms&amp;#34;: { &amp;#34;field&amp;#34;: &amp;#34;_index&amp;#34;, &amp;#34;size&amp;#34;: 10 } } }, &amp;#34;sort&amp;#34;: [ { &amp;#34;_index&amp;#34;: { &amp;#34;order&amp;#34;: &amp;#34;desc&amp;#34; } } ], &amp;#34;script_fields&amp;#34;: { &amp;#34;index_name&amp;#34;: { &amp;#34;script&amp;#34;: { &amp;#34;lang&amp;#34;: &amp;#34;painless&amp;#34;, &amp;#34;source&amp;#34;: &amp;#34;doc[&amp;#39;_index&amp;#39;].</description></item><item><title>路由元数据字段（_routing）</title><link>/easysearch/main/docs/features/mapping-and-analysis/metadata-field/routing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/metadata-field/routing/</guid><description>_routing 元数据字段 # Easysearch 使用哈希算法将文档路由到索引中的特定分片。默认情况下，文档的 _id 字段用作路由值，但您也可以为每个文档指定自定义路由值。
默认路由 # 以下是 Easysearch 的默认路由公式。_routing 值是文档的 _id。
相关指南（先读这些） # 映射基础 元数据字段 shard_num = hash(_routing) % num_primary_shards 自定义路由 # 您可以在索引文档时指定自定义路由值，如以下示例所示：
PUT sample-index1/_doc/1?routing=JohnDoe1 { &amp;#34;title&amp;#34;: &amp;#34;This is a document&amp;#34; } 在此示例中，文档使用的路由值是 JohnDoe1 而不是默认的 _id 。
在检索、删除或更新文档时，您必须提供相同的路由值，如以下示例所示：
GET sample-index1/_doc/1?routing=JohnDoe1 通过路由查询 # 您可以使用 _routing 字段根据文档的路由值进行查询，如以下示例所示。此查询仅搜索与 JohnDoe1 路由值关联的分片：
GET sample-index1/_search { &amp;#34;query&amp;#34;: { &amp;#34;terms&amp;#34;: { &amp;#34;_routing&amp;#34;: [ &amp;#34;JohnDoe1&amp;#34; ] } } } 设置路由为必需项 # 您可以使索引上的所有 CRUD 操作都必需提供路由值，如以下示例。如果您尝试在不提供路由值的情况下索引文档，Easysearch 将抛出异常。</description></item><item><title>文档大小元数据字段（_size）</title><link>/easysearch/main/docs/features/mapping-and-analysis/metadata-field/size/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/mapping-and-analysis/metadata-field/size/</guid><description>文档大小元数据字段（_size） # _size 元数据字段记录每个文档的 _source 字段的原始未压缩大小（字节数）。启用后，可以按文档大小进行过滤、排序和聚合。
前置条件 # _size 字段由 mapper-size 插件提供，需要确认插件已安装：
bin/easysearch-plugin list # 应包含 mapper-size 启用 _size 字段 # _size 字段默认未启用，需要在索引映射中显式开启：
PUT my_index { &amp;#34;mappings&amp;#34;: { &amp;#34;_size&amp;#34;: { &amp;#34;enabled&amp;#34;: true } } } 使用示例 # 索引文档 # 启用 _size 后，索引文档时会自动计算并存储 _source 的大小：
PUT my_index/_doc/1 { &amp;#34;title&amp;#34;: &amp;#34;示例文档&amp;#34;, &amp;#34;content&amp;#34;: &amp;#34;这是一个示例文档，用于演示 _size 字段。&amp;#34; } 查询文档大小 # GET my_index/_search { &amp;#34;query&amp;#34;: { &amp;#34;match_all&amp;#34;: {} }, &amp;#34;fields&amp;#34;: [&amp;#34;_size&amp;#34;], &amp;#34;_source&amp;#34;: false } 按大小过滤 # 查找大于 1KB 的文档：</description></item></channel></rss>