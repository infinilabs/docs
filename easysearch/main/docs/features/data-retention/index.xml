<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>数据保留与生命周期 on INFINI Easysearch (main)</title><link>/easysearch/main/docs/features/data-retention/</link><description>Recent content in 数据保留与生命周期 on INFINI Easysearch (main)</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/main/docs/features/data-retention/index.xml" rel="self" type="application/rss+xml"/><item><title>数据生命周期</title><link>/easysearch/main/docs/features/data-retention/lifecycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/data-retention/lifecycle/</guid><description>数据保留与生命周期管理 # 时间序列数据（日志/指标/审计）有个现实：越新的越值钱，越老的越偶尔被翻。当数据规模持续增长，你面临三个经典问题：
性能与成本的平衡：最近数据要快速可查，历史数据如何低成本保留？ 合规与可追溯：历史数据要留多久？ 自动化运维：如何减少手工干预？ 本页给你一套完整的数据保留策略体系。建议先了解 时间序列数据建模。
快速决策树 # 开始 → 数据还在写入? ├─ 是 → 放在&amp;#34;热&amp;#34;节点，使用好硬件 │ ├─ 准备自动化? → 用 ILM（推荐） │ └─ 手动管理? → 按时间切索引 │ └─ 不再写入 → 迁移到&amp;#34;温/冷&amp;#34;节点 ├─ 还会经常查询? → 温节点，forcemerge 优化 │ ├─ 很少查询? → 冷节点或关闭索引 │ └─ 长期存档? ├─ 快照 → 删索引（完全清除） └─ 或用 Rollup 汇总压缩 核心策略详解 # 1. 按时间切索引：最简单的删除策略 # 时间序列数据治理的第一优先：按时间切索引。
这样做的好处：
删除旧数据变成&amp;quot;删整个索引&amp;quot;，而不是&amp;quot;给 N 个文档标记删除&amp;quot; 删索引是异步的、无锁的，不阻塞查询和写入 可以精确控制数据保留窗口 示例：按天切索引</description></item><item><title>索引生命周期</title><link>/easysearch/main/docs/features/data-retention/ilm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/data-retention/ilm/</guid><description>索引生命周期管理 # 索引生命周期管理（Index Lifecycle Management, ILM）为您提供了一种集成化、自动化的方式来高效管理时序数据。 通过配置 ILM 策略，您可以根据性能、可用性与数据保留需求，自动执行索引的滚动、归档和清理等操作。
从 1.15.2 版本开始，index-management 已经成为 modules 的一部分，不需要单独安装插件。
典型应用场景 # 自动滚动生成新索引：当现有索引达到指定大小或文档数量时，自动创建新索引。 周期性轮换索引：按天、周或月创建新索引，并将历史索引归档。 强制数据保留策略：自动删除过期索引，确保合规与存储成本可控。 分层存储：将热数据分配到高性能节点，冷数据迁移到廉价存储节点。 策略管理 API # 创建策略 # 创建一个新的生命周期策略。
请求 # PUT _ilm/policy/{policyID} 参数 描述 类型 是否必需 policyID 策略 ID。 string 是 查询参数 # 参数 描述 类型 默认值 if_seq_no 仅当匹配此序列号时更新。 long — if_primary_term 仅当匹配此主分片任期时更新。 long — 请求体 # 策略支持 ES 兼容的 phases 格式。系统内部会自动转换为 states 格式。</description></item><item><title>快照生命周期</title><link>/easysearch/main/docs/features/data-retention/slm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/data-retention/slm/</guid><description>快照生命周期管理 # 快照生命周期管理（Snapshot Lifecycle Management, SLM）提供自动化的快照创建与清理能力。 通过配置 SLM 策略，您可以按照预定计划自动创建快照，并根据保留条件自动删除过期快照。
策略配置参考 # 策略结构 # { &amp;#34;description&amp;#34;: &amp;#34;策略描述&amp;#34;, &amp;#34;creation&amp;#34;: { ... }, &amp;#34;deletion&amp;#34;: { ... }, &amp;#34;snapshot_config&amp;#34;: { ... }, &amp;#34;notification&amp;#34;: { ... } } creation — 快照创建配置 # 参数 描述 类型 是否必需 schedule 创建快照的时间计划。 object 是 time_limit 创建快照的最大等待时间。 string 否 schedule — 时间计划 # 支持 cron 表达式或固定间隔两种格式：</description></item><item><title>可搜索快照</title><link>/easysearch/main/docs/features/data-retention/searchable-snapshot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/data-retention/searchable-snapshot/</guid><description>可搜索快照（Searchable Snapshots） # Easysearch 快照搜索允许系统直接在对象存储（如 S3、MinIO、OSS）上挂载快照索引，让归档数据瞬间具备检索能力——无需将快照恢复为完整索引，即使是 PB 级快照数据也能在数分钟内完成挂载并开放搜索。
核心优势 # 分钟级上线，零恢复等待 # 传统快照恢复需要将全量数据拷贝到本地磁盘，耗时可能达数小时。快照搜索消除了这一步骤，仅挂载元数据，数据按需从对象存储拉取。
极低的存储成本 # 核心数据保留在低成本的对象存储中，仅在查询时按需调用，大幅节省高性能磁盘（SSD）的占用空间。
统一的搜索体验 # 快照搜索与在线集群共享统一的 API 和查询语法，业务人员无需学习新接口即可调取历史记录。
前置条件 # 配置 search 角色节点 # 只有角色为 search 的节点才能执行快照搜索。在 easysearch.yml 中配置：
node.name: search-node node.roles: [search] Docker 环境：
- node.roles: [search] 集群中至少需要一个 search 角色节点才能使用可搜索快照功能。
注册快照仓库 # 以 MinIO（S3 兼容）为例：
PUT _snapshot/my-repo { &amp;#34;type&amp;#34;: &amp;#34;s3&amp;#34;, &amp;#34;settings&amp;#34;: { &amp;#34;access_key&amp;#34;: &amp;#34;minioadmin&amp;#34;, &amp;#34;secret_key&amp;#34;: &amp;#34;minioadmin&amp;#34;, &amp;#34;bucket&amp;#34;: &amp;#34;es-bucket&amp;#34;, &amp;#34;endpoint&amp;#34;: &amp;#34;http://127.</description></item><item><title>数据汇总</title><link>/easysearch/main/docs/features/data-retention/rollup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/data-retention/rollup/</guid><description>数据汇总 # 先读概述：如果您尚未了解 Rollup 的优势与应用场景，建议先阅读 数据生命周期 中的 Rollup 部分。
数据汇总或上卷（Rollup），对于时序场景类的数据，往往会有大量的非常详细的聚合指标，随着时间的图推移，存储将持续增长。汇总功能可以将旧的、细粒度的数据汇总为粗粒度格式以进行长期存储。通过将数据汇总到一个单一的文档中，可以大大降低历史数据的存储成本。 Easysearch 的 rollup 具备一些独特的优势，可以自动对 rollup 索引进行滚动而不用依赖其他 API 去单独设置，并且在进行聚合查询时支持直接搜索原始索引，做到了对业务端的搜索代码完全兼容，从而对用户无感知。
支持的聚合类型 # 对数值类型字段支持的聚合
avg sum max min value_count percentiles 对 keyword 类型字段提供 terms 聚合。
对 date 类型字段 除了 date_histogram 聚合，还支持 date_range 聚合。(v1.10.0)
查询 rollup 数据时，增加支持 Filter aggregation，某些场景可以用来替代 query 过滤数据。(v1.10.1)
增加针对个别字段自定义 special_metrics 指标的配置项。 (v1.10.1)
增加支持 Bucket sort aggregation。 (v1.10.1)
混合查询原始索引和 rollup 索引时，返回的 response 里增加了 origin 参数，表示包含 rollup 数据。(v1.</description></item><item><title>备份与恢复</title><link>/easysearch/main/docs/features/data-retention/backup-restore/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/data-retention/backup-restore/</guid><description>备份与恢复 # 副本提供了高可用性，但无法防御灾难性故障（如误删除、数据损坏、机房级故障）。快照（Snapshot） 是 Easysearch 的备份机制，提供完整的数据保护能力。
快照机制概述 # 核心特点 # 增量备份：首次快照是全量备份，后续快照只保存变化的数据 不阻塞写入：快照过程不会阻止正常的索引和搜索操作 支持多种存储：共享文件系统、S3、HDFS、Azure Blob 等 灵活恢复：可恢复到同一集群或不同集群，支持重命名 工作流程 # ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ 创建仓库 │───▶│ 执行快照 │───▶│ 恢复数据 │ └─────────────┘ └─────────────┘ └─────────────┘ │ │ │ ▼ ▼ ▼ 配置存储位置 选择索引范围 选择目标索引 设置访问权限 等待快照完成 可重命名恢复 创建快照仓库 # 快照需要先配置一个仓库（Repository），仓库定义了快照的存储位置。
共享文件系统仓库 # 前提条件：
所有节点都能访问同一个共享目录（NFS、GlusterFS 等） 在 easysearch.yml 中配置允许的路径： path.repo: [&amp;#34;/mount/backups&amp;#34;, &amp;#34;/mount/snapshots&amp;#34;] 创建仓库：</description></item><item><title>时间序列索引优化</title><link>/easysearch/main/docs/features/data-retention/time-series/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/features/data-retention/time-series/</guid><description>时间序列索引优化 # 最低版本：1.12.1
概述 # 在处理时序数据（如日志、监控指标、事件流）时，数据通常具有明显的时间先后顺序。Easysearch 底层的 Lucene Segment 合并是保证搜索性能和资源效率的关键操作。 然而，默认的合并策略（TieredMergePolicy）主要基于 Segment 的大小和删除文档比例来决定合并哪些 Segment，它并不感知数据的时间属性。
对于时序场景，默认策略可能导致：
冷热数据混合合并：较旧的（冷）数据 Segment 可能与较新的（热）数据 Segment 合并，导致不必要的 I/O 和 CPU 开销。 查询性能下降：跨时间范围的大 Segment 可能降低按时间范围过滤的查询效率。 为此，Easysearch 引入了基于时间范围的合并策略（TimeRangeMergePolicy），专为时序索引优化 Segment 合并行为。
核心原理 # TimeRangeMergePolicy 在选择要合并的 Segment 时，除了考虑大小、删除比例等因素外，优先考虑 Segment 所覆盖的时间范围：
时间优先：倾向于合并时间上相邻的 Segment，保持数据的&amp;quot;时间局部性&amp;quot;。 保留时间分区：避免将时间跨度很大的 Segment 合并在一起。 优先合并新数据：新写入的数据变化更频繁，优先合并较新的 Segment 有助于更快回收空间和优化查询性能。 工作流程 # 每个 Segment 在创建时记录 min_timestamp 和 max_timestamp。 合并候选按最新时间倒序排列（同一时间的按大小排列）。 候选合并组的评分以时间跨度为主要因子 — 时间跨度越小评分越优。 单次合并限制在 max_merge_at_once 个 Segment 以内，合并后大小不超过 max_merged_segment。 如何启用 # 设置索引的 index.</description></item></channel></rss>