<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>控制条件 on INFINI Easysearch</title><link>/easysearch/main/docs/references/ingest-pipelines/conditional-execution/</link><description>Recent content in 控制条件 on INFINI Easysearch</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/main/docs/references/ingest-pipelines/conditional-execution/index.xml" rel="self" type="application/rss+xml"/><item><title>复杂逻辑</title><link>/easysearch/main/docs/references/ingest-pipelines/conditional-execution/complex-conditionals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/references/ingest-pipelines/conditional-execution/complex-conditionals/</guid><description>复杂逻辑 # 在摄取管道中，处理器中的 if 参数可以使用 Painless 脚本来评估复杂条件。这些条件有助于微调文档处理，允许进行高级逻辑，例如类型检查、正则表达式和组合多个标准。
多条件检查 # 您可以将逻辑运算符如 &amp;amp;&amp;amp; （与）、 || （或）和 ! （非）组合起来构建更复杂的条件。以下管道标签将文档标记为 spam ，如果它们包含一个高于 1000 的 error_code ，则将其丢弃：
PUT _ingest/pipeline/spammy_error_handler { &amp;quot;processors&amp;quot;: [ { &amp;quot;set&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;tags&amp;quot;, &amp;quot;value&amp;quot;: [&amp;quot;spam&amp;quot;], &amp;quot;if&amp;quot;: &amp;quot;ctx.message != null &amp;amp;&amp;amp; ctx.message.contains('OutOfMemoryError')&amp;quot; } }, { &amp;quot;drop&amp;quot;: { &amp;quot;if&amp;quot;: &amp;quot;ctx.tags != null &amp;amp;&amp;amp; ctx.tags.contains('spam') &amp;amp;&amp;amp; ctx.error_code != null &amp;amp;&amp;amp; ctx.error_code &amp;gt; 1000&amp;quot; } } ] } 您可以使用以下 _simulate 请求测试管道：
POST _ingest/pipeline/spammy_error_handler/_simulate { &amp;quot;docs&amp;quot;: [ { &amp;quot;_source&amp;quot;: { &amp;quot;message&amp;quot;: &amp;quot;OutOfMemoryError occurred&amp;quot;, &amp;quot;error_code&amp;quot;: 1200 } }, { &amp;quot;_source&amp;quot;: { &amp;quot;message&amp;quot;: &amp;quot;OutOfMemoryError occurred&amp;quot;, &amp;quot;error_code&amp;quot;: 800 } }, { &amp;quot;_source&amp;quot;: { &amp;quot;message&amp;quot;: &amp;quot;All good&amp;quot;, &amp;quot;error_code&amp;quot;: 200 } } ] } 第一份文档被丢弃，因为它包含一个 OutOfMemoryError 字符串和一个高于 1000 的 error_code ：</description></item><item><title>控制条件和处理器</title><link>/easysearch/main/docs/references/ingest-pipelines/conditional-execution/conditional-pipeline-processor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/references/ingest-pipelines/conditional-execution/conditional-pipeline-processor/</guid><description>控制条件和处理器 # 在摄取管道中， pipeline 处理器允许根据文档内容条件性地执行不同的子管道。当不同类型的文档需要单独的处理逻辑时，这提供了强大的灵活性。您可以使用 if 参数在 pipeline 处理器中根据字段值、数据类型或内容结构将文档路由到不同的管道。然后，每个管道可以独立应用自己的处理器集。这种方法通过仅在相关位置应用逻辑，保持了管道的模块化和可维护性。
示例：按服务路由日志 # 以下示例演示了如何根据文档中的 service.name 字段将日志路由到不同的子管道。
创建第一个名为 webapp_logs 的管道：
PUT _ingest/pipeline/webapp_logs { &amp;quot;processors&amp;quot;: [ { &amp;quot;set&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;log_type&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;webapp&amp;quot; } } ] } 创建第二个名为 api_logs 的管道：
PUT _ingest/pipeline/api_logs { &amp;quot;processors&amp;quot;: [ { &amp;quot;set&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;log_type&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;api&amp;quot; } } ] } 创建主路由管道名为 service_router ，根据 service.name 将文档路由到相应的管道：
PUT _ingest/pipeline/service_router { &amp;quot;processors&amp;quot;: [ { &amp;quot;pipeline&amp;quot;: { &amp;quot;name&amp;quot;: &amp;quot;webapp_logs&amp;quot;, &amp;quot;if&amp;quot;: &amp;quot;ctx.</description></item><item><title>正则表达式条件</title><link>/easysearch/main/docs/references/ingest-pipelines/conditional-execution/regex-conditionals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/references/ingest-pipelines/conditional-execution/regex-conditionals/</guid><description>正则表达式条件 # 摄取管道支持使用正则表达式（regex）和 Painless 脚本语言进行条件逻辑。这允许根据文本字段的结构和内容对哪些文档进行处理进行精细控制。正则表达式可以用于 if 参数中评估字符串模式。这对于匹配 IP 格式、验证电子邮件地址、识别 UUID 或处理包含特定关键字的日志特别有用。
示例：电子邮件名过滤 # 以下管道使用正则表达式来识别来自 @example.com 电子邮件域的用户，并相应地标记这些文档：
PUT _ingest/pipeline/tag_example_com_users { &amp;quot;processors&amp;quot;: [ { &amp;quot;set&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;user_domain&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;example.com&amp;quot;, &amp;quot;if&amp;quot;: &amp;quot;ctx.email != null &amp;amp;&amp;amp; ctx.email =~ /@example.com$/&amp;quot; } } ] } 使用以下请求来模拟管道：
POST _ingest/pipeline/tag_example_com_users/_simulate { &amp;quot;docs&amp;quot;: [ { &amp;quot;_source&amp;quot;: { &amp;quot;email&amp;quot;: &amp;quot;alice@example.com&amp;quot; } }, { &amp;quot;_source&amp;quot;: { &amp;quot;email&amp;quot;: &amp;quot;bob@another.com&amp;quot; } } ] } 只有第一份文档添加了 user_domain ：
{ &amp;quot;docs&amp;quot;: [ { &amp;quot;doc&amp;quot;: { &amp;quot;_source&amp;quot;: { &amp;quot;email&amp;quot;: &amp;quot;alice@example.</description></item></channel></rss>