<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>搜索操作 on INFINI Easysearch</title><link>/easysearch/main/docs/references/search/</link><description>Recent content in 搜索操作 on INFINI Easysearch</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/main/docs/references/search/index.xml" rel="self" type="application/rss+xml"/><item><title>查询和过滤上下文</title><link>/easysearch/main/docs/references/search/query-filter-context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/references/search/query-filter-context/</guid><description>查询和过滤上下文 # 查询由查询子句组成，这些子句可以在过滤（filter）上下文或查询上下文中运行。 在过滤（filter）上下文中的查询子句会询问“文档是否匹配查询子句？”并返回匹配的文档。在查询上下文中的查询子句会询问“文档与查询子句匹配程度如何？”，返回匹配的文档，并以相关性分数的形式提供每个文档的相关性。
相关性分数 # 相关性分数衡量文档与查询的匹配程度。它是一个正浮点数，Easysearch 会记录在每个文档的 _score 元数据字段中：
&amp;quot;hits&amp;quot; : [ { &amp;quot;_index&amp;quot; : &amp;quot;shakespeare&amp;quot;, &amp;quot;_id&amp;quot; : &amp;quot;32437&amp;quot;, &amp;quot;_score&amp;quot; : 18.781435, &amp;quot;_source&amp;quot; : { &amp;quot;type&amp;quot; : &amp;quot;line&amp;quot;, &amp;quot;line_id&amp;quot; : 32438, &amp;quot;play_name&amp;quot; : &amp;quot;Hamlet&amp;quot;, &amp;quot;speech_number&amp;quot; : 3, &amp;quot;line_number&amp;quot; : &amp;quot;1.1.3&amp;quot;, &amp;quot;speaker&amp;quot; : &amp;quot;BERNARDO&amp;quot;, &amp;quot;text_entry&amp;quot; : &amp;quot;Long live the king!&amp;quot; } }, ... 一个更高的分数表示文档更相关。虽然不同的查询类型计算相关性分数的方式不同，但所有查询类型都会考虑查询子句是在过滤（filter）上下文还是查询上下文中运行。
在查询上下文中使用你想影响相关性分数的查询子句，并在过滤（filter）上下文中使用所有其他查询子句。
过滤上下文 # 在过滤上下文中的查询子句会问“文档是否匹配查询子句？”，这个问题有二元答案。例如，如果你有一个包含学生数据的索引，你可以使用过滤上下文来回答以下关于学生的疑问:
学生的 honors 状态是否设置为 true ？ 学生的 graduation_year 是否在 2020–2022 范围内？ 使用过滤上下文时，Easysearch 会返回匹配的文档，而不会计算相关性分数。因此，您应该使用过滤上下文来处理具有精确值的字段。</description></item><item><title>精确查询与全文检索的对比</title><link>/easysearch/main/docs/references/search/term-vs-full-text/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/references/search/term-vs-full-text/</guid><description>精确查询与全文检索的对比 # 您可以使用精确查询和全文检索来搜索文本，但精确查询通常用于搜索结构化数据，而全文检索则用于全文搜索。精确查询与全文检索的主要区别在于，精确查询搜索文档中的确切指定词项，而全文检索分析查询字符串。下表总结了精确查询与全文检索之间的差异。
精确查询 全文检索 描述 精确查询回答哪些文档匹配查询。 全文检索回答文档与查询匹配的程度。 分词器 搜索词没有被分析。这意味着精确查询会按照你输入的搜索词进行搜索。 搜索词由在索引特定文档字段时使用的相同分词器进行分析。这意味着您的搜索词会经历与文档字段相同的分词过程。 相关性 词级查询仅返回匹配的文档，而不根据相关性分数对它们进行排序。它们仍然计算相关性分数，但这个分数是所有返回文档相同的。 全文检索为每个匹配计算相关性分数，并按相关性分数降序对结果进行排序。 用例 当你需要匹配精确值（如数字、日期或标签）且不需要按相关性排序时，使用词级查询。 使用全文检索来匹配文本字段，并根据大小写和词干变化等因素进行相关性排序。 Easysearch 使用 BM25 排序算法来计算相关性分数。欲了解更多信息，请参阅 Okapi BM25。
我应该使用全文检索还是精确查询？ # 为了说明全文检索和精确查询的区别，考虑以下两个搜索特定文本短语的示例。莎士比亚的全部作品在一个 Easysearch 集群中被索引。
示例：短语搜索 # 在这个示例中，你将在 text_entry 字段中搜索莎士比亚的全部作品中短语“To be, or not to be”。
首先，使用精确查询进行此搜索：
GET shakespeare/_search { &amp;quot;query&amp;quot;: { &amp;quot;term&amp;quot;: { &amp;quot;text_entry&amp;quot;: &amp;quot;To be, or not to be&amp;quot; } } } 返回内容不包含任何匹配项，hits 为 0：</description></item><item><title>全匹配查询</title><link>/easysearch/main/docs/references/search/match-all/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/references/search/match-all/</guid><description>全匹配查询 # match_all 查询返回所有文档。如果需要返回整个文档集，这个查询在测试大量文档集时很有用。
GET _search { &amp;quot;query&amp;quot;: { &amp;quot;match_all&amp;quot;: {} } } match_all 查询有一个 match_none 的对应查询，这个对应查询很少有用：
GET _search { &amp;quot;query&amp;quot;: { &amp;quot;match_none&amp;quot;: {} } } 参数说明 # 全匹配和全不匹配查询都接受以下参数。所有参数都是可选的。
参数 数据类型 描述 boost Float 一个浮点数值，用于指定该字段对相关性分数的权重。大于 1.0 的值会增加字段的权重。介于 0.0 和 1.0 之间的值会降低字段的权重。默认值为 1.0。 _name String 用于查询标签的查询名称。可选。</description></item><item><title>最小匹配</title><link>/easysearch/main/docs/references/search/minimum-should-match/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/references/search/minimum-should-match/</guid><description>最小匹配 # minimum_should_match 参数可用于全文搜索，并指定文档必须匹配的最小词项数量才能在搜索结果中返回。
以下示例要求文档至少匹配三个搜索词中的两个才能作为搜索结果返回：
GET /shakespeare/_search { &amp;quot;query&amp;quot;: { &amp;quot;match&amp;quot;: { &amp;quot;text_entry&amp;quot;: { &amp;quot;query&amp;quot;: &amp;quot;prince king star&amp;quot;, &amp;quot;minimum_should_match&amp;quot;: &amp;quot;2&amp;quot; } } } } 在这个示例中，查询有三个可选子句，它们通过 OR 结合，因此文档必须匹配 prince 和 king ，或者 prince 和 star ，或者 king 和 star 。
参数值说明 # 您可以指定 minimum_should_match 参数为以下值之一。
值类型 示例 描述 非负整数 2 一个文档必须匹配这个数量的可选子句。 负整数 -1 一个文档必须匹配可选子句总数减去这个数。 非负百分比 70% 一个文档必须匹配可选子句总数的这个百分比。要匹配的子句数向下取整到最接近的整数。 负百分比 -30% 一个文档可以有这个百分比的不匹配的可选子句。文档允许不匹配的子句数向下取整到最接近的整数。 组合 2&amp;lt;75% n&amp;lt;p% 格式的表达式。如果可选子句的数量小于或等于 n ，文档必须匹配所有可选子句。如果可选子句的数量大于 n ，则文档必须匹配 p 百分比的可选子句。 多种组合 3&amp;lt;-1 5&amp;lt;50% 用空格分隔的多个组合。每个条件适用于 &amp;lt; 符号左侧数字更多的可选子句数量。在这个例子中，如果有三个或更少可选子句，文档必须匹配所有它们。如果有四或五个可选子句，文档必须匹配所有但一个。如果有 6 个或更多可选子句，文档必须匹配 50% 的它们。 设 n 为文档必须匹配的可选子句数量。当 n 计算为百分比时，如果 n 小于 1，则使用 1。如果 n 大于可选子句的数量，则使用可选子句的数量。</description></item><item><title>正则表达式语法</title><link>/easysearch/main/docs/references/search/regex-syntax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/references/search/regex-syntax/</guid><description>正则表达式语法 # 正则表达式（regex）是一种使用特殊符号和运算符定义搜索模式的方法。这些模式允许你在字符串中匹配字符序列。
在 Easysearch 中，你可以在以下查询类型中使用正则表达式：
regexp query_string Easysearch 使用 Apache Lucene 正则表达式引擎，该引擎有自己的语法和限制。它不使用 Perl 兼容正则表达式（PCRE），因此某些熟悉的正则表达式功能可能会表现不同或不受支持。
在 regexp 和 query_string 查询之间进行选择 # regexp 和 query_string 查询都支持正则表达式，但它们的行为不同，适用于不同的使用场景。
特性 regexp 查询 query_string 查询 模式匹配 正则表达式模式必须匹配整个字段值 正则表达式模式可以匹配字段中的任何部分 flags 支持 flags 启用可选正则表达式运算符 flags 不支持 查询类型 词级查询（未评分） 全文检索（评分和解析） 最佳使用场景 对关键字或精确字段进行严格模式匹配 使用支持正则表达式模式的灵活查询字符串在分析字段中进行搜索 复杂查询组合 仅限于正则表达式模式 支持 AND 、 OR 、通配符、字段、提升值以及其他功能。参见查询字符串查询。 保留字符 # Lucene 的正则表达式引擎支持所有 Unicode 字符。然而，以下字符被视为特殊运算符：</description></item><item><title>重写参数</title><link>/easysearch/main/docs/references/search/rewrite-parameter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/references/search/rewrite-parameter/</guid><description>重写参数 # 像 wildcard 、 prefix 、 regexp 、 fuzzy 和 range 这样的多词查询在内部会重组成一组词。 rewrite 参数允许你控制这些词重写的执行和评分。
当多词查询扩展成很多词（例如 prefix: &amp;quot;error*&amp;quot; 匹配数百个词）时，它们在内部会转换成 term 查询。这个过程可能会有以下缺点：
超出 indices.query.bool.max_clause_count 限制（默认是 1024 ）。 影响匹配文档的评分计算方式。 根据所使用的重写方法，影响内存和延迟。 rewrite 参数让你能够控制多词查询的内部行为。
模式 评分规则 性能 注释 constant_score 所有匹配具有相同分数 最佳 默认模式，适合过滤器 scoring_boolean 基于 TF/IDF 中等 完整相关性评分 constant_score_boolean 相同分数但使用布尔结构 中等 与 must_not 或 minimum_should_match 一起使用 top_terms_N 在顶部 N 个词上使用 TF/IDF 高效 截断扩展 top_terms_boost_N 静态提升 快速 较低准确度 top_terms_blended_freqs_N 混合评分 平衡 最佳评分/效率权衡 可用的重写方法 # 下表总结了可用的重写方法。</description></item><item><title>向量查询</title><link>/easysearch/main/docs/references/search/knn_api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/references/search/knn_api/</guid><description>向量查询 # 使用 kNN 检索 API 来进行向量查询。
先决条件 # 要运行 kNN 搜索，必须安装 knn 插件，参考 插件安装 。
创建 Mapping 和 Setting # 在索引向量之前，首先定义一个 Mapping，指定向量数据类型、索引模型和模型的参数。这决定了索引向量支持哪些查询。 并指定 index.knn 为 true ，这是为了启用近似相似度模型。
从1.11.1 版本开始，index.knn 已弃用，创建 knn 索引时，不再配置 index.knn 参数。
请求示例 # PUT /knn-test { &amp;quot;mappings&amp;quot;: { &amp;quot;properties&amp;quot;: { &amp;quot;my_vec&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;knn_dense_float_vector&amp;quot;, &amp;quot;knn&amp;quot;: { &amp;quot;dims&amp;quot;: 50, &amp;quot;model&amp;quot;: &amp;quot;lsh&amp;quot;, &amp;quot;similarity&amp;quot;: &amp;quot;cosine&amp;quot;, &amp;quot;L&amp;quot;: 99, &amp;quot;k&amp;quot;: 1 } } } } } 参数说明 # my_vec 存储向量的字段名称 knn_dense_float_vector 表示数据类型为密集型浮点向量.</description></item><item><title>查询模版</title><link>/easysearch/main/docs/references/search/search-template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/references/search/search-template/</guid><description>查询模版 # 您可以将全文查询转换为查询模版，以接受用户输入并将其动态插入到查询中。
例如，如果您使用 Easysearch 作为应用程序或网站的后端搜索引擎，则可以从搜索栏或表单字段接收用户查询，并将其作为参数传递到查询模版中。这样，创建 Easysearch 查询的语法就从最终用户那里抽象出来了。
当您编写代码将用户输入转换为 Easysearch 查询时，可以使用查询模版简化代码。如果需要将字段添加到搜索查询中，只需修改模板即可，而无需更改代码。
查询模版使用 Mustache 语言。有关所有语法选项的列表，请参阅 Mustache 手册。
创建查询模版 # 查询模版有两个组件：查询和参数。参数是放置在变量中的用户输入值。在 Mustache 符号中，变量用双括号表示。当在查询中遇到类似 {% raw %}{{var}}{% endraw %} 的变量时，Easysearch 会转到 params 部分，查找名为 var 的参数，并用指定的值替换它。
您可以编写应用程序代码，询问用户要搜索什么，然后在运行时将该值插入 params 对象中。
此命令定义了一个查询模版，用于按名称查找播放。查询中的 {% raw %}{{play_name}}{% endraw %} 被值 Henry IV 替换：
GET _search/template { &amp;#34;source&amp;#34;: { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;play_name&amp;#34;: &amp;#34;{% raw %}{{play_name}}{% endraw %}&amp;#34; } } }, &amp;#34;params&amp;#34;: { &amp;#34;play_name&amp;#34;: &amp;#34;Henry IV&amp;#34; } } 此模板在整个集群上运行搜索。</description></item><item><title>异步搜索</title><link>/easysearch/main/docs/references/search/async_search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/references/search/async_search/</guid><description>异步搜索 # 搜索大量数据可能会花费很长时间，尤其是当你在热节点或者多个远程集群中进行搜索时。
Easysearch 中的异步搜索允许你发送在后台运行的搜索请求。你可以监控这些搜索的进度，并且在部分结果可用时获取这些部分结果。在搜索完成之后，你可以保存结果以便日后查看。
先决条件 # Easysearch 从 1.11.1 版本开始，内置支持异步搜索。
REST API # 引入版本 1.11.0
要执行异步搜索，请向 /{index}/_async_search 发送请求，并在请求正文中包含您的查询：
POST test-index/_asynch_search 可以指定以下选项。
选项 描述 默认值 是否必填 wait_for_completion_timeout 计划等待结果的时间。在此时间内，您可以像在普通搜索中一样查看所获得的结果。您可以根据ID轮询剩余的结果。最大值为300秒。 1秒 否 keep_on_completion 搜索完成后，您是否希望将结果保存在集群中。您可以在稍后查看存储的结果。 false 否 keep_alive 结果在集群中保存的时间。例如，2d 表示结果在集群中存储48小时。保存的搜索结果在此时间段结束后或如果搜索被取消时将被删除。请注意，这包括查询执行时间。如果查询超过此时间，进程将自动取消该查询。 12小时 否 index 要搜索的索引名称。可以是单个名称、用逗号分隔的索引列表，或索引名称的通配符表达式。 集群中的所有索引 否 请求示例 # POST test-index/_async_search?wait_for_completion_timeout=1ms&amp;amp;keep_on_completion=true { &amp;quot;query&amp;quot;: { &amp;quot;match&amp;quot;: { &amp;quot;name&amp;quot;: &amp;quot;张三&amp;quot; } } } 示例响应 # { &amp;quot;id&amp;quot;: &amp;quot;FmFqN0llTXlKVHF5cnV1NGdVNUlPancEMzMzMBRaOUNxU3BVQlRIdzczZmJfNnZtRQIyMA==&amp;quot;, &amp;quot;state&amp;quot;: &amp;quot;RUNNING&amp;quot;, &amp;quot;start_time_in_millis&amp;quot;: 1740714470020, &amp;quot;expiration_time_in_millis&amp;quot;: 1740800870020, &amp;quot;response&amp;quot;: { &amp;quot;took&amp;quot;: 0, &amp;quot;timed_out&amp;quot;: false, &amp;quot;num_reduce_phases&amp;quot;: 0, &amp;quot;_shards&amp;quot;: { &amp;quot;total&amp;quot;: 1, &amp;quot;successful&amp;quot;: 0, &amp;quot;skipped&amp;quot;: 0, &amp;quot;failed&amp;quot;: 0 }, &amp;quot;hits&amp;quot;: { &amp;quot;max_score&amp;quot;: null, &amp;quot;hits&amp;quot;: [] } } } 响应参数 # 选项 描述 id 异步搜索的ID。使用此ID来监控搜索进度、获取其部分结果和/或删除结果。如果异步搜索在超时期限内完成，响应中不包含ID，因为结果未存储在集群中。 state 指定搜索是仍在运行还是已经完成，以及结果是否在集群中持久保存。可能的状态有 RUNNING（运行中）、SUCCEEDED（成功）、FAILED（失败）、PERSISTING（正在持久化）、PERSIST_SUCCEEDED（持久化成功）、PERSIST_FAILED（持久化失败）、CLOSED（已关闭）和 STORE_RESIDENT（存储驻留）。 start_time_in_millis 开始时间，单位为毫秒。 expiration_time_in_millis 过期时间，单位为毫秒。 took 搜索运行的总时长。 response 实际的搜索响应。 num_reduce_phases 协调节点从分片响应批次中聚合结果的次数（默认值为5）。如果与上次检索到的结果相比，此数字增加，您可以预期搜索响应中将包含额外的结果。 total 执行搜索的分片总数。 successful 协调节点成功接收到的分片响应数量。 aggregations 分片到目前为止已完成的聚合部分结果。 获取部分结果 # 提交异步搜索请求后，您可以使用在异步搜索响应中看到的ID请求部分响应。</description></item><item><title>定点查询</title><link>/easysearch/main/docs/references/search/pit_api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/main/docs/references/search/pit_api/</guid><description>定点查询 # 定点查询，也称为 Point in Time 搜索，具有与常规搜索相同的功能，不同之处在于 PIT 搜索作用于较旧的数据集，而常规搜索作用于实时数据集。PIT 搜索不绑定于特定查询，因此您可以在同一个冻结在时间点上的数据集上运行不同的查询。
您可以使用创建 PIT API 来创建 PIT。当您为一组索引创建 PIT 时，Easysearch 会锁定这些索引的一组段，使它们在时间上冻结。在底层，此 PIT 所需的资源不会被修改或删除。 如果作为 PIT 一部分的段被合并，Easysearch 会在 PIT 创建时通过 keep_alive 参数指定的时间段内保留这些段的副本。
创建 PIT 操作会返回一个 PIT ID，您可以使用该 ID 在冻结的数据集上运行多个查询。即使索引继续摄取数据并修改或删除文档，PIT 引用的数据自 PIT 创建以来不会发生变化。当您的查询包含 PIT ID 时， 您不需要将索引传递给搜索，因为它将使用该 PIT。使用 PIT ID 的搜索在多次运行时将产生完全相同的结果。
创建 PIT # 创建一个 PIT。查询参数 keep_alive 是必需的；它指定了保持 PIT 的时间长度。
端点 # POST /&amp;lt;target_indexes&amp;gt;/_pit?keep_alive=1h&amp;amp;routing=&amp;amp;expand_wildcards=&amp;amp;preference= 路径参数 # 参数 数据类型 描述 target_indexes 字符串 PIT 的目标索引名称。可以包含以逗号分隔的列表或通配符索引模式。 查询参数 # 参数 数据类型 描述 keep_alive 时间 保持 PIT 的时间长度。每次使用搜索 API 访问 PIT 时，PIT 的生命周期都会延长一段等于 keep_alive 参数的时间。必需。 preference 字符串 用于执行搜索的节点或分片。可选。默认为随机。 routing 字符串 指定将搜索请求路由到特定分片。可选。默认为文档的 _id。 expand_wildcards 字符串 可匹配通配符模式的索引类型。支持逗号分隔的值。有效值如下：</description></item></channel></rss>