<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SQL 查询 on INFINI Easysearch</title><link>/easysearch/v1.15.5/docs/references/sql/</link><description>Recent content in SQL 查询 on INFINI Easysearch</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/v1.15.5/docs/references/sql/index.xml" rel="self" type="application/rss+xml"/><item><title>SQL-JDBC</title><link>/easysearch/v1.15.5/docs/references/sql/sql-jdbc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.5/docs/references/sql/sql-jdbc/</guid><description>SQL-JDBC 驱动 # Easysearch 的 SQL jdbc 驱动程序是一个独立、直连的纯 Java 驱动程序，可将 JDBC 调用转换为 Easysearch SQL。
安装 # JDBC 驱动 可以从官网下载：https://release.infinilabs.com/easysearch/archive/plugins/sql-jdbc-1.7.1.jar
在 gradle 项目中安装 # 需要把sql-jdbc-1.x.x.jar 集成到本地 gradle 项目的libs目录，假设项目名称叫 jdbc-test
将下载的sql-jdbc jar 包放到 jdbc-test/libs/ 下：
在 项目 build.gradle 添加依赖
implementation files(&amp;lsquo;libs/sql-jdbc-1.0.0.jar&amp;rsquo;)
完整的build.gradle 配置：
plugins { id 'java' } group 'org.example' version '1.0-SNAPSHOT' repositories { mavenCentral() flatDir { dirs 'libs' } } dependencies { implementation files('libs/sql-jdbc-1.0.0.jar') testImplementation 'org.junit.jupiter:junit-jupiter-api:5.7.0' testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.7.0' } test { useJUnitPlatform() } 初始化 # String url = &amp;quot;jdbc:easysearch://https://localhost:9210&amp;quot;; Properties properties = new Properties(); properties.</description></item><item><title>聚合查询</title><link>/easysearch/v1.15.5/docs/references/sql/aggregations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.5/docs/references/sql/aggregations/</guid><description>聚合查询 # 介绍 # 聚合函数作用于一组值。它们通常与GROUP BY子句一起使用，将值分组为子集。
GROUP BY 子句 # GROUP BY 表达式可以是：
标识符：Identifier 序数：Ordinal 表达式：Expression 标识符 # group by 表达式可以是标识符：
os&amp;gt; SELECT gender, sum(age) FROM accounts GROUP BY gender; fetched rows / total rows = 2/2 +----------+------------+ | gender | sum(age) | |----------+------------| | F | 28 | | M | 101 | +----------+------------+ 序数 # group by 表达式可以是序数：
os&amp;gt; SELECT gender, sum(age) FROM accounts GROUP BY 1; fetched rows / total rows = 2/2 +----------+------------+ | gender | sum(age) | |----------+------------| | F | 28 | | M | 101 | +----------+------------+ group by 表达式可以是一个表达式。</description></item><item><title>全文搜索</title><link>/easysearch/v1.15.5/docs/references/sql/fulltext/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.5/docs/references/sql/fulltext/</guid><description>全文搜索 # 全文搜索是对存储的单个文档进行搜索，这与基于数据库中的原始文本的常规搜索有所区别。全文搜索尝试通过检查每个文档中的所有单词来匹配搜索条件。 在 Easysearch 中，提供的全文查询使你能够搜索在索引过程中分析的文本字段。
Match Query # 在 Easysearch 中，Match 查询是执行全文搜索的标准查询。MATCHQUERY 和 MATCH_QUERY 都是用于执行匹配查询的函数。
示例 1 # 这两个函数都可以接受字段名称作为第一个参数，文本作为第二个参数。
SQL query:
POST /_sql { &amp;quot;query&amp;quot; : &amp;quot;&amp;quot;&amp;quot; SELECT account_number, address FROM accounts WHERE MATCH_QUERY(address, 'Holmes') &amp;quot;&amp;quot;&amp;quot; } 解释：
{ &amp;quot;from&amp;quot; : 0, &amp;quot;size&amp;quot; : 200, &amp;quot;query&amp;quot; : { &amp;quot;bool&amp;quot; : { &amp;quot;filter&amp;quot; : [ { &amp;quot;bool&amp;quot; : { &amp;quot;must&amp;quot; : [ { &amp;quot;match&amp;quot; : { &amp;quot;address&amp;quot; : { &amp;quot;query&amp;quot; : &amp;quot;Holmes&amp;quot;, &amp;quot;operator&amp;quot; : &amp;quot;OR&amp;quot;, &amp;quot;prefix_length&amp;quot; : 0, &amp;quot;max_expansions&amp;quot; : 50, &amp;quot;fuzzy_transpositions&amp;quot; : true, &amp;quot;lenient&amp;quot; : false, &amp;quot;zero_terms_query&amp;quot; : &amp;quot;NONE&amp;quot;, &amp;quot;auto_generate_synonyms_phrase_query&amp;quot; : true, &amp;quot;boost&amp;quot; : 1.</description></item><item><title>复杂查询</title><link>/easysearch/v1.15.5/docs/references/sql/complex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.5/docs/references/sql/complex/</guid><description>复杂查询 # 子查询 (Subquery) # 子查询 (subquery) 是一个完整的 SELECT 语句，它被用在另一个语句中，并用括号括起来。从 explain 输出中，您可以注意到一些子查询实际上被转换为等效的联接查询来执行。
示例 1：表子查询 # SQL query:
POST /_sql { &amp;quot;query&amp;quot; : &amp;quot;&amp;quot;&amp;quot; SELECT a1.firstname, a1.lastname, a1.balance FROM accounts a1 WHERE a1.account_number IN ( SELECT a2.account_number FROM accounts a2 WHERE a2.balance &amp;gt; 10000 ) &amp;quot;&amp;quot;&amp;quot; } 解释：
{ &amp;quot;Physical Plan&amp;quot; : { &amp;quot;Project [ columns=[a1.balance, a1.firstname, a1.lastname] ]&amp;quot; : { &amp;quot;Top [ count=200 ]&amp;quot; : { &amp;quot;BlockHashJoin[ conditions=( a1.</description></item><item><title>基础查询</title><link>/easysearch/v1.15.5/docs/references/sql/basics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.5/docs/references/sql/basics/</guid><description>基础查询 # 介绍 # SQL 中的 SELECT 语句是从 Easysearch 索引中检索数据的最常见查询。在本文档中，只涵盖涉及单个索引和查询的简单 SELECT 语句。 SELECT 语句包括 SELECT、FROM、WHERE、GROUP BY、HAVING、ORDER BY 和 LIMIT 子句。其中，SELECT 和 FROM 是指定要获取哪些字段以及它们应该从哪个索引获取的基础。 其它所有子句都是可选的，根据您的需求使用。请继续阅读以了解它们的详细描述、语法和用例。
语法 # SELECT 语句的语法如下：
SELECT [ALL | DISTINCT] (* | expression) [[AS] alias] [, ...] FROM index_name [WHERE predicates] [GROUP BY expression [, ...] [HAVING predicates]] [ORDER BY expression [ASC | DESC] [NULLS {FIRST | LAST}] [, ...]] [LIMIT [offset, ] size] 尽管不支持批量执行多个查询语句，但仍然允许以分号 ; 结束。例如，你可以运行 SELECT * FROM accounts; 而不会遇到问题。这对于支持其他工具生成的查询，如 Microsoft Excel 或 BI 工具，非常有用。</description></item></channel></rss>