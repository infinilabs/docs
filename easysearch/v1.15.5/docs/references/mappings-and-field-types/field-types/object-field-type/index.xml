<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>对象字段类型 on INFINI Easysearch</title><link>/easysearch/v1.15.5/docs/references/mappings-and-field-types/field-types/object-field-type/</link><description>Recent content in 对象字段类型 on INFINI Easysearch</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/v1.15.5/docs/references/mappings-and-field-types/field-types/object-field-type/index.xml" rel="self" type="application/rss+xml"/><item><title>Flat 对象字段类型</title><link>/easysearch/v1.15.5/docs/references/mappings-and-field-types/field-types/object-field-type/flattened/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.5/docs/references/mappings-and-field-types/field-types/object-field-type/flattened/</guid><description>Flat 对象字段类型 # 在 Easysearch 中，您不需要在索引文档之前指定映射。如果您不指定映射，Easysearch 会使用动态映射自动映射文档中的每个字段及其子字段。当您摄取诸如日志之类的文档时，您可能事先不知道每个字段的子字段名称和类型。在这种情况下，动态映射所有新的子字段可能会快速导致&amp;quot;映射爆炸&amp;quot;，其中不断增长的字段数量可能会降低集群的性能。
Flat 对象字段类型通过将整个 JSON 对象视为字符串来解决这个问题。可以使用标准的点路径表示法访问 JSON 对象中的子字段，但它们不会被索引成单独的字段以供快速查找。
点表示法（a.b）中的字段名最大长度为 2^24 − 1。
Flat 对象字段类型提供以下优势：
高效读取：获取性能类似于关键字字段。 内存效率：将整个复杂的 JSON 对象存储在一个字段中而不索引其所有子字段，可以减少索引中的字段数量。 空间效率：Easysearch 不会为 flat 对象中的子字段创建倒排索引，从而节省空间。 迁移兼容性：您可以将数据从支持类似 flat 字段的数据库系统迁移到 Easysearch。 当字段及其子字段主要用于读取而不是用作搜索条件时，应将字段映射为 flat 对象，因为子字段不会被索引。当对象具有大量字段或您事先不知道内容时，flat 对象非常有用。
Flat 对象支持带有和不带有点路径表示法的精确匹配查询。有关支持的查询类型的完整列表，请参见支持的查询。
在文档中搜索特定嵌套字段的值可能效率低下，因为它可能需要对索引进行完整扫描，这可能是一个昂贵的操作。
Flat 对象不支持：
特定类型的解析。 数值运算，如数值比较或数值排序。 文本分析。 高亮显示。 使用点表示法(a.b)的子字段聚合。 按子字段过滤。 支持的查询 # Flat 对象字段类型支持以下查询：
Term Terms Terms set Prefix Range Match Multi-match Query string Simple query string Exists Wildcard 限制 # 以下限制适用于 Easysearch 中的 flat 对象：</description></item><item><title>Flat 对象字段类型</title><link>/easysearch/v1.15.5/docs/references/mappings-and-field-types/field-types/object-field-type/flattened_text/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.5/docs/references/mappings-and-field-types/field-types/object-field-type/flattened_text/</guid><description>flattened_text 字段类型 # Introduced 1.10.0
flattened_text 类型是一种特殊的数据结构，适用于存储和查询嵌套层次的数据，同时保留类似于 text 类型的灵活搜索特性，例如分词和全文匹配。它在处理结构化或者半结构化数据时非常有用，例如 JSON 对象或动态键值对映射。
定义映射 # { &amp;#34;properties&amp;#34;: { &amp;#34;my_field&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;flattened_text&amp;#34; } } } 特性 # 扁平化存储
将嵌套的 JSON 对象转换为扁平结构 保留完整的路径信息 支持点号访问内部字段 文本分析
支持标准分词器 支持短语查询 支持全文搜索功能 内部索引结构 每个 flattened_text 字段在 lucene 层面会创建多个子字段:
{field} - 存储所有键 {field}._value - 存储所有值 {field}._valueAndPath - 存储 &amp;ldquo;path=value&amp;rdquo; 格式 索引示例 # PUT my_index/_doc/1 { &amp;quot;my_field&amp;quot;: { &amp;quot;key1&amp;quot;: { &amp;quot;subkey1&amp;quot;: { &amp;quot;subkey2&amp;quot;: &amp;quot;quick brown fox&amp;quot; } } } } 查询示例 # 精确路径匹配 # // Match Query - 指定完整路径 GET my_index/_search { &amp;quot;query&amp;quot;: { &amp;quot;match&amp;quot;: { &amp;quot;my_field.</description></item><item><title>Join 字段类型</title><link>/easysearch/v1.15.5/docs/references/mappings-and-field-types/field-types/object-field-type/join/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.5/docs/references/mappings-and-field-types/field-types/object-field-type/join/</guid><description>Join 字段类型 # Join 字段类型用于在同一索引中的文档之间建立父/子关系。
代码样例 # 模拟创建一个映射来建立一个产品和其品牌之间的父/子关系：
PUT testindex1 { &amp;#34;mappings&amp;#34;: { &amp;#34;properties&amp;#34;: { &amp;#34;product_to_brand&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;join&amp;#34;, &amp;#34;relations&amp;#34;: { &amp;#34;brand&amp;#34;: &amp;#34;product&amp;#34; } } } } } 索引一个父文档：
PUT testindex1/_doc/1 { &amp;#34;name&amp;#34;: &amp;#34;Brand 1&amp;#34;, &amp;#34;product_to_brand&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;brand&amp;#34; } } 您也可以使用更简单的格式：
PUT testindex1/_doc/1 { &amp;#34;name&amp;#34;: &amp;#34;Brand 1&amp;#34;, &amp;#34;product_to_brand&amp;#34;: &amp;#34;brand&amp;#34; } 在索引子文档时，您需要指定 routing 查询参数，因为同一父/子层级中的父文档和子文档必须索引在同一分片上。每个子文档在 parent 字段中引用其父文档的 ID。
为每个父文档索引两个子文档：
PUT testindex1/_doc/3?routing=1 { &amp;#34;name&amp;#34;: &amp;#34;Product 1&amp;#34;, &amp;#34;product_to_brand&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;product&amp;#34;, &amp;#34;parent&amp;#34;: &amp;#34;1&amp;#34; } } PUT testindex1/_doc/4?</description></item><item><title>Nested 字段类型</title><link>/easysearch/v1.15.5/docs/references/mappings-and-field-types/field-types/object-field-type/nested/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.5/docs/references/mappings-and-field-types/field-types/object-field-type/nested/</guid><description>Nested 字段类型 # Nested 字段类型是一种特殊的 对象字段类型。
任何对象字段都可以包含一个对象数组。数组中的每个对象都会被动态映射为对象字段类型并以扁平化形式存储。这意味着数组中的对象会被分解成单独的字段，每个字段在所有对象中的值会被存储在一起。有时需要使用 Nested 嵌套类型来将嵌套对象作为一个整体保存，以便您可以对其关联性执行搜索。
扁平化形式 # 默认情况下，每个嵌套对象都被动态映射为对象字段类型。任何对象字段都可以包含一个对象数组。
PUT testindex1/_doc/100 { &amp;#34;patients&amp;#34;: [ {&amp;#34;name&amp;#34;: &amp;#34;John Doe&amp;#34;, &amp;#34;age&amp;#34;: 56, &amp;#34;smoker&amp;#34;: true}, {&amp;#34;name&amp;#34;: &amp;#34;Mary Major&amp;#34;, &amp;#34;age&amp;#34;: 85, &amp;#34;smoker&amp;#34;: false} ] } 当这些对象被存储时，它们会被扁平化，因此它们的内部表示形式具有每个字段的所有值的数组：
{ &amp;#34;patients.name&amp;#34;: [&amp;#34;John Doe&amp;#34;, &amp;#34;Mary Major&amp;#34;], &amp;#34;patients.age&amp;#34;: [56, 85], &amp;#34;patients.smoker&amp;#34;: [true, false] } 一些查询会在这种表示形式中正确工作。如果您搜索年龄大于 75 或者 吸烟的病人 &amp;quot;patients.smoker&amp;quot;: true，文档 id 100 应该匹配。
GET testindex1/_search { &amp;#34;query&amp;#34;: { &amp;#34;bool&amp;#34;: { &amp;#34;should&amp;#34;: [ { &amp;#34;term&amp;#34;: { &amp;#34;patients.</description></item><item><title>Object 对象字段类型</title><link>/easysearch/v1.15.5/docs/references/mappings-and-field-types/field-types/object-field-type/object/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.5/docs/references/mappings-and-field-types/field-types/object-field-type/object/</guid><description>Object 对象字段类型 # 对象字段类型包含一个 JSON 对象（一组名称/值对）。JSON 对象中的值可以是另一个 JSON 对象。在映射对象字段时不需要指定 object 作为类型，因为 object 是默认类型。
代码示例 # 创建一个带有对象字段的映射：
PUT testindex1/_mappings { &amp;#34;properties&amp;#34;: { &amp;#34;patient&amp;#34;: { &amp;#34;properties&amp;#34; : { &amp;#34;name&amp;#34; : { &amp;#34;type&amp;#34; : &amp;#34;text&amp;#34; }, &amp;#34;id&amp;#34; : { &amp;#34;type&amp;#34; : &amp;#34;keyword&amp;#34; } } } } } 索引一个包含对象字段的文档：
PUT testindex1/_doc/1 { &amp;#34;patient&amp;#34;: { &amp;#34;name&amp;#34; : &amp;#34;John Doe&amp;#34;, &amp;#34;id&amp;#34; : &amp;#34;123456&amp;#34; } } 嵌套对象在内部存储为扁平的键/值对。要引用嵌套对象中的字段，使用 parent field.child field（例如，patient.id）。
搜索 ID 为 123456 的患者信息：</description></item></channel></rss>