<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>复合查询 on INFINI Easysearch</title><link>/easysearch/v1.15.5/docs/references/search/compound/</link><description>Recent content in 复合查询 on INFINI Easysearch</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/v1.15.5/docs/references/search/compound/index.xml" rel="self" type="application/rss+xml"/><item><title>函数评分查询</title><link>/easysearch/v1.15.5/docs/references/search/compound/function-score/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.5/docs/references/search/compound/function-score/</guid><description>函数评分查询 # 如果您需要更改结果中返回的文档的相关性评分，请使用 function_score 查询。 function_score 查询定义了一个查询和一个或多个函数，这些函数可以应用于所有结果或结果的一部分，以重新计算它们的相关性评分。
使用一个评分函数 # 最基础的 function_score 查询示例使用一个函数来重新计算分数。以下查询使用一个 weight 函数将所有相关性分数加倍。此函数适用于所有结果文档，因为没有在 function_score 中指定 query 参数：
GET shakespeare/_search { &amp;quot;query&amp;quot;: { &amp;quot;function_score&amp;quot;: { &amp;quot;weight&amp;quot;: &amp;quot;2&amp;quot; } } } 将评分函数应用于文档子集 # 要将评分函数应用于文档子集，在函数中提供一个查询：
GET shakespeare/_search { &amp;quot;query&amp;quot;: { &amp;quot;function_score&amp;quot;: { &amp;quot;query&amp;quot;: { &amp;quot;match&amp;quot;: { &amp;quot;play_name&amp;quot;: &amp;quot;Hamlet&amp;quot; } }, &amp;quot;weight&amp;quot;: &amp;quot;2&amp;quot; } } } 支持的功能 # function_score 查询类型支持以下功能：
内置: weight ：将文档得分乘以一个预定义的增强因子。 random_score ：提供一个对单个用户一致的随机得分，但不同用户之间得分不同。 field_value_factor : 使用指定文档字段的值来重新计算分数。 衰减函数（ gauss 、 exp 和 linear ）：使用指定的衰减函数重新计算分数。 自定义： script_score : 使用脚本对文档进行评分。 权重函数 # 当您使用 weight 函数时，原始的相关性分数会乘以 weight 的浮点值：</description></item><item><title>加权</title><link>/easysearch/v1.15.5/docs/references/search/compound/boosting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.5/docs/references/search/compound/boosting/</guid><description>加权 # 如果你搜索“pitcher”这个词，你的结果可能既与棒球运动员有关，也与盛液体的容器有关。在棒球语境下搜索时，你可能想通过使用 must_not 子句完全排除包含“glass”或“water”的搜索结果。然而，如果你想保留这些结果但降低它们的关联度，可以使用 boosting 查询。
一个 boosting 查询返回与 positive 查询匹配的文档。在这些文档中，与 negative 查询也匹配的文档的关联度得分会降低（它们的关联度得分会乘以负的提升因子）。
参考用例 # 考虑一个包含两个文档的索引，你以如下方式索引：
PUT testindex/_doc/1 { &amp;quot;article_name&amp;quot;: &amp;quot;The greatest pitcher in baseball history&amp;quot; } PUT testindex/_doc/2 { &amp;quot;article_name&amp;quot;: &amp;quot;The making of a glass pitcher&amp;quot; } 使用以下匹配查询来搜索包含单词“pitcher”的文档：
GET testindex/_search { &amp;quot;query&amp;quot;: { &amp;quot;match&amp;quot;: { &amp;quot;article_name&amp;quot;: &amp;quot;pitcher&amp;quot; } } } 返回的两个文档具有相同的相关性分数：
{ &amp;quot;took&amp;quot;: 5, &amp;quot;timed_out&amp;quot;: false, &amp;quot;_shards&amp;quot;: { &amp;quot;total&amp;quot;: 1, &amp;quot;successful&amp;quot;: 1, &amp;quot;skipped&amp;quot;: 0, &amp;quot;failed&amp;quot;: 0 }, &amp;quot;hits&amp;quot;: { &amp;quot;total&amp;quot;: { &amp;quot;value&amp;quot;: 2, &amp;quot;relation&amp;quot;: &amp;quot;eq&amp;quot; }, &amp;quot;max_score&amp;quot;: 0.</description></item><item><title>布尔查询</title><link>/easysearch/v1.15.5/docs/references/search/compound/bool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.5/docs/references/search/compound/bool/</guid><description>布尔查询 # 一个布尔（ bool ）查询可以将多个查询子句组合成一个高级查询。这些子句通过布尔逻辑组合起来，以在结果中找到匹配的文档。
在布尔（ bool ）查询中使用以下查询子句：
子句 行为 must 逻辑 and 运算符。结果必须匹配此子句中的所有查询。 must_not 逻辑 not 运算符。所有匹配项都将被排除在结果之外。如果 must_not 包含多个子句，则只返回不匹配任何这些子句的文档。例如， &amp;quot;must_not&amp;quot;:[{clause_A}, {clause_B}] 等同于 NOT(A OR B) 。 should 逻辑 or 运算符。结果必须匹配至少一个查询。匹配更多 should 子句会增加文档的相关性分数。您可以使用 minimum_should_match 参数设置必须匹配的最小查询数量。如果一个查询包含 must 或 filter 子句，默认 minimum_should_match 值为 0。否则，默认 minimum_should_match 值为 1。 filter 逻辑 and 运算符，在应用查询之前首先应用于减少您的数据集。过滤器子句中的查询是一个是或否选项。如果文档匹配查询，则它将出现在结果中；否则，它将不会出现。过滤器查询的结果通常会被缓存以允许更快的返回。使用过滤器查询根据精确匹配、范围、日期或数字来过滤结果。 一个布尔查询具有以下结构：
GET _search { &amp;quot;query&amp;quot;: { &amp;quot;bool&amp;quot;: { &amp;quot;must&amp;quot;: [ {} ], &amp;quot;must_not&amp;quot;: [ {} ], &amp;quot;should&amp;quot;: [ {} ], &amp;quot;filter&amp;quot;: {} } } } 例如，假设您在 Easysearch 集群中索引了莎士比亚的全部作品。您希望构建一个满足以下要求的单个查询：</description></item><item><title>常量化评分查询</title><link>/easysearch/v1.15.5/docs/references/search/compound/constant-score/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.5/docs/references/search/compound/constant-score/</guid><description>常量化评分查询 # 如果您需要返回包含某个词的文档，而不管该词出现多少次，您可以使用 constant_score 查询。 constant_score 查询包装一个过滤器查询，并将结果中的所有文档的关联分数设置为 boost 参数的值。因此，所有返回的文档具有相同的关联分数，并且不考虑词频/逆文档频率（TF/IDF）。过滤器查询不会计算关联分数。此外，Easysearch 会缓存常用的过滤器查询以提高性能。
参考样例 # 使用以下查询返回 shakespeare 索引中包含单词“Hamlet”的文档：
GET shakespeare/_search { &amp;quot;query&amp;quot;: { &amp;quot;constant_score&amp;quot;: { &amp;quot;filter&amp;quot;: { &amp;quot;match&amp;quot;: { &amp;quot;text_entry&amp;quot;: &amp;quot;Hamlet&amp;quot; } }, &amp;quot;boost&amp;quot;: 1.2 } } } 结果中的所有文档都被分配了 1.2 的相关性分数：
{ &amp;quot;took&amp;quot;: 8, &amp;quot;timed_out&amp;quot;: false, &amp;quot;_shards&amp;quot;: { &amp;quot;total&amp;quot;: 1, &amp;quot;successful&amp;quot;: 1, &amp;quot;skipped&amp;quot;: 0, &amp;quot;failed&amp;quot;: 0 }, &amp;quot;hits&amp;quot;: { &amp;quot;total&amp;quot;: { &amp;quot;value&amp;quot;: 96, &amp;quot;relation&amp;quot;: &amp;quot;eq&amp;quot; }, &amp;quot;max_score&amp;quot;: 1.2, &amp;quot;hits&amp;quot;: [ { &amp;quot;_index&amp;quot;: &amp;quot;shakespeare&amp;quot;, &amp;quot;_id&amp;quot;: &amp;quot;32535&amp;quot;, &amp;quot;_score&amp;quot;: 1.</description></item><item><title>析取最大查询</title><link>/easysearch/v1.15.5/docs/references/search/compound/disjunction-max/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.5/docs/references/search/compound/disjunction-max/</guid><description>析取最大查询 # 析取最大（ dis_max ）查询返回与一个或多个查询子句匹配的任何文档。对于与多个查询子句匹配的文档，相关性得分设置为所有匹配查询子句中的最高相关性得分。
当返回的文档的相关性分数相同时，您可以使用 tie_breaker 参数来增加匹配多个查询子句的文档的权重。
参考样例 # 考虑一个包含两个文档的索引，您按照以下方式索引这些文档：
PUT testindex1/_doc/1 { &amp;quot;title&amp;quot;: &amp;quot; The Top 10 Shakespeare Poems&amp;quot;, &amp;quot;description&amp;quot;: &amp;quot;Top 10 sonnets of England's national poet and the Bard of Avon&amp;quot; } PUT testindex1/_doc/2 { &amp;quot;title&amp;quot;: &amp;quot;Sonnets of the 16th Century&amp;quot;, &amp;quot;body&amp;quot;: &amp;quot;The poems written by various 16-th century poets&amp;quot; } 使用 dis_max 查询来搜索包含单词“莎士比亚诗歌”的文档
GET testindex1/_search { &amp;quot;query&amp;quot;: { &amp;quot;dis_max&amp;quot;: { &amp;quot;queries&amp;quot;: [ { &amp;quot;match&amp;quot;: { &amp;quot;title&amp;quot;: &amp;quot;Shakespeare poems&amp;quot; }}, { &amp;quot;match&amp;quot;: { &amp;quot;body&amp;quot;: &amp;quot;Shakespeare poems&amp;quot; }} ] } } } 返回内容包含两个文档：</description></item></channel></rss>