<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>关联查询 on INFINI Easysearch</title><link>/easysearch/v1.15.5/docs/references/search/joining/</link><description>Recent content in 关联查询 on INFINI Easysearch</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/v1.15.5/docs/references/search/joining/index.xml" rel="self" type="application/rss+xml"/><item><title>子查询</title><link>/easysearch/v1.15.5/docs/references/search/joining/has-child/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.5/docs/references/search/joining/has-child/</guid><description>子查询 # has_child 查询返回匹配特定查询的子文档的父文档。您可以通过使用连接字段类型在相同索引中的文档之间建立父子关系。
has_child 查询比其他查询慢，因为它执行了连接操作。随着指向不同父文档的匹配子文档数量的增加，性能会降低。您搜索中的每个 has_child 查询都可能显著影响查询性能。如果您优先考虑速度，请避免使用此查询或尽可能限制其使用。
参考样例 # 在您运行一个 has_child 查询之前，您的索引必须包含一个连接字段，以便建立父子关系。索引映射请求使用以下格式：
PUT /example_index { &amp;quot;mappings&amp;quot;: { &amp;quot;properties&amp;quot;: { &amp;quot;relationship_field&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;join&amp;quot;, &amp;quot;relations&amp;quot;: { &amp;quot;parent_doc&amp;quot;: &amp;quot;child_doc&amp;quot; } } } } } 在这个例子中，您将配置一个包含代表产品和其品牌的文档的索引。
首先，创建索引并建立 brand 和 product 之间的父子关系：
PUT testindex1 { &amp;quot;mappings&amp;quot;: { &amp;quot;properties&amp;quot;: { &amp;quot;product_to_brand&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;join&amp;quot;, &amp;quot;relations&amp;quot;: { &amp;quot;brand&amp;quot;: &amp;quot;product&amp;quot; } } } } } 创建两个父（品牌）文档：
PUT testindex1/_doc/1 { &amp;quot;name&amp;quot;: &amp;quot;Luxury brand&amp;quot;, &amp;quot;product_to_brand&amp;quot; : &amp;quot;brand&amp;quot; } PUT testindex1/_doc/2 { &amp;quot;name&amp;quot;: &amp;quot;Economy brand&amp;quot;, &amp;quot;product_to_brand&amp;quot; : &amp;quot;brand&amp;quot; } 索引三个子（产品）文档：</description></item><item><title>嵌套查询</title><link>/easysearch/v1.15.5/docs/references/search/joining/nested/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.5/docs/references/search/joining/nested/</guid><description>嵌套查询 # nested 查询充当其他查询的包装器，用于搜索嵌套字段。嵌套字段对象被视为单独的文档进行搜索。如果对象匹配搜索条件， nested 查询将返回根级别的父文档。
参考样例 # 在运行 nested 查询之前，您的索引必须包含一个嵌套字段。
要配置一个包含嵌套字段的示例索引，请发送以下请求：
PUT /testindex { &amp;quot;mappings&amp;quot;: { &amp;quot;properties&amp;quot;: { &amp;quot;patient&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;nested&amp;quot;, &amp;quot;properties&amp;quot;: { &amp;quot;name&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot; }, &amp;quot;age&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot; } } } } } } 接下来，将一个文档索引到示例索引中：
PUT /testindex/_doc/1 { &amp;quot;patient&amp;quot;: { &amp;quot;name&amp;quot;: &amp;quot;John Doe&amp;quot;, &amp;quot;age&amp;quot;: 56 } } 要搜索嵌套的 patient 字段，请将您的查询包裹在 nested 查询中，并提供 path 给嵌套字段：
GET /testindex/_search { &amp;quot;query&amp;quot;: { &amp;quot;nested&amp;quot;: { &amp;quot;path&amp;quot;: &amp;quot;patient&amp;quot;, &amp;quot;query&amp;quot;: { &amp;quot;match&amp;quot;: { &amp;quot;patient.</description></item><item><title>父 ID 查询</title><link>/easysearch/v1.15.5/docs/references/search/joining/parent-id/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.5/docs/references/search/joining/parent-id/</guid><description>父 ID 查询 # parent_id 查询返回具有指定 ID 的父文档的子文档。您可以通过使用连接字段类型在相同索引中的文档之间建立父子关系。
参考样例 # 在您运行一个 parent_id 查询之前，您的索引必须包含一个连接字段，以便建立父子关系。索引映射请求使用以下格式：
PUT /example_index { &amp;quot;mappings&amp;quot;: { &amp;quot;properties&amp;quot;: { &amp;quot;relationship_field&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;join&amp;quot;, &amp;quot;relations&amp;quot;: { &amp;quot;parent_doc&amp;quot;: &amp;quot;child_doc&amp;quot; } } } } } 对于此示例，首先配置一个包含代表产品和其品牌的文档的索引，这些文档在 has_child 查询示例中有所描述。
要搜索特定父文档的子文档，请使用 parent_id 查询。以下查询返回具有 ID 1 的父文档的子文档（产品）：
GET testindex1/_search { &amp;quot;query&amp;quot;: { &amp;quot;parent_id&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;product&amp;quot;, &amp;quot;id&amp;quot;: &amp;quot;1&amp;quot; } } } 返回子产品：
{ &amp;quot;took&amp;quot;: 57, &amp;quot;timed_out&amp;quot;: false, &amp;quot;_shards&amp;quot;: { &amp;quot;total&amp;quot;: 1, &amp;quot;successful&amp;quot;: 1, &amp;quot;skipped&amp;quot;: 0, &amp;quot;failed&amp;quot;: 0 }, &amp;quot;hits&amp;quot;: { &amp;quot;total&amp;quot;: { &amp;quot;value&amp;quot;: 1, &amp;quot;relation&amp;quot;: &amp;quot;eq&amp;quot; }, &amp;quot;max_score&amp;quot;: 0.</description></item><item><title>父查询</title><link>/easysearch/v1.15.5/docs/references/search/joining/has-parent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.5/docs/references/search/joining/has-parent/</guid><description>父查询 # has_parent 查询返回匹配特定查询的父文档的子文档。您可以通过使用连接字段类型在相同索引中的文档之间建立父子关系。
has_parent 查询比其他查询慢，因为它执行了连接操作。随着匹配的父文档数量的增加，性能会降低。您搜索中的每个 has_parent 查询都可能显著影响查询性能。如果您优先考虑速度，请避免使用此查询或尽可能限制其使用。
参考样例 # 在您运行一个 has_parent 查询之前，您的索引必须包含一个连接字段，以便建立父子关系。索引映射请求使用以下格式：
PUT /example_index { &amp;quot;mappings&amp;quot;: { &amp;quot;properties&amp;quot;: { &amp;quot;relationship_field&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;join&amp;quot;, &amp;quot;relations&amp;quot;: { &amp;quot;parent_doc&amp;quot;: &amp;quot;child_doc&amp;quot; } } } } } 对于这个示例，首先配置一个包含代表产品和其品牌的文档的索引，这些文档如查询示例 has_child 中所述。
要搜索父项的子项，请使用 has_parent 查询。以下查询返回与查询 economy 匹配的品牌生产的子文档（产品）：
GET testindex1/_search { &amp;quot;query&amp;quot; : { &amp;quot;has_parent&amp;quot;: { &amp;quot;parent_type&amp;quot;:&amp;quot;brand&amp;quot;, &amp;quot;query&amp;quot;: { &amp;quot;match&amp;quot; : { &amp;quot;name&amp;quot;: &amp;quot;economy&amp;quot; } } } } } 返回由该品牌生产的所有产品：
{ &amp;quot;took&amp;quot;: 11, &amp;quot;timed_out&amp;quot;: false, &amp;quot;_shards&amp;quot;: { &amp;quot;total&amp;quot;: 1, &amp;quot;successful&amp;quot;: 1, &amp;quot;skipped&amp;quot;: 0, &amp;quot;failed&amp;quot;: 0 }, &amp;quot;hits&amp;quot;: { &amp;quot;total&amp;quot;: { &amp;quot;value&amp;quot;: 2, &amp;quot;relation&amp;quot;: &amp;quot;eq&amp;quot; }, &amp;quot;max_score&amp;quot;: 1, &amp;quot;hits&amp;quot;: [ { &amp;quot;_index&amp;quot;: &amp;quot;testindex1&amp;quot;, &amp;quot;_id&amp;quot;: &amp;quot;4&amp;quot;, &amp;quot;_score&amp;quot;: 1, &amp;quot;_routing&amp;quot;: &amp;quot;2&amp;quot;, &amp;quot;_source&amp;quot;: { &amp;quot;name&amp;quot;: &amp;quot;Electronic watch&amp;quot;, &amp;quot;sales_count&amp;quot;: 300, &amp;quot;product_to_brand&amp;quot;: { &amp;quot;name&amp;quot;: &amp;quot;product&amp;quot;, &amp;quot;parent&amp;quot;: &amp;quot;2&amp;quot; } } }, { &amp;quot;_index&amp;quot;: &amp;quot;testindex1&amp;quot;, &amp;quot;_id&amp;quot;: &amp;quot;5&amp;quot;, &amp;quot;_score&amp;quot;: 1, &amp;quot;_routing&amp;quot;: &amp;quot;2&amp;quot;, &amp;quot;_source&amp;quot;: { &amp;quot;name&amp;quot;: &amp;quot;Digital watch&amp;quot;, &amp;quot;sales_count&amp;quot;: 100, &amp;quot;product_to_brand&amp;quot;: { &amp;quot;name&amp;quot;: &amp;quot;product&amp;quot;, &amp;quot;parent&amp;quot;: &amp;quot;2&amp;quot; } } } ] } } 检索内部命中项 # 返回与查询匹配的父文档，请提供 inner_hits 参数：</description></item></channel></rss>