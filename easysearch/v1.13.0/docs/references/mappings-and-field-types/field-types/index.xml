<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>字段类型 on INFINI Easysearch</title><link>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/</link><description>Recent content in 字段类型 on INFINI Easysearch</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/index.xml" rel="self" type="application/rss+xml"/><item><title>Rank 字段类型</title><link>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/rank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/rank/</guid><description>Rank 字段类型 # 下表列出了 Easysearch 支持的所有 rank 字段类型。
字段数据类型 描述 rank_feature 提升或降低文档的相关性得分。 rank_features 提升或降低文档的相关性得分。用于特征列表稀疏的情况。 Rank feature 和 rank features 字段只能使用 rank feature 查询进行查询。它们不支持聚合或排序。
Rank feature 字段类型 # Rank feature 字段类型使用正浮点值来提升或降低文档在 rank_feature 查询中的相关性得分。默认情况下，该值会提升相关性得分。要降低相关性得分，请将可选参数 positive_score_impact 设置为 false。
示例 # 创建一个包含 rank feature 字段的映射：
PUT chessplayers { &amp;#34;mappings&amp;#34;: { &amp;#34;properties&amp;#34;: { &amp;#34;name&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;text&amp;#34; }, &amp;#34;rating&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;rank_feature&amp;#34; }, &amp;#34;age&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;rank_feature&amp;#34;, &amp;#34;positive_score_impact&amp;#34;: false } } } } 索引三个文档，其中包含一个提升得分的 rank_feature 字段（rating）和一个降低得分的 rank_feature 字段（age）：</description></item><item><title>IP 地址字段类型</title><link>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/ip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/ip/</guid><description>IP 地址字段类型 # IP 字段类型用于存储 IPv4 或 IPv6 格式的 IP 地址。
要表示 IP 地址范围，可以使用 IP 范围字段类型
参考代码 # 创建一个有 IP 地址的 mapping
PUT testindex { &amp;quot;mappings&amp;quot; : { &amp;quot;properties&amp;quot; : { &amp;quot;ip_address&amp;quot; : { &amp;quot;type&amp;quot; : &amp;quot;ip&amp;quot; } } } } 索引一个有 IP 地址的文档
PUT testindex/_doc/1 { &amp;quot;ip_address&amp;quot; : &amp;quot;10.24.34.0&amp;quot; } 查询一个特定 IP 地址的索引
GET testindex/_doc/1 { &amp;quot;query&amp;quot;: { &amp;quot;term&amp;quot;: { &amp;quot;ip_address&amp;quot;: &amp;quot;10.24.34.0&amp;quot; } } } 搜索 IP 地址及其关联的网络掩码 # 您可以使用无类别域间路由 (CIDR) 表示法查询索引中的 IP 地址。在 CIDR 表示法中，通过斜杠 / 分隔 IP 地址和前缀长度（0–32）。例如，前缀长度为 24 表示匹配所有具有相同前 24 位的 IP 地址。</description></item><item><title>match_only_text 字段类型</title><link>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/match_only_text/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/match_only_text/</guid><description>match_only_text 字段类型 # Introduced 1.10.0
简介 # match_only_text 是一个为全文搜索优化的字段类型，是 text 类型的变体。它通过省略词条位置、词频和规范化信息来减少存储需求,适合对存储成本敏感但仍需要基本全文搜索功能的场景。
主要特点 # 存储优化:
不存储位置信息 不存储词频信息 不存储规范化信息 显著减少索引大小 评分机制:
禁用评分计算 所有匹配文档得分统一为 1.0 查询支持:
支持大多数查询类型 不支持 interval 查询 不支持 span 查询 支持但不优化短语查询 使用场景 # 适合用于:
需要快速查找包含特定词条的文档 对存储成本敏感的大数据集 不需要复杂相关性排序的场景 不适合用于:
需要基于相关性排序的查询 依赖词条位置或顺序的查询 需要精确短语匹配的场景 映射示例 # PUT my_index { &amp;#34;mappings&amp;#34;: { &amp;#34;properties&amp;#34;: { &amp;#34;title&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;match_only_text&amp;#34; } } } } 参数配置 # 参数 说明 默认值 analyzer 分析器设置 standard boost 评分提升因子 1.</description></item><item><title>Percolator 过滤器字段类型</title><link>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/percolator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/percolator/</guid><description>Percolator 过滤器字段类型 # Percolator 字段类型将该字段视为查询处理。任何 JSON 对象字段都可以标记为 Percolator 字段。通常，文档被索引并用于搜索，而 Percolator 字段存储搜索条件，稍后通过 Percolate 查询将匹配文档到该条件。
参考代码 # 客户正在搜索价格在 400 美元或以下的桌子，并希望为此搜索创建警报。 创建一个映射，为查询字段分配一个 percolator 字段类型：
PUT testindex1 { &amp;quot;mappings&amp;quot;: { &amp;quot;properties&amp;quot;: { &amp;quot;search&amp;quot;: { &amp;quot;properties&amp;quot;: { &amp;quot;query&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;percolator&amp;quot; } } }, &amp;quot;price&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;float&amp;quot; }, &amp;quot;item&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot; } } } } 索引一个查询
PUT testindex1/_doc/1 { &amp;quot;search&amp;quot;: { &amp;quot;query&amp;quot;: { &amp;quot;bool&amp;quot;: { &amp;quot;filter&amp;quot;: [ { &amp;quot;match&amp;quot;: { &amp;quot;item&amp;quot;: { &amp;quot;query&amp;quot;: &amp;quot;table&amp;quot; } } }, { &amp;quot;range&amp;quot;: { &amp;quot;price&amp;quot;: { &amp;quot;lte&amp;quot;: 400.</description></item><item><title>二进制字段类型</title><link>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/binary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/binary/</guid><description>二进制字段类型 # 二进制字段类型包含以 Base64 编码存储的二进制值，这些值不可被搜索。
参考代码 # 创建包含二进制字段的映射
PUT testindex { &amp;quot;mappings&amp;quot; : { &amp;quot;properties&amp;quot; : { &amp;quot;binary_value&amp;quot; : { &amp;quot;type&amp;quot; : &amp;quot;binary&amp;quot; } } } } 索引一个二进制值的文档
PUT testindex/_doc/1 { &amp;quot;binary_value&amp;quot; : &amp;quot;bGlkaHQtd29rfx4=&amp;quot; } 使用 = 作为填充字符。不允许嵌入换行符。
参数说明 # 以下参数均为可选参数
doc_values：布尔值，指定字段是否应存储在磁盘上，以便用于聚合、排序或 script 操作。可选，默认为 false。 store：布尔值，指定字段值是否应存储，并可从 _source 字段中单独检索。可选，默认为 false。</description></item><item><title>别名字段类型</title><link>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/alias/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/alias/</guid><description>Alias 别名字段类型 # 别名字段类型为现有字段创建另一个名称。您可以在搜索和字段功能的 API 操作中使用别名字段，但存在一些例外情况。要设置别名，必须在 path 参数中指定原始字段名称。
参考代码 # PUT movies { &amp;quot;mappings&amp;quot; : { &amp;quot;properties&amp;quot; : { &amp;quot;year&amp;quot; : { &amp;quot;type&amp;quot; : &amp;quot;date&amp;quot; }, &amp;quot;release_date&amp;quot; : { &amp;quot;type&amp;quot; : &amp;quot;alias&amp;quot;, &amp;quot;path&amp;quot; : &amp;quot;year&amp;quot; } } } } 参数说明 # path：指向原始字段的完整路径，包括所有父对象。例如，parent.child.field_name。此参数为必填项。 别名（Alias）字段 # 别名（Alias）字段必须遵循以下规则：
一个别名字段只能引用一个原始字段。 在嵌套对象中，别名必须与原始字段位于相同的嵌套层级。 要更改别名引用的字段，需要更新映射配置。但请注意，之前存储的 Percolator 查询中的别名仍会继续引用原始字段，不会自动更新为新的字段引用。
原始字段 # 别名的原始字段必须遵守以下规则：
原始字段必须在别名字段创建之前定义。 原始字段不能是对象类型，也不能是另一个别名字段。 可以使用别名字段的搜索 API # 您可以在以下搜索 API 的只读操作中使用别名：</description></item><item><title>向量字段类型</title><link>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/knn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/knn/</guid><description>k-NN 向量字段类型 # 关于向量 # 在索引文档和运行查询时都需要指定向量类型。在这两种情况下，您都使用相同的 JSON 结构来定义向量类型。每个向量类型还有一个简写形式，这在使用不支持嵌套文档的工具时会很方便。以下示例展示了如何在索引向量时指定它们。
knn_dense_float_vector 密集向量类型 # 假设您已经定义了一个映射，其中 my_vec 的类型为 knn_dense_float_vector。
POST /my-index/_doc { &amp;#34;my_vec&amp;#34;: { &amp;#34;values&amp;#34;: [0.1, 0.2, 0.3, ...] # 1 } } POST /my-index/_doc { &amp;#34;my_vec&amp;#34;: [0.1, 0.2, 0.3, ...] # 2 } 说明 # 1 向量中所有浮点值的 JSON 列表。长度应与映射中的dims匹配。 2 #1 的简写形式。
knn_sparse_bool_vector 稀疏向量类型 # 假设您已经定义了一个映射，其中 my_vec 的类型为 knn_sparse_bool_vector。
POST /my-index/_doc { &amp;#34;my_vec&amp;#34;: { &amp;#34;true_indices&amp;#34;: [1, 3, 5, .</description></item><item><title>布尔字段类型</title><link>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/boolean/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/boolean/</guid><description>布尔字段类型 # 布尔字段类型接受 true 或 false 值，也支持字符串形式的 &amp;ldquo;true&amp;rdquo; 或 &amp;ldquo;false&amp;rdquo;。此外，还可以使用空字符串 &amp;quot;&amp;quot; 表示 false 值。
参考代码 # 创建一个由 a,b,c 三个布尔字段组成的 mapping
PUT testindex { &amp;quot;mappings&amp;quot; : { &amp;quot;properties&amp;quot; : { &amp;quot;a&amp;quot; : { &amp;quot;type&amp;quot; : &amp;quot;boolean&amp;quot; }, &amp;quot;b&amp;quot; : { &amp;quot;type&amp;quot; : &amp;quot;boolean&amp;quot; }, &amp;quot;c&amp;quot; : { &amp;quot;type&amp;quot; : &amp;quot;boolean&amp;quot; } } } } 索引由布尔值组成的文档
PUT testindex/_doc/1 { &amp;quot;a&amp;quot; : true, &amp;quot;b&amp;quot; : &amp;quot;true&amp;quot;, &amp;quot;c&amp;quot; : &amp;quot;&amp;quot; } 因此，字段 a 和 b 将被设置为 true，而字段 c 将被设置为 false。</description></item><item><title>数值字段类型</title><link>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/numeric-field/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/numeric-field/</guid><description>Numeric 字段类型 # 下表列出了 Easysearch 支持的所有数字字段类型。
字段数据类型 描述 byte 有符号的 8 位整数。最小值为 -128，最大值为 127。 double 双精度 64 位 IEEE 754 浮点数。最小值为 2^−1074，最大值为 (2 − 2^−52) · 2^1023。有效位数为 53，有效数字位为 15.95。 float 单精度 32 位 IEEE 754 浮点数。最小值为 2^−149，最大值为 (2 − 2^−23) · 2^127。有效位数为 24，有效数字位为 7.22。 half_float 半精度 16 位 IEEE 754 浮点数。最小值为 2^−24，最大值为 65504。有效位数为 11，有效数字位为 3.31。 integer 有符号的 32 位整数。最小值为 -2^31，最大值为 2^31 - 1。 long 有符号的 64 位整数。最小值为 -2^63，最大值为 2^63 - 1。 unsigned_long 无符号的 64 位整数。最小值为 0，最大值为 2^64 - 1。 short 有符号的 16 位整数。最小值为 -2^15，最大值为 2^15 - 1。 scaled_float 一个浮点值，它会被乘以双精度缩放因子并存储为长整型值。 Integer、long、float 和 double 字段类型都有对应的 范围字段类型。</description></item><item><title>范围字段类型</title><link>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/range-field-type/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/range-field-type/</guid><description>范围（Range）字段类型 # 以下表格列出了 Easysearch 支持的所有范围字段类型。
字段数据类型 描述 integer_range 整数值范围。 long_range 长整型值范围。 double_range 双精度浮点值范围。 float_range 浮点值范围。 ip_range IPv4 或 IPv6 地址范围，起始和结束地址可使用不同格式。 date_range 日期值范围，起始和结束日期可采用不同格式。内部以 64 位无符号整数存储，自纪元以来的毫秒数表示。 参考代码 # 创建一个有双精度浮点数范围字段和日期范围字段的映射
PUT testindex { &amp;quot;mappings&amp;quot; : { &amp;quot;properties&amp;quot; : { &amp;quot;gpa&amp;quot; : { &amp;quot;type&amp;quot; : &amp;quot;double_range&amp;quot; }, &amp;quot;graduation_date&amp;quot; : { &amp;quot;type&amp;quot; : &amp;quot;date_range&amp;quot;, &amp;quot;format&amp;quot; : &amp;quot;strict_year_month||strict_year_month_day&amp;quot; } } } } 索引一个包含这两个字段的文档</description></item><item><title>Wildcard 字段类型</title><link>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/wildcard/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.13.0/docs/references/mappings-and-field-types/field-types/wildcard/</guid><description>Wildcard 字段类型 # wildcard（通配符）字段是keyword（关键字）字段的一种变体，专为任意子字符串和正则表达式匹配而设计。
当您的内容由&amp;quot;字符串&amp;quot;而非&amp;quot;文本&amp;quot;组成时，应使用wildcard字段。示例包括非结构化日志行和计算机代码。
wildcard字段类型的索引方式与keyword字段类型不同。keyword字段将原始字段值写入索引，而wildcard字段类型则将字段值拆分为长度小于或等于3的子字符串，并将这些子字符串写入索引。例如，字符串test被拆分为t、te、tes、e、es和est这些子字符串。
在搜索时，将查询模式中所需的子字符串与索引进行匹配以生成候选文档，然后根据查询中的模式对这些文档进行过滤。例如，对于搜索词test，OpenSearch执行索引搜索tes AND est。如果搜索词包含少于三个字符，OpenSearch会使用长度为一或二的字符子字符串。对于每个匹配的文档，如果源值为test，则该文档将出现在结果中。这样可以排除误报值，如nikola tesla felt alternating current was best。
通常，精确匹配查询（如 term或 terms查询）在wildcard字段上的表现不如在keyword字段上有效， 而 wildcard、 prefix和 regexp查询在wildcard字段上表现更好。
示例 # 创建带有 wildcard 字段的映射：
PUT logs { &amp;#34;mappings&amp;#34; : { &amp;#34;properties&amp;#34; : { &amp;#34;log_line&amp;#34; : { &amp;#34;type&amp;#34; : &amp;#34;wildcard&amp;#34; } } } } 参数 # 以下表格列出了 wildcard 字段可用的所有参数。 `
参数 描述 doc_values 布尔值，指定该字段是否应存储在磁盘上，以便用于聚合、排序或脚本操作。默认值为 false。 ignore_above 长度超过此整数值的任何字符串都不会被索引。默认值为 2147483647。 normalizer 用于预处理索引和搜索值的标准化器。默认情况下，不进行标准化，使用原始值。您可以使用 lowercase 标准化器在该字段上执行不区分大小写的匹配。 null_value 用于替代 null 的值。必须与字段类型相同。如果未指定此参数，则当字段值为 null 时，该字段将被视为缺失。默认值为 null。</description></item></channel></rss>