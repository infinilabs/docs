<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>搜索操作 on INFINI Easysearch</title><link>/easysearch/v1.12.0/docs/references/search/</link><description>Recent content in 搜索操作 on INFINI Easysearch</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/v1.12.0/docs/references/search/index.xml" rel="self" type="application/rss+xml"/><item><title>词项查询</title><link>/easysearch/v1.12.0/docs/references/search/term/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.12.0/docs/references/search/term/</guid><description>词项查询 # Easysearch 在搜索数据时支持两种类型的查询：词项 (term) 查询和全文查询。
下表显示了它们之间的差异：
词项查询 全文检索 描述 term 查询回应与查询匹配的文档。 全文查询回应文档与查询的匹配程度。 分词 搜索 term 是不分词的。这意味着 term 查询按原样搜索您的 term。 搜索 term 由索引时用于文档指定字段的分词器进行分词。这意味着您的搜索词将经历与文档字段相同的分词过程。 相关性 Term 级查询只返回匹配的文档，而不根据相关性得分对其进行排序。他们仍然计算相关性得分，但该得分对于返回的所有文档都是相同的。 全文查询计算每个匹配的相关性得分，并按相关性的降序对结果进行排序。 应用场景 当您希望匹配数字、日期、 tag 等精确值，并且不需要按相关性对匹配项进行排序时，请使用术语级查询。 在考虑大小写和词干变体等因素后，使用全文查询来匹配文本字段并按相关性排序。 Easysearch 使用名为 Okapi BM25 的概率排名框架来计算相关性得分。要了解更多关于 Okapi BM25 的信息，请参阅 维基百科.
假设您在 Easysearch 集群中索引了莎士比亚全集。我们使用 term 查询在 text_entry 字段中搜索短语 “To be，or not be”：</description></item><item><title>全文查询</title><link>/easysearch/v1.12.0/docs/references/search/full-text/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.12.0/docs/references/search/full-text/</guid><description>全文查询 # 尽管可以使用 HTTP 请求参数执行简单搜索，但 Easysearch 查询域特定语言（DSL）允许您指定全部搜索选项。查询 DSL 使用 HTTP 请求主体。以这种方式指定的查询还有一个额外的优点，即其意图更加明确，并且更易于随时间调整。
此页面列出了所有全文查询类型和常用选项。考虑到选项的数量和微妙的行为，确保有用搜索结果的最佳方法是根据代表性索引测试不同的查询并验证输出。
匹配 # 创建一个 布尔查询 ，如果字段中存在搜索项，则返回结果。
查询的最基本形式仅提供字段（ title ）和对应的值（ wind ）:
GET _search { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;title&amp;#34;: &amp;#34;wind&amp;#34; } } } 采用 curl的方式:
curl --insecure -XGET -u &amp;#39;admin:admin&amp;#39; https://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/&amp;lt;index&amp;gt;/_search \ -H &amp;#34;content-type: application/json&amp;#34; \ -d &amp;#39;{ &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;title&amp;#34;: &amp;#34;wind&amp;#34; } } }&amp;#39; 查询接受以下选项。有关每个参数的描述，请参见 查询选项
GET _search { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;title&amp;#34;: { &amp;#34;query&amp;#34;: &amp;#34;wind&amp;#34;, &amp;#34;fuzziness&amp;#34;: &amp;#34;AUTO&amp;#34;, &amp;#34;fuzzy_transpositions&amp;#34;: true, &amp;#34;operator&amp;#34;: &amp;#34;or&amp;#34;, &amp;#34;minimum_should_match&amp;#34;: 1, &amp;#34;analyzer&amp;#34;: &amp;#34;standard&amp;#34;, &amp;#34;zero_terms_query&amp;#34;: &amp;#34;none&amp;#34;, &amp;#34;lenient&amp;#34;: false, &amp;#34;cutoff_frequency&amp;#34;: 0.</description></item><item><title>向量查询</title><link>/easysearch/v1.12.0/docs/references/search/knn_api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.12.0/docs/references/search/knn_api/</guid><description>向量查询 # 使用 kNN 检索 API 来进行向量查询。
先决条件 # 要运行 kNN 搜索，必须安装 knn 插件，参考 插件安装 。
创建 Mapping 和 Setting # 在索引向量之前，首先定义一个 Mapping，指定向量数据类型、索引模型和模型的参数。这决定了索引向量支持哪些查询。 并指定 index.knn 为 true ，这是为了启用近似相似度模型。
从1.11.1 版本开始，index.knn 已弃用，创建 knn 索引时，不再配置 index.knn 参数。
请求示例 # PUT /knn-test { &amp;quot;mappings&amp;quot;: { &amp;quot;properties&amp;quot;: { &amp;quot;my_vec&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;knn_dense_float_vector&amp;quot;, &amp;quot;knn&amp;quot;: { &amp;quot;dims&amp;quot;: 50, &amp;quot;model&amp;quot;: &amp;quot;lsh&amp;quot;, &amp;quot;similarity&amp;quot;: &amp;quot;cosine&amp;quot;, &amp;quot;L&amp;quot;: 99, &amp;quot;k&amp;quot;: 1 } } } } } 参数说明 # my_vec 存储向量的字段名称 knn_dense_float_vector 表示数据类型为密集型浮点向量.</description></item><item><title>布尔查询</title><link>/easysearch/v1.12.0/docs/references/search/bool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.12.0/docs/references/search/bool/</guid><description>布尔查询 # bool 查询允许您将多个搜索查询与布尔逻辑结合起来。您可以在查询之间使用布尔逻辑来缩小或扩大搜索结果。
bool 查询是一个查询组合器，因为它允许您通过组合几个简单的查询来构造高级查询。
在 bool 查询中使用以下子句（子查询）：
条件 说明 must 结果必须与此子句中的查询匹配。如果有多个查询，则每个查询都必须匹配。充当 and 运算符 must_not 结果中排除所有匹配项。充当 not 运算符 should 结果应该但不必与查询匹配。每个匹配的 should 子句都会增加相关性得分。作为选项，您可以要求一个或多个查询与 minimum_should_match 参数的值匹配（默认值为 1） filter 过滤器在应用查询之前减少数据集。筛选器子句中的查询是 yes-no 选项，其中如果文档与查询匹配，则将包含在结果中。筛选查询不会影响结果排序所依据的相关性分数。筛选查询的结果通常会被缓存，因此运行速度更快。使用筛选器查询根据精确匹配项、范围、日期、数字等筛选结果 bool 查询的结构如下:
GET _search { &amp;#34;query&amp;#34;: { &amp;#34;bool&amp;#34;: { &amp;#34;must&amp;#34;: [ {} ], &amp;#34;must_not&amp;#34;: [ {} ], &amp;#34;should&amp;#34;: [ {} ], &amp;#34;filter&amp;#34;: {} } } } 例如，假设您有一个 Easysearch 集群中的莎士比亚全集索引。您希望构造满足以下要求的单个查询：</description></item><item><title>查询模版</title><link>/easysearch/v1.12.0/docs/references/search/search-template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.12.0/docs/references/search/search-template/</guid><description>查询模版 # 您可以将全文查询转换为查询模版，以接受用户输入并将其动态插入到查询中。
例如，如果您使用 Easysearch 作为应用程序或网站的后端搜索引擎，则可以从搜索栏或表单字段接收用户查询，并将其作为参数传递到查询模版中。这样，创建 Easysearch 查询的语法就从最终用户那里抽象出来了。
当您编写代码将用户输入转换为 Easysearch 查询时，可以使用查询模版简化代码。如果需要将字段添加到搜索查询中，只需修改模板即可，而无需更改代码。
查询模版使用 Mustache 语言。有关所有语法选项的列表，请参阅 Mustache 手册。
创建查询模版 # 查询模版有两个组件：查询和参数。参数是放置在变量中的用户输入值。在 Mustache 符号中，变量用双括号表示。当在查询中遇到类似 {% raw %}{{var}}{% endraw %} 的变量时，Easysearch 会转到 params 部分，查找名为 var 的参数，并用指定的值替换它。
您可以编写应用程序代码，询问用户要搜索什么，然后在运行时将该值插入 params 对象中。
此命令定义了一个查询模版，用于按名称查找播放。查询中的 {% raw %}{{play_name}}{% endraw %} 被值 Henry IV 替换：
GET _search/template { &amp;#34;source&amp;#34;: { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;play_name&amp;#34;: &amp;#34;{% raw %}{{play_name}}{% endraw %}&amp;#34; } } }, &amp;#34;params&amp;#34;: { &amp;#34;play_name&amp;#34;: &amp;#34;Henry IV&amp;#34; } } 此模板在整个集群上运行搜索。</description></item><item><title>异步搜索</title><link>/easysearch/v1.12.0/docs/references/search/async_search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.12.0/docs/references/search/async_search/</guid><description>异步搜索 # 搜索大量数据可能会花费很长时间，尤其是当你在热节点或者多个远程集群中进行搜索时。
Easysearch 中的异步搜索允许你发送在后台运行的搜索请求。你可以监控这些搜索的进度，并且在部分结果可用时获取这些部分结果。在搜索完成之后，你可以保存结果以便日后查看。
先决条件 # Easysearch 从 1.11.1 版本开始，内置支持异步搜索。
REST API # 引入版本 1.11.0
要执行异步搜索，请向 /{index}/_async_search 发送请求，并在请求正文中包含您的查询：
POST test-index/_asynch_search 可以指定以下选项。
选项 描述 默认值 是否必填 wait_for_completion_timeout 计划等待结果的时间。在此时间内，您可以像在普通搜索中一样查看所获得的结果。您可以根据ID轮询剩余的结果。最大值为300秒。 1秒 否 keep_on_completion 搜索完成后，您是否希望将结果保存在集群中。您可以在稍后查看存储的结果。 false 否 keep_alive 结果在集群中保存的时间。例如，2d 表示结果在集群中存储48小时。保存的搜索结果在此时间段结束后或如果搜索被取消时将被删除。请注意，这包括查询执行时间。如果查询超过此时间，进程将自动取消该查询。 12小时 否 index 要搜索的索引名称。可以是单个名称、用逗号分隔的索引列表，或索引名称的通配符表达式。 集群中的所有索引 否 请求示例 # POST test-index/_async_search?wait_for_completion_timeout=1ms&amp;amp;keep_on_completion=true { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;张三&amp;#34; } } } 示例响应 # { &amp;#34;id&amp;#34;: &amp;#34;FmFqN0llTXlKVHF5cnV1NGdVNUlPancEMzMzMBRaOUNxU3BVQlRIdzczZmJfNnZtRQIyMA==&amp;#34;, &amp;#34;state&amp;#34;: &amp;#34;RUNNING&amp;#34;, &amp;#34;start_time_in_millis&amp;#34;: 1740714470020, &amp;#34;expiration_time_in_millis&amp;#34;: 1740800870020, &amp;#34;response&amp;#34;: { &amp;#34;took&amp;#34;: 0, &amp;#34;timed_out&amp;#34;: false, &amp;#34;num_reduce_phases&amp;#34;: 0, &amp;#34;_shards&amp;#34;: { &amp;#34;total&amp;#34;: 1, &amp;#34;successful&amp;#34;: 0, &amp;#34;skipped&amp;#34;: 0, &amp;#34;failed&amp;#34;: 0 }, &amp;#34;hits&amp;#34;: { &amp;#34;max_score&amp;#34;: null, &amp;#34;hits&amp;#34;: [] } } } 响应参数 # 选项 描述 id 异步搜索的ID。使用此ID来监控搜索进度、获取其部分结果和/或删除结果。如果异步搜索在超时期限内完成，响应中不包含ID，因为结果未存储在集群中。 state 指定搜索是仍在运行还是已经完成，以及结果是否在集群中持久保存。可能的状态有 RUNNING（运行中）、SUCCEEDED（成功）、FAILED（失败）、PERSISTING（正在持久化）、PERSIST_SUCCEEDED（持久化成功）、PERSIST_FAILED（持久化失败）、CLOSED（已关闭）和 STORE_RESIDENT（存储驻留）。 start_time_in_millis 开始时间，单位为毫秒。 expiration_time_in_millis 过期时间，单位为毫秒。 took 搜索运行的总时长。 response 实际的搜索响应。 num_reduce_phases 协调节点从分片响应批次中聚合结果的次数（默认值为5）。如果与上次检索到的结果相比，此数字增加，您可以预期搜索响应中将包含额外的结果。 total 执行搜索的分片总数。 successful 协调节点成功接收到的分片响应数量。 aggregations 分片到目前为止已完成的聚合部分结果。 获取部分结果 # 提交异步搜索请求后，您可以使用在异步搜索响应中看到的ID请求部分响应。</description></item><item><title>定点查询</title><link>/easysearch/v1.12.0/docs/references/search/pit_api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.12.0/docs/references/search/pit_api/</guid><description>定点查询 # 定点查询，也称为 Point in Time 搜索，具有与常规搜索相同的功能，不同之处在于 PIT 搜索作用于较旧的数据集，而常规搜索作用于实时数据集。PIT 搜索不绑定于特定查询，因此您可以在同一个冻结在时间点上的数据集上运行不同的查询。
您可以使用创建 PIT API 来创建 PIT。当您为一组索引创建 PIT 时，Easysearch 会锁定这些索引的一组段，使它们在时间上冻结。在底层，此 PIT 所需的资源不会被修改或删除。 如果作为 PIT 一部分的段被合并，Easysearch 会在 PIT 创建时通过 keep_alive 参数指定的时间段内保留这些段的副本。
创建 PIT 操作会返回一个 PIT ID，您可以使用该 ID 在冻结的数据集上运行多个查询。即使索引继续摄取数据并修改或删除文档，PIT 引用的数据自 PIT 创建以来不会发生变化。当您的查询包含 PIT ID 时， 您不需要将索引传递给搜索，因为它将使用该 PIT。使用 PIT ID 的搜索在多次运行时将产生完全相同的结果。
创建 PIT # 创建一个 PIT。查询参数 keep_alive 是必需的；它指定了保持 PIT 的时间长度。
端点 # POST /&amp;lt;target_indexes&amp;gt;/_pit?keep_alive=1h&amp;amp;routing=&amp;amp;expand_wildcards=&amp;amp;preference= 路径参数 # 参数 数据类型 描述 target_indexes 字符串 PIT 的目标索引名称。可以包含以逗号分隔的列表或通配符索引模式。 查询参数 # 参数 数据类型 描述 keep_alive 时间 保持 PIT 的时间长度。每次使用搜索 API 访问 PIT 时，PIT 的生命周期都会延长一段等于 keep_alive 参数的时间。必需。 preference 字符串 用于执行搜索的节点或分片。可选。默认为随机。 routing 字符串 指定将搜索请求路由到特定分片。可选。默认为文档的 _id。 expand_wildcards 字符串 可匹配通配符模式的索引类型。支持逗号分隔的值。有效值如下：</description></item></channel></rss>