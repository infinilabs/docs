<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>搜索操作 on INFINI Easysearch</title><link>/easysearch/v1.11.0/docs/references/search/</link><description>Recent content in 搜索操作 on INFINI Easysearch</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/v1.11.0/docs/references/search/index.xml" rel="self" type="application/rss+xml"/><item><title>词项查询</title><link>/easysearch/v1.11.0/docs/references/search/term/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.11.0/docs/references/search/term/</guid><description>词项查询 # Easysearch 在搜索数据时支持两种类型的查询：词项 (term) 查询和全文查询。
下表显示了它们之间的差异：
词项查询 全文检索 描述 term 查询回应与查询匹配的文档。 全文查询回应文档与查询的匹配程度。 分词 搜索 term 是不分词的。这意味着 term 查询按原样搜索您的 term。 搜索 term 由索引时用于文档指定字段的分词器进行分词。这意味着您的搜索词将经历与文档字段相同的分词过程。 相关性 Term 级查询只返回匹配的文档，而不根据相关性得分对其进行排序。他们仍然计算相关性得分，但该得分对于返回的所有文档都是相同的。 全文查询计算每个匹配的相关性得分，并按相关性的降序对结果进行排序。 应用场景 当您希望匹配数字、日期、 tag 等精确值，并且不需要按相关性对匹配项进行排序时，请使用术语级查询。 在考虑大小写和词干变体等因素后，使用全文查询来匹配文本字段并按相关性排序。 Easysearch 使用名为 Okapi BM25 的概率排名框架来计算相关性得分。要了解更多关于 Okapi BM25 的信息，请参阅 维基百科.
假设您在 Easysearch 集群中索引了莎士比亚全集。我们使用 term 查询在 text_entry 字段中搜索短语 “To be，or not be”：</description></item><item><title>全文查询</title><link>/easysearch/v1.11.0/docs/references/search/full-text/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.11.0/docs/references/search/full-text/</guid><description>全文查询 # 尽管可以使用 HTTP 请求参数执行简单搜索，但 Easysearch 查询域特定语言（DSL）允许您指定全部搜索选项。查询 DSL 使用 HTTP 请求主体。以这种方式指定的查询还有一个额外的优点，即其意图更加明确，并且更易于随时间调整。
此页面列出了所有全文查询类型和常用选项。考虑到选项的数量和微妙的行为，确保有用搜索结果的最佳方法是根据代表性索引测试不同的查询并验证输出。
匹配 # 创建一个 布尔查询 ，如果字段中存在搜索项，则返回结果。
查询的最基本形式仅提供字段（ title ）和对应的值（ wind ）:
GET _search { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;title&amp;#34;: &amp;#34;wind&amp;#34; } } } 采用 curl的方式:
curl --insecure -XGET -u &amp;#39;admin:admin&amp;#39; https://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/&amp;lt;index&amp;gt;/_search \ -H &amp;#34;content-type: application/json&amp;#34; \ -d &amp;#39;{ &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;title&amp;#34;: &amp;#34;wind&amp;#34; } } }&amp;#39; 查询接受以下选项。有关每个参数的描述，请参见 查询选项
GET _search { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;title&amp;#34;: { &amp;#34;query&amp;#34;: &amp;#34;wind&amp;#34;, &amp;#34;fuzziness&amp;#34;: &amp;#34;AUTO&amp;#34;, &amp;#34;fuzzy_transpositions&amp;#34;: true, &amp;#34;operator&amp;#34;: &amp;#34;or&amp;#34;, &amp;#34;minimum_should_match&amp;#34;: 1, &amp;#34;analyzer&amp;#34;: &amp;#34;standard&amp;#34;, &amp;#34;zero_terms_query&amp;#34;: &amp;#34;none&amp;#34;, &amp;#34;lenient&amp;#34;: false, &amp;#34;cutoff_frequency&amp;#34;: 0.</description></item><item><title>向量查询</title><link>/easysearch/v1.11.0/docs/references/search/knn_api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.11.0/docs/references/search/knn_api/</guid><description>向量查询 # 使用 kNN 检索 API 来进行向量查询。
先决条件 # 要运行 kNN 搜索，必须安装 knn 插件，参考 插件安装 。
创建 Mapping 和 Setting # 在索引向量之前，首先定义一个 Mapping，指定向量数据类型、索引模型和模型的参数。这决定了索引向量支持哪些查询。
并指定 index.knn 为 true ，这是为了启用近似相似度模型。
请求示例 # PUT /knn-test { &amp;quot;settings&amp;quot;: { &amp;quot;index.knn&amp;quot;: true }, &amp;quot;mappings&amp;quot;: { &amp;quot;properties&amp;quot;: { &amp;quot;my_vec&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;knn_dense_float_vector&amp;quot;, &amp;quot;knn&amp;quot;: { &amp;quot;dims&amp;quot;: 50, &amp;quot;model&amp;quot;: &amp;quot;lsh&amp;quot;, &amp;quot;similarity&amp;quot;: &amp;quot;cosine&amp;quot;, &amp;quot;L&amp;quot;: 99, &amp;quot;k&amp;quot;: 1 } } } } } 参数说明 # my_vec 存储向量的字段名称 knn_dense_float_vector 表示数据类型为密集型浮点向量.</description></item><item><title>布尔查询</title><link>/easysearch/v1.11.0/docs/references/search/bool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.11.0/docs/references/search/bool/</guid><description>布尔查询 # bool 查询允许您将多个搜索查询与布尔逻辑结合起来。您可以在查询之间使用布尔逻辑来缩小或扩大搜索结果。
bool 查询是一个查询组合器，因为它允许您通过组合几个简单的查询来构造高级查询。
在 bool 查询中使用以下子句（子查询）：
条件 说明 must 结果必须与此子句中的查询匹配。如果有多个查询，则每个查询都必须匹配。充当 and 运算符 must_not 结果中排除所有匹配项。充当 not 运算符 should 结果应该但不必与查询匹配。每个匹配的 should 子句都会增加相关性得分。作为选项，您可以要求一个或多个查询与 minimum_should_match 参数的值匹配（默认值为 1） filter 过滤器在应用查询之前减少数据集。筛选器子句中的查询是 yes-no 选项，其中如果文档与查询匹配，则将包含在结果中。筛选查询不会影响结果排序所依据的相关性分数。筛选查询的结果通常会被缓存，因此运行速度更快。使用筛选器查询根据精确匹配项、范围、日期、数字等筛选结果 bool 查询的结构如下:
GET _search { &amp;#34;query&amp;#34;: { &amp;#34;bool&amp;#34;: { &amp;#34;must&amp;#34;: [ {} ], &amp;#34;must_not&amp;#34;: [ {} ], &amp;#34;should&amp;#34;: [ {} ], &amp;#34;filter&amp;#34;: {} } } } 例如，假设您有一个 Easysearch 集群中的莎士比亚全集索引。您希望构造满足以下要求的单个查询：</description></item><item><title>查询模版</title><link>/easysearch/v1.11.0/docs/references/search/search-template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.11.0/docs/references/search/search-template/</guid><description>查询模版 # 您可以将全文查询转换为查询模版，以接受用户输入并将其动态插入到查询中。
例如，如果您使用 Easysearch 作为应用程序或网站的后端搜索引擎，则可以从搜索栏或表单字段接收用户查询，并将其作为参数传递到查询模版中。这样，创建 Easysearch 查询的语法就从最终用户那里抽象出来了。
当您编写代码将用户输入转换为 Easysearch 查询时，可以使用查询模版简化代码。如果需要将字段添加到搜索查询中，只需修改模板即可，而无需更改代码。
查询模版使用 Mustache 语言。有关所有语法选项的列表，请参阅 Mustache 手册。
创建查询模版 # 查询模版有两个组件：查询和参数。参数是放置在变量中的用户输入值。在 Mustache 符号中，变量用双括号表示。当在查询中遇到类似 {% raw %}{{var}}{% endraw %} 的变量时，Easysearch 会转到 params 部分，查找名为 var 的参数，并用指定的值替换它。
您可以编写应用程序代码，询问用户要搜索什么，然后在运行时将该值插入 params 对象中。
此命令定义了一个查询模版，用于按名称查找播放。查询中的 {% raw %}{{play_name}}{% endraw %} 被值 Henry IV 替换：
GET _search/template { &amp;#34;source&amp;#34;: { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;play_name&amp;#34;: &amp;#34;{% raw %}{{play_name}}{% endraw %}&amp;#34; } } }, &amp;#34;params&amp;#34;: { &amp;#34;play_name&amp;#34;: &amp;#34;Henry IV&amp;#34; } } 此模板在整个集群上运行搜索。</description></item></channel></rss>