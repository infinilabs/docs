<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>专业查询 on INFINI Easysearch</title><link>/easysearch/v1.15.2/docs/references/search/specialized/</link><description>Recent content in 专业查询 on INFINI Easysearch</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/v1.15.2/docs/references/search/specialized/index.xml" rel="self" type="application/rss+xml"/><item><title>包装器</title><link>/easysearch/v1.15.2/docs/references/search/specialized/wrapper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.2/docs/references/search/specialized/wrapper/</guid><description>包装器 # wrapper 查询允许您以 Base64 编码的 JSON 格式提交完整的查询。当查询必须嵌入到仅支持字符串值的上下文中时，它非常有用。
仅当需要管理系统约束时才使用此查询。为了提高可读性和可维护性，最好尽可能使用基于 JSON 的标准查询。
参考样例 # 使用以下映射创建名为 products 的索引：
PUT /products { &amp;quot;mappings&amp;quot;: { &amp;quot;properties&amp;quot;: { &amp;quot;title&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot; } } } } 索引示例文档：
POST /products/_bulk { &amp;quot;index&amp;quot;: { &amp;quot;_id&amp;quot;: 1 } } { &amp;quot;title&amp;quot;: &amp;quot;Wireless headphones with noise cancellation&amp;quot; } { &amp;quot;index&amp;quot;: { &amp;quot;_id&amp;quot;: 2 } } { &amp;quot;title&amp;quot;: &amp;quot;Bluetooth speaker&amp;quot; } { &amp;quot;index&amp;quot;: { &amp;quot;_id&amp;quot;: 3 } } { &amp;quot;title&amp;quot;: &amp;quot;Over-ear headphones with rich bass&amp;quot; } 以 Base64 格式编码以下查询：</description></item><item><title>排序功能</title><link>/easysearch/v1.15.2/docs/references/search/specialized/rank-feature/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.2/docs/references/search/specialized/rank-feature/</guid><description>排序功能 # 使用 rank_feature 查询根据文档中的数值（如相关性分数、人气或新鲜度）提升文档分数。如果你希望使用数值特征微调相关性排名，这种查询非常理想。与全文检索不同， rank_feature 仅关注数值信号；在复合查询（如 bool ）中与其他查询结合时效果最佳。
rank_feature 查询要求目标字段映射为 rank_feature 字段类型。这可以启用内部优化的评分，从而实现快速高效的提升。
分数影响取决于字段值以及可选的 saturation 、 log 或 sigmoid 函数。这些函数在查询时动态应用以计算最终文档分数；它们不会更改或存储文档中的任何值。
参数说明 # rank_feature 查询支持以下参数。
参数 数据类型 必需/可选 描述 field String 必需 一个 rank_feature 或 rank_features 字段，用于影响文档评分。 boost Float 可选 应用于评分的乘数。默认值为 1.0 。0 到 1 之间的值会降低评分；大于 1 的值会提高评分。 saturation Object 可选 对特征值应用饱和函数。随着值的增加，增益会增长，但在 pivot 之后会趋于平稳。如果没有提供其他函数，则使用此默认函数。一次只能使用 saturation 、 log 或 sigmoid 中的一个函数。 log Object 可选 使用基于字段值的对数评分函数。适用于大范围值的场景。一次只能使用 saturation 、 log 或 sigmoid 中的一个函数。 sigmoid Object 可选 对评分影响应用 S 形曲线，由 pivot 和 exponent 控制。一次只能使用 saturation 、 log 或 sigmoid 中的一个函数。 positive_score_impact Boolean 可选 当 false 时，较低值会获得更高的评分。适用于像价格这样的特征，其中较小值更好。作为映射的一部分定义。默认值为 true 。 参考样例 # 以下示例展示了如何定义和使用 rank_feature 字段来影响文档评分。</description></item><item><title>渗透查询</title><link>/easysearch/v1.15.2/docs/references/search/specialized/percolate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.2/docs/references/search/specialized/percolate/</guid><description>渗透查询 # 使用 percolate 渗透查询来查找与给定文档匹配的已存储查询。此操作与常规搜索相反：常规搜索是查找与查询匹配的文档，而 percolate 查询是查找与文档匹配的查询。 percolate 查询通常用于告警、通知和反向搜索用例。
在使用 percolate 查询时，请考虑以下几点：
您可以在线提供文档进行 percolate 操作，或者从索引中获取现有文档。 文档和存储的查询必须使用相同的字段名称和类型。 您可以结合使用透查、过滤和评分来构建复杂的匹配系统。 percolate 查询被视为昂贵的查询，并且只有在集群设置 search.allow_expensive_queries 被设置为 true （默认值）时才会运行。如果此设置是 false ， percolate 查询将被拒绝。 percolate 查询在各种实时匹配场景中非常有用。一些常见的用例包括：
电子商务通知：用户可以注册对产品的兴趣，例如，“有新的苹果笔记本电脑时通知我”。当新产品文档被索引时，系统会找到所有匹配保存的查询的用户并发送警报。 工作警报：求职者根据首选的工作标题或地点保存查询，新的职位发布将与这些查询匹配以触发警报。 安全和警报系统：Percolate 传入的日志或事件数据与保存的规则或异常模式进行匹配。 新闻筛选：将传入的文章与保存的主题配置文件进行匹配，以分类或提供相关内容。 工作过程 # 保存的查询存储在一个特殊的 percolator 字段类型中。 文档会与所有保存的查询进行比较。 每个匹配的查询都会返回其 _id 。 如果启用了高亮显示，匹配的文本片段也会被返回。 如果发送了多个文档， _percolator_document_slot 会显示匹配的文档。 参考样例 # 以下示例展示了如何存储 percolate 查询，并使用不同方法对它们进行测试。
首先，创建一个索引并配置其 mappings 字段类型以存储保存的查询：
PUT /my_percolator_index { &amp;quot;mappings&amp;quot;: { &amp;quot;properties&amp;quot;: { &amp;quot;query&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;percolator&amp;quot; }, &amp;quot;title&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot; } } } } 在 title 字段中添加一个匹配“apple”的查询：</description></item><item><title>类似查询</title><link>/easysearch/v1.15.2/docs/references/search/specialized/more-like-this/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.2/docs/references/search/specialized/more-like-this/</guid><description>类似查询 # 使用 more_like_this 查询查找与一个或多个给定文档相似的文档。这对于推荐引擎、内容发现以及识别数据集中的相关项目很有用。
more_like_this 查询分析输入文档或文本，并选择最能描述它们的词项。然后，它搜索包含这些重要词项的其他文档。
前提条件 # 在使用 more_like_this 查询之前，请确保您目标字段已索引，且其数据类型为 text 或 keyword 。
如果您在 like 部分引用文档，Easysearch 需要访问其内容。这通常通过 _source 字段完成，该字段默认启用。如果 _source 被禁用，您必须单独存储这些字段，或配置它们以保存 term_vector 数据。
在索引文档时保存 term_vector 信息可以大大加速 more_like_this 查询，因为引擎可以直接检索重要词项，而无需在查询时重新分析字段文本。
示例：无词向量优化 # 使用以下映射创建名为 articles-basic 的索引：
PUT /articles-basic { &amp;quot;mappings&amp;quot;: { &amp;quot;properties&amp;quot;: { &amp;quot;title&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot; }, &amp;quot;content&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot; } } } } 添加示例文档：
POST /articles-basic/_bulk { &amp;quot;index&amp;quot;: { &amp;quot;_id&amp;quot;: 1 }} { &amp;quot;title&amp;quot;: &amp;quot;Exploring the Sahara Desert&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Sand dunes and vast landscapes.</description></item><item><title>脚本分数查询</title><link>/easysearch/v1.15.2/docs/references/search/specialized/script-score/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.2/docs/references/search/specialized/script-score/</guid><description>脚本分数查询 # 使用 script_score 查询通过脚本自定义分数计算。对于昂贵的评分函数，您可以使用 script_score 查询仅计算已过滤的返回文档的分数。
参考样例 # 例如，以下请求创建一个包含一个文档的索引：
PUT testindex1/_doc/1 { &amp;quot;name&amp;quot;: &amp;quot;John Doe&amp;quot;, &amp;quot;multiplier&amp;quot;: 0.5 } 您可以使用 match 查询返回所有在 name 字段中包含 John 的文档：
GET testindex1/_search { &amp;quot;query&amp;quot;: { &amp;quot;match&amp;quot;: { &amp;quot;name&amp;quot;: &amp;quot;John&amp;quot; } } } 在返回内容中，文档 1 的得分为 0.2876821 ：
{ &amp;quot;took&amp;quot;: 7, &amp;quot;timed_out&amp;quot;: false, &amp;quot;_shards&amp;quot;: { &amp;quot;total&amp;quot;: 1, &amp;quot;successful&amp;quot;: 1, &amp;quot;skipped&amp;quot;: 0, &amp;quot;failed&amp;quot;: 0 }, &amp;quot;hits&amp;quot;: { &amp;quot;total&amp;quot;: { &amp;quot;value&amp;quot;: 1, &amp;quot;relation&amp;quot;: &amp;quot;eq&amp;quot; }, &amp;quot;max_score&amp;quot;: 0.</description></item><item><title>脚本查询</title><link>/easysearch/v1.15.2/docs/references/search/specialized/script/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.2/docs/references/search/specialized/script/</guid><description>脚本查询 # 使用 script 查询基于 Painless 脚本语言编写的自定义条件来过滤文档。此查询返回脚本评估结果为 true 的文档，从而实现无法使用标准查询表达的高级过滤逻辑。
script 查询计算成本高，应谨慎使用。仅在必要时使用，并确保 search.allow_expensive_queries 已启用（默认为 true ）。有关更多信息，请参阅昂贵查询。
参考样例 # 使用以下映射创建一个名为 products 的索引：
PUT /products { &amp;quot;mappings&amp;quot;: { &amp;quot;properties&amp;quot;: { &amp;quot;title&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot; }, &amp;quot;price&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;float&amp;quot; }, &amp;quot;rating&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;float&amp;quot; } } } } 使用以下请求索引示例文档：
POST /products/_bulk { &amp;quot;index&amp;quot;: { &amp;quot;_id&amp;quot;: 1 } } { &amp;quot;title&amp;quot;: &amp;quot;Wireless Earbuds&amp;quot;, &amp;quot;price&amp;quot;: 99.99, &amp;quot;rating&amp;quot;: 4.5 } { &amp;quot;index&amp;quot;: { &amp;quot;_id&amp;quot;: 2 } } { &amp;quot;title&amp;quot;: &amp;quot;Bluetooth Speaker&amp;quot;, &amp;quot;price&amp;quot;: 79.</description></item><item><title>距离特征查询</title><link>/easysearch/v1.15.2/docs/references/search/specialized/distance-feature/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.2/docs/references/search/specialized/distance-feature/</guid><description>距离特征查询 # 使用 distance_feature 查询来提升与特定日期或地理位置更近的文档的相关性。这可以帮助你在搜索结果中优先显示更近期的或附近的内容。例如，你可以为近期生产的产品分配更高的权重，或提升最接近用户指定位置的项目。
你可以将此查询应用于包含日期或位置数据的字段。它通常用于 bool 查询的 should 子句中，以改进相关性评分而不过滤掉结果。
配置索引 # 在使用 distance_feature 查询之前，请确保您的索引至少包含以下字段类型之一：date,date_nanos,geo_point
在此示例中，您将配置 opening_date 和 coordinates 字段，用于运行距离特征查询：
PUT /stores { &amp;quot;mappings&amp;quot;: { &amp;quot;properties&amp;quot;: { &amp;quot;opening_date&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;date&amp;quot; }, &amp;quot;coordinates&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;geo_point&amp;quot; } } } } 向索引中添加示例文档：
PUT /stores/_doc/1 { &amp;quot;store_name&amp;quot;: &amp;quot;Green Market&amp;quot;, &amp;quot;opening_date&amp;quot;: &amp;quot;2025-03-10&amp;quot;, &amp;quot;coordinates&amp;quot;: [74.00, 40.70] } PUT /stores/_doc/2 { &amp;quot;store_name&amp;quot;: &amp;quot;Fresh Foods&amp;quot;, &amp;quot;opening_date&amp;quot;: &amp;quot;2025-04-01&amp;quot;, &amp;quot;coordinates&amp;quot;: [73.98, 40.75] } PUT /stores/_doc/3 { &amp;quot;store_name&amp;quot;: &amp;quot;City Organics&amp;quot;, &amp;quot;opening_date&amp;quot;: &amp;quot;2021-04-20&amp;quot;, &amp;quot;coordinates&amp;quot;: [74.</description></item></channel></rss>