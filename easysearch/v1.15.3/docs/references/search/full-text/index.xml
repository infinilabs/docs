<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>全文检索 on INFINI Easysearch</title><link>/easysearch/v1.15.3/docs/references/search/full-text/</link><description>Recent content in 全文检索 on INFINI Easysearch</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/v1.15.3/docs/references/search/full-text/index.xml" rel="self" type="application/rss+xml"/><item><title>Intervals 查询</title><link>/easysearch/v1.15.3/docs/references/search/full-text/intervals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.3/docs/references/search/full-text/intervals/</guid><description>Intervals 查询 # 间隔查询根据匹配词的邻近度和顺序来匹配文档。它将一组匹配规则应用于指定字段中的词。该查询生成跨越文本中词的最小间隔序列。你可以组合间隔并按父源进行过滤。
考虑一个包含以下文档的索引：
PUT testindex/_doc/1 { &amp;quot;title&amp;quot;: &amp;quot;key-value pairs are efficiently stored in a hash table&amp;quot; } PUT /testindex/_doc/2 { &amp;quot;title&amp;quot;: &amp;quot;store key-value pairs in a hash map&amp;quot; } 例如，以下查询搜索包含短语 key-value pairs （词之间没有间隔）后跟 hash table 或 hash map 的文档：
GET /testindex/_search { &amp;quot;query&amp;quot;: { &amp;quot;intervals&amp;quot;: { &amp;quot;title&amp;quot;: { &amp;quot;all_of&amp;quot;: { &amp;quot;ordered&amp;quot;: true, &amp;quot;intervals&amp;quot;: [ { &amp;quot;match&amp;quot;: { &amp;quot;query&amp;quot;: &amp;quot;key-value pairs&amp;quot;, &amp;quot;max_gaps&amp;quot;: 0, &amp;quot;ordered&amp;quot;: true } }, { &amp;quot;any_of&amp;quot;: { &amp;quot;intervals&amp;quot;: [ { &amp;quot;match&amp;quot;: { &amp;quot;query&amp;quot;: &amp;quot;hash table&amp;quot; } }, { &amp;quot;match&amp;quot;: { &amp;quot;query&amp;quot;: &amp;quot;hash map&amp;quot; } } ] } } ] } } } } } 该查询返回两个文档：</description></item><item><title>匹配布尔前缀查询</title><link>/easysearch/v1.15.3/docs/references/search/full-text/match-bool-prefix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.3/docs/references/search/full-text/match-bool-prefix/</guid><description>匹配布尔前缀查询 # match_bool_prefix 匹配布尔前缀查询分析提供的搜索字符串，并从字符串的词项中创建一个布尔查询。它将除最后一个词项外的每个词项作为完整单词进行匹配。最后一个词项用作前缀。 match_bool_prefix 查询返回包含完整单词词项或以前缀词项开头的词项的文档，顺序不限。
以下示例展示了一个基本的 match_bool_prefix 查询：
GET _search { &amp;quot;query&amp;quot;: { &amp;quot;match_bool_prefix&amp;quot;: { &amp;quot;title&amp;quot;: &amp;quot;the wind&amp;quot; } } } 要传递额外参数，您可以使用扩展语法：
GET _search { &amp;quot;query&amp;quot;: { &amp;quot;match_bool_prefix&amp;quot;: { &amp;quot;title&amp;quot;: { &amp;quot;query&amp;quot;: &amp;quot;the wind&amp;quot;, &amp;quot;analyzer&amp;quot;: &amp;quot;stop&amp;quot; } } } } 参数说明 # 例如，考虑一个包含以下文档的索引：
PUT testindex/_doc/1 { &amp;quot;title&amp;quot;: &amp;quot;The wind rises&amp;quot; } PUT testindex/_doc/2 { &amp;quot;title&amp;quot;: &amp;quot;Gone with the wind&amp;quot; } 以下 match_bool_prefix 查询会搜索整个词 rises 以及以 wi 开头的词，顺序不限：</description></item><item><title>匹配查询</title><link>/easysearch/v1.15.3/docs/references/search/full-text/match/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.3/docs/references/search/full-text/match/</guid><description>匹配查询 # 使用 match 查询在特定文档字段上执行全文搜索。如果你在 text 字段上运行 match 查询， match 查询会分析提供的搜索字符串，并返回匹配字符串中任意词的文档。如果你在精确值字段上运行 match 查询，它会返回匹配精确值的文档。搜索精确值字段的推荐方式是使用过滤（ filter ）查询，因为与普通查询不同，过滤（ filter ）查询会被缓存。
以下示例展示了在 title 中对 wind 的基本 match 查询：
GET _search { &amp;quot;query&amp;quot;: { &amp;quot;match&amp;quot;: { &amp;quot;title&amp;quot;: &amp;quot;wind&amp;quot; } } } 通过传递其他参数，您可以使用扩展语法：
GET _search { &amp;quot;query&amp;quot;: { &amp;quot;match&amp;quot;: { &amp;quot;title&amp;quot;: { &amp;quot;query&amp;quot;: &amp;quot;wind&amp;quot;, &amp;quot;analyzer&amp;quot;: &amp;quot;stop&amp;quot; } } } } 参考样例 # 在以下示例中，您将使用包含以下文档的索引：
PUT testindex/_doc/1 { &amp;quot;title&amp;quot;: &amp;quot;Let the wind rise&amp;quot; } PUT testindex/_doc/2 { &amp;quot;title&amp;quot;: &amp;quot;Gone with the wind&amp;quot; } PUT testindex/_doc/3 { &amp;quot;title&amp;quot;: &amp;quot;Rise is gone&amp;quot; } 运算符 # 如果对 text 字段运行 match 查询，文本将使用 analyzer 参数中指定的分词器进行分析。然后，将生成的词元组合为使用 operator 参数中指定的操作符构成的布尔查询。默认操作符是 OR ，因此查询 wind rise 被改为 wind OR rise 。在这个示例中，此查询返回文档 1–3，因为每个文档都有一个与查询匹配的词元。要指定 and 操作符，请使用以下查询：</description></item><item><title>匹配短语前缀查询</title><link>/easysearch/v1.15.3/docs/references/search/full-text/match-phrase-prefix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.3/docs/references/search/full-text/match-phrase-prefix/</guid><description>匹配短语前缀查询 # 使用 match_phrase_prefix 查询来指定要匹配的短语。包含您指定短语的文档将被返回。短语中的最后一个部分词被解释为前缀，因此任何包含以该短语和最后一个词的前缀开头的短语的文档都将被返回。
与匹配短语类似，但会从查询字符串中的最后一个词创建一个前缀查询。
对于 match_phrase_prefix 和 match_bool_prefix 查询之间的差异，请参阅 match_bool_prefix 和 match_phrase_prefix 查询。
以下示例展示了一个基本的 match_phrase_prefix 查询：
GET _search { &amp;quot;query&amp;quot;: { &amp;quot;match_phrase_prefix&amp;quot;: { &amp;quot;title&amp;quot;: &amp;quot;the wind&amp;quot; } } } 要传递附加参数，您可以使用扩展语法：
GET _search { &amp;quot;query&amp;quot;: { &amp;quot;match_phrase_prefix&amp;quot;: { &amp;quot;title&amp;quot;: { &amp;quot;query&amp;quot;: &amp;quot;the wind&amp;quot;, &amp;quot;analyzer&amp;quot;: &amp;quot;stop&amp;quot; } } } } 参考用例 # 例如，创建一个包含以下文档的索引：
PUT testindex/_doc/1 { &amp;quot;title&amp;quot;: &amp;quot;The wind rises&amp;quot; } PUT testindex/_doc/2 { &amp;quot;title&amp;quot;: &amp;quot;Gone with the wind&amp;quot; } 以下 match_phrase_prefix 查询会搜索完整单词 wind ，后跟一个以 ri 开头的单词：</description></item><item><title>匹配短语查询</title><link>/easysearch/v1.15.3/docs/references/search/full-text/match-phrase/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.3/docs/references/search/full-text/match-phrase/</guid><description>匹配短语查询 # 使用 match_phrase 查询来匹配包含指定顺序中确切的短语的文档。您可以通过提供 slop 参数来增加短语匹配的灵活性。
match_phrase 查询创建一个匹配词项序列的短语查询。
以下示例展示了一个基本的 match_phrase 查询：
GET _search { &amp;quot;query&amp;quot;: { &amp;quot;match_phrase&amp;quot;: { &amp;quot;title&amp;quot;: &amp;quot;the wind&amp;quot; } } } 要传递额外的参数，您可以使用扩展语法：
GET _search { &amp;quot;query&amp;quot;: { &amp;quot;match_phrase&amp;quot;: { &amp;quot;title&amp;quot;: { &amp;quot;query&amp;quot;: &amp;quot;the wind&amp;quot;, &amp;quot;analyzer&amp;quot;: &amp;quot;stop&amp;quot; } } } } 参考用例 # 例如，创建一个包含以下文档的索引：
PUT testindex/_doc/1 { &amp;quot;title&amp;quot;: &amp;quot;The wind rises&amp;quot; } PUT testindex/_doc/1 { &amp;quot;title&amp;quot;: &amp;quot;The wind rises&amp;quot; } 以下 match_phrase 查询搜索短语 wind rises ，其中单词 wind 后面跟着单词 rises ：</description></item><item><title>多字段查询</title><link>/easysearch/v1.15.3/docs/references/search/full-text/multi-match/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.3/docs/references/search/full-text/multi-match/</guid><description>多字段查询 # 多字段查询与匹配查询类似。您可以使用 multi_match 查询来搜索多个字段。
^ 会“提升”某些字段的权重。提升是乘数，用于使一个字段中的匹配比其他字段中的匹配更重要。在以下示例中，title字段中匹配 “wind” 的权重比 plot 字段中匹配的权重高 _score 四倍：
GET _search { &amp;quot;query&amp;quot;: { &amp;quot;multi_match&amp;quot;: { &amp;quot;query&amp;quot;: &amp;quot;wind&amp;quot;, &amp;quot;fields&amp;quot;: [&amp;quot;title^4&amp;quot;, &amp;quot;plot&amp;quot;] } } } 结果是，像《The Wind Rises》和《Gone with the Wind》这样的电影出现在搜索结果的顶部附近，而像《Twister》这样的电影，其剧情简介中可能包含“wind”字，则出现在底部附近。
您可以在字段名中使用通配符。例如，以下查询将搜索 speaker 字段以及所有以 play_ 开头的字段，例如 play_name 或 play_title ：
GET _search { &amp;quot;query&amp;quot;: { &amp;quot;multi_match&amp;quot;: { &amp;quot;query&amp;quot;: &amp;quot;hamlet&amp;quot;, &amp;quot;fields&amp;quot;: [&amp;quot;speaker&amp;quot;, &amp;quot;play_*&amp;quot;] } } } 如果您不提供 fields 参数， multi_match 查询将搜索 index.query. Default_field 设置中指定的字段，该设置默认为 * 。默认行为是提取映射中所有适用于词级查询的字段，过滤元数据字段，并将所有提取的字段组合起来构建查询。
查询中的子句最大数量由 indices.</description></item><item><title>字符串查询</title><link>/easysearch/v1.15.3/docs/references/search/full-text/query-string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.3/docs/references/search/full-text/query-string/</guid><description>字符串查询 # 一个 query_string 查询根据查询字符串语法解析查询字符串。它提供了创建强大而简洁的查询的功能，这些查询可以包含通配符并搜索多个字段。
使用 query_string 查询的搜索不会返回嵌套文档。要搜索嵌套字段，请使用 nested 查询。
查询字符串查询具有严格的语法，在语法无效时会返回错误。因此，它不适合搜索框应用程序。对于不太严格的替代方案，可以考虑使用 simple_query_string 查询。如果你不需要查询语法支持，使用 match 查询。
参考样例 # 运行以下搜索时， query_string 查询会将 (new york city) OR (big apple) 拆分为两部分： new york city 和 big apple 。 content 字段的分词器随后会分别将每个部分转换为标记，然后返回匹配的文档。由于查询语法不使用空格作为运算符，因此 new york city 会按原样传递给分词器。
GET /_search { &amp;quot;query&amp;quot;: { &amp;quot;query_string&amp;quot;: { &amp;quot;query&amp;quot;: &amp;quot;(new york city) OR (big apple)&amp;quot;, &amp;quot;default_field&amp;quot;: &amp;quot;content&amp;quot; } } } 参数说明 # 下表列出了 query_string 查询支持的参数。除 query 外，所有参数都是可选的。</description></item><item><title>简单字符串查询</title><link>/easysearch/v1.15.3/docs/references/search/full-text/simple-query-string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v1.15.3/docs/references/search/full-text/simple-query-string/</guid><description>简单字符串查询 # 使用 simple_query_string 类型在查询字符串中直接指定由正则表达式分隔的多个参数。简单查询字符串的语法比查询字符串宽松，因为它会丢弃字符串中的任何无效部分，并且不会因无效语法而返回错误。
此查询使用简单语法根据特殊运算符解析查询字符串，并将字符串拆分为词项。解析后，查询会独立分析每个词项，然后返回匹配的文档。
以下查询对 title 字段执行模糊搜索：
GET _search { &amp;quot;query&amp;quot;: { &amp;quot;simple_query_string&amp;quot;: { &amp;quot;query&amp;quot;: &amp;quot;\&amp;quot;rises wind the\&amp;quot;~4 | *ising~2&amp;quot;, &amp;quot;fields&amp;quot;: [&amp;quot;title&amp;quot;] } } } 简单字符串语法 # 查询字符串由词项和运算符组成。词项是一个单词（例如，在查询 wind rises 中，词项是 wind 和 rises ）。如果多个词项被引号包围，它们被视为一个短语，其中单词按出现的顺序匹配（例如， &amp;ldquo;wind rises&amp;rdquo; ）。 + 、 | 和 - 等运算符指定用于解释查询字符串中文本的布尔逻辑。
操作符 # 简单查询字符串语法支持以下运算符。
操作符 描述 + 作为 AND 操作符。 | 作为 OR 操作符。 * 在词尾使用时，表示前缀查询。 &amp;quot; 将多个词括起来组成短语（例如， &amp;quot;wind rises&amp;quot; ）。 (, ) 为优先级包装子句（例如， wind + (rises | rising) ）。 ~n 在词后面使用时（例如，wnid~3 ），设置 fuzziness 。在短语后面使用时，设置 slop 。 - 否定该词。 所有前面的操作符都是保留字符。要将其作为原始字符而不是操作符引用，用反斜杠转义它们中的任何一个。在发送 JSON 请求时，使用 \\ 转义保留字符（因为反斜杠字符本身也是保留的，你必须用另一个反斜杠转义反斜杠）。</description></item></channel></rss>