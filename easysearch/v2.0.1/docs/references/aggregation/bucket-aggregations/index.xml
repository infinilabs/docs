<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>分组聚合 on INFINI Easysearch</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/</link><description>Recent content in 分组聚合 on INFINI Easysearch</description><generator>Hugo -- gohugo.io</generator><atom:link href="/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/index.xml" rel="self" type="application/rss+xml"/><item><title>IP 范围聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/ip-range/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/ip-range/</guid><description>IP 范围聚合 # ip_range IP 范围聚合用于 IP 地址。它适用于 ip 类型字段。您可以在 CIDR 表示法中定义 IP 范围和掩码。
GET sample_data_logs/_search { &amp;quot;size&amp;quot;: 0, &amp;quot;aggs&amp;quot;: { &amp;quot;access&amp;quot;: { &amp;quot;ip_range&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;ip&amp;quot;, &amp;quot;ranges&amp;quot;: [ { &amp;quot;from&amp;quot;: &amp;quot;1.0.0.0&amp;quot;, &amp;quot;to&amp;quot;: &amp;quot;126.158.155.183&amp;quot; }, { &amp;quot;mask&amp;quot;: &amp;quot;1.0.0.0/8&amp;quot; } ] } } } } 返回内容
... &amp;quot;aggregations&amp;quot; : { &amp;quot;access&amp;quot; : { &amp;quot;buckets&amp;quot; : [ { &amp;quot;key&amp;quot; : &amp;quot;1.0.0.0/8&amp;quot;, &amp;quot;from&amp;quot; : &amp;quot;1.0.0.0&amp;quot;, &amp;quot;to&amp;quot; : &amp;quot;2.0.0.0&amp;quot;, &amp;quot;doc_count&amp;quot; : 98 }, { &amp;quot;key&amp;quot; : &amp;quot;1.</description></item><item><title>全局聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/global/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/global/</guid><description>全局聚合 # global 全局聚合让你能跳出过滤聚合的聚合上下文。即使你包含了一个缩小文档集的过滤查询， global 聚合仍然对所有文档进行聚合，就好像过滤查询不存在一样。它忽略 filter 聚合，并隐式地假设 match_all 查询。
以下示例返回索引中所有文档的 taxful_total_price 字段的 avg 值：
GET sample_data_ecommerce/_search { &amp;quot;size&amp;quot;: 0, &amp;quot;query&amp;quot;: { &amp;quot;range&amp;quot;: { &amp;quot;taxful_total_price&amp;quot;: { &amp;quot;lte&amp;quot;: 50 } } }, &amp;quot;aggs&amp;quot;: { &amp;quot;total_avg_amount&amp;quot;: { &amp;quot;global&amp;quot;: {}, &amp;quot;aggs&amp;quot;: { &amp;quot;avg_price&amp;quot;: { &amp;quot;avg&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;taxful_total_price&amp;quot; } } } } } } 返回内容
... &amp;quot;aggregations&amp;quot; : { &amp;quot;total_avg_amount&amp;quot; : { &amp;quot;doc_count&amp;quot; : 4675, &amp;quot;avg_price&amp;quot; : { &amp;quot;value&amp;quot; : 75.05542864304813 } } } } 你可以看到， taxful_total_price 字段的平均值是 75.</description></item><item><title>分组聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/terms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/terms/</guid><description>分组聚合 # terms 聚合会动态为字段中的每个唯一词条创建一个分组。
以下示例使用 terms 聚合来查找网络日志数据中每个响应代码的文档数量：
GET sample_data_logs/_search { &amp;quot;size&amp;quot;: 0, &amp;quot;aggs&amp;quot;: { &amp;quot;response_codes&amp;quot;: { &amp;quot;terms&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;response.keyword&amp;quot;, &amp;quot;size&amp;quot;: 10 } } } } 返回内容
... &amp;quot;aggregations&amp;quot; : { &amp;quot;response_codes&amp;quot; : { &amp;quot;doc_count_error_upper_bound&amp;quot; : 0, &amp;quot;sum_other_doc_count&amp;quot; : 0, &amp;quot;buckets&amp;quot; : [ { &amp;quot;key&amp;quot; : &amp;quot;200&amp;quot;, &amp;quot;doc_count&amp;quot; : 12832 }, { &amp;quot;key&amp;quot; : &amp;quot;404&amp;quot;, &amp;quot;doc_count&amp;quot; : 801 }, { &amp;quot;key&amp;quot; : &amp;quot;503&amp;quot;, &amp;quot;doc_count&amp;quot; : 441 } ] } } } 值以 key 键返回。 doc_count 指定每个分组中的文档数量。默认情况下，分组按 doc-count 的降序排列。</description></item><item><title>反向嵌套聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/reverse-nested/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/reverse-nested/</guid><description>反向嵌套聚合 # 您可以将嵌套文档中的值聚合到其父文档中；这种聚合称为 reverse_nested 。您可以使用 reverse_nested 在按嵌套对象中的字段分组后，聚合父文档中的字段。 reverse_nested 聚合将“连接回”根页面，并为您的各种变体获取 load_time 。
reverse_nested 聚合是嵌套聚合中的一个子聚合。它接受一个名为 path 的选项。此选项定义 Easysearch 在计算聚合时在文档层次结构中向后退多少步。
GET logs/_search { &amp;quot;query&amp;quot;: { &amp;quot;match&amp;quot;: { &amp;quot;response&amp;quot;: &amp;quot;200&amp;quot; } }, &amp;quot;aggs&amp;quot;: { &amp;quot;pages&amp;quot;: { &amp;quot;nested&amp;quot;: { &amp;quot;path&amp;quot;: &amp;quot;pages&amp;quot; }, &amp;quot;aggs&amp;quot;: { &amp;quot;top_pages_per_load_time&amp;quot;: { &amp;quot;terms&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;pages.load_time&amp;quot; }, &amp;quot;aggs&amp;quot;: { &amp;quot;comment_to_logs&amp;quot;: { &amp;quot;reverse_nested&amp;quot;: {}, &amp;quot;aggs&amp;quot;: { &amp;quot;min_load_time&amp;quot;: { &amp;quot;min&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;pages.load_time&amp;quot; } } } } } } } } } } 返回内容</description></item><item><title>地理距离聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/geo-distance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/geo-distance/</guid><description>地理距离聚合 # geo_distance 地理距离聚合根据与一个起始 geo_point 字段距离将文档分组到同心圆中。它与 range 聚合相同，只是它作用于地理位置。
例如，你可以使用 geo_distance 聚合来查找你 1 公里范围内的所有披萨店。搜索结果仅限于你指定的 1 公里半径范围内，但你还可以添加另一个在 2 公里范围内找到的结果。
您只能对映射为 geo_point 的字段使用 geo_distance 聚合。
点是一个单一的地理坐标，例如您智能手机显示的当前位置。在 OpenSearch 中，点表示如下：
{ &amp;quot;location&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;point&amp;quot;, &amp;quot;coordinates&amp;quot;: { &amp;quot;lat&amp;quot;: 83.76, &amp;quot;lon&amp;quot;: -81.2 } } } 您还可以将纬度和经度指定为数组 [-81.20, 83.76] 或字符串 &amp;quot;83.76, -81.20&amp;quot;
此表列出了 geo_distance 聚合的相关字段：
字段 必需/可选 描述 field 必需 指定您要处理的地理点字段。 origin 必需 指定用于计算距离的地理点。 ranges 必需 指定一组范围，根据文档与目标点的距离收集文档。 unit 可选 定义 ranges 数组中使用的单位。 unit 默认为 m （米），但你可以切换到其他单位，如 km （千米）、 mi （英里）、 in （英寸）、 yd （码）、 cm （厘米）和 mm （毫米）。 distance_type 可选 指定 OpenSearch 如何计算距离。默认值为 sloppy_arc （更快但精度较低），也可以设置为 arc （较慢但最精确）或 plane （最快但精度最低）。由于误差范围较大，仅适用于小地理区域使用 plane 。 语法如下：</description></item><item><title>复合聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/composite/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/composite/</guid><description>复合聚合 # composite 复合聚合基于一个或多个文档字段或源创建分组。 composite 聚合为每个单独源值的组合创建一个分组。默认情况下，如果一个或多个字段中缺少值，则这些组合会从结果中省略。
每个源有四种类型的聚合之一：
terms 类型按唯一（通常是 String ）值分组。 histogram 类型按指定宽度数值分组。 date_histogram 类型按指定宽度的日期或时间范围分组。 geotile_grid 类型按指定分辨率将地理点分组到网格中。 composite 聚合通过将其源键组合到分组中来工作。生成的分组是有序的，跨源(Across)和源内部(Within)都是：
Across：分组按聚合请求中源的顺序嵌套。 Within:每个源中值的顺序决定了该源的分组顺序。排序方式根据源类型适当选择，可以是字母顺序、数字顺序、日期时间顺序或地理切片顺序。 考虑一下来自马拉松参与者索引的这些字段：
{... &amp;quot;city&amp;quot;: &amp;quot;Albuquerque&amp;quot;, &amp;quot;place&amp;quot;: &amp;quot;Bronze&amp;quot; ...} {... &amp;quot;city&amp;quot;: &amp;quot;Boston&amp;quot;, ...} {... &amp;quot;city&amp;quot;: &amp;quot;Chicago&amp;quot;, &amp;quot;place&amp;quot;: &amp;quot;Bronze&amp;quot; ...} {... &amp;quot;city&amp;quot;: &amp;quot;Albuquerque&amp;quot;, &amp;quot;place&amp;quot;: &amp;quot;Gold&amp;quot; ...} {... &amp;quot;city&amp;quot;: &amp;quot;Chicago&amp;quot;, &amp;quot;place&amp;quot;: &amp;quot;Silver&amp;quot; ...} {... &amp;quot;city&amp;quot;: &amp;quot;Boston&amp;quot;, &amp;quot;place&amp;quot;: &amp;quot;Bronze&amp;quot; ...} {... &amp;quot;city&amp;quot;: &amp;quot;Chicago&amp;quot;, &amp;quot;place&amp;quot;: &amp;quot;Gold&amp;quot; ...} 假设请求指定源如下：
... &amp;quot;sources&amp;quot;: [ { &amp;quot;marathon_city&amp;quot;: { &amp;quot;terms&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;city&amp;quot; }}}, { &amp;quot;participant_medal&amp;quot;: { &amp;quot;terms&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;place&amp;quot; }}} ], .</description></item><item><title>多样化采样聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/diversified-sampler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/diversified-sampler/</guid><description>多样化采样聚合 # diversified_sampler 多样化采样聚合允许你通过去重包含相同 field 的文档来减少样本池分布的偏差。它通过使用 max_docs_per_value 和 field 设置来实现，这些设置限制了在分片上收集的 field 的最大文档数。 max_docs_per_value 设置是一个可选参数，用于确定每个 field 将返回的最大文档数。此设置的默认值为 1 。
与 sampler 聚合类似，你可以使用 shard_size 设置来控制在任何单个分片上收集的最大文档数，如下面的示例所示：
GET sample_data_logs/_search { &amp;quot;size&amp;quot;: 0, &amp;quot;aggs&amp;quot;: { &amp;quot;sample&amp;quot;: { &amp;quot;diversified_sampler&amp;quot;: { &amp;quot;shard_size&amp;quot;: 1000, &amp;quot;field&amp;quot;: &amp;quot;response.keyword&amp;quot; }, &amp;quot;aggs&amp;quot;: { &amp;quot;terms&amp;quot;: { &amp;quot;terms&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;agent.keyword&amp;quot; } } } } } } 返回内容
... &amp;quot;aggregations&amp;quot; : { &amp;quot;sample&amp;quot; : { &amp;quot;doc_count&amp;quot; : 3, &amp;quot;terms&amp;quot; : { &amp;quot;doc_count_error_upper_bound&amp;quot; : 0, &amp;quot;sum_other_doc_count&amp;quot; : 0, &amp;quot;buckets&amp;quot; : [ { &amp;quot;key&amp;quot; : &amp;quot;Mozilla/5.</description></item><item><title>多过滤聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/filters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/filters/</guid><description>多过滤聚合 # filters 聚合与 filter 聚合相同，但它允许你使用多个过滤器聚合。 filter 聚合结果为一个分组，而 filters 聚合会返回多个分组，每个定义的过滤器对应一个分组。
要为所有未匹配任何过滤器查询的文档创建一个分组，将 other_bucket 属性设置为 true ：
GET sample_data_logs/_search { &amp;quot;size&amp;quot;: 0, &amp;quot;aggs&amp;quot;: { &amp;quot;200_os&amp;quot;: { &amp;quot;filters&amp;quot;: { &amp;quot;other_bucket&amp;quot;: true, &amp;quot;filters&amp;quot;: [ { &amp;quot;term&amp;quot;: { &amp;quot;response.keyword&amp;quot;: &amp;quot;200&amp;quot; } }, { &amp;quot;term&amp;quot;: { &amp;quot;machine.os.keyword&amp;quot;: &amp;quot;osx&amp;quot; } } ] }, &amp;quot;aggs&amp;quot;: { &amp;quot;avg_amount&amp;quot;: { &amp;quot;avg&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;bytes&amp;quot; } } } } } } 返回内容
... &amp;quot;aggregations&amp;quot; : { &amp;quot;200_os&amp;quot; : { &amp;quot;buckets&amp;quot; : [ { &amp;quot;doc_count&amp;quot; : 12832, &amp;quot;avg_amount&amp;quot; : { &amp;quot;value&amp;quot; : 5897.</description></item><item><title>子关联聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/children/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/children/</guid><description>子关联聚合 # children 子关联聚合是一种存储分组聚合，它根据索引中定义的父子关系创建包含子文档的单个存储分组。
子关联聚合与 join 字段类型配合使用，以聚合与父文档关联的子文档。
子关联聚合标识与特定子关系名称匹配的子文档，而 parent 父聚合标识具有匹配子文档的父文档。这两个聚合都采用子关系名称作为输入。
参数说明 # children 聚合采用以下参数。
参数 必需/可选 数据类型 描述 type 必填 String join 字段中的子类型的名称。这标识了要使用的父子关系。 参考样例 # 以下示例构建一个包含三名员工的小型公司数据库。每个员工记录都与父部门记录具有子联接关系。
首先，创建一个 company 索引，其中包含一个将部门（父级）映射到员工（子级）的联接字段：
PUT /company { &amp;quot;mappings&amp;quot;: { &amp;quot;properties&amp;quot;: { &amp;quot;join_field&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;join&amp;quot;, &amp;quot;relations&amp;quot;: { &amp;quot;department&amp;quot;: &amp;quot;employee&amp;quot; } }, &amp;quot;department_name&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;keyword&amp;quot; }, &amp;quot;employee_name&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;keyword&amp;quot; }, &amp;quot;salary&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;double&amp;quot; }, &amp;quot;hire_date&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;date&amp;quot; } } } } 接下来，使用三个部门和三名员工填充数据。下表显示了父子分配。</description></item><item><title>嵌套聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/nested/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/nested/</guid><description>嵌套聚合 # nested 聚合让你能够对嵌套对象内的字段进行聚合。 nested 类型是对象数据类型的特殊版本，它允许对象数组以独立于彼此的方式进行索引，从而可以独立于彼此进行查询
使用 object 类型，所有数据都存储在同一个文档中，因此搜索匹配可以跨越子文档。例如，想象一个 logs 索引，其中 pages 映射为 object 数据类型：
PUT logs/_doc/0 { &amp;quot;response&amp;quot;: &amp;quot;200&amp;quot;, &amp;quot;pages&amp;quot;: [ { &amp;quot;page&amp;quot;: &amp;quot;landing&amp;quot;, &amp;quot;load_time&amp;quot;: 200 }, { &amp;quot;page&amp;quot;: &amp;quot;blog&amp;quot;, &amp;quot;load_time&amp;quot;: 500 } ] } Easysearch 合并所有看起来像这样的实体关系的子属性：
{ &amp;quot;logs&amp;quot;: { &amp;quot;pages&amp;quot;: [&amp;quot;landing&amp;quot;, &amp;quot;blog&amp;quot;], &amp;quot;load_time&amp;quot;: [&amp;quot;200&amp;quot;, &amp;quot;500&amp;quot;] } } 所以，如果你想要用 pages=landing 和 load_time=500 搜索这个索引，即使 load_time 的 landing 值为 200，这个文档也符合条件。
如果你想要确保不会发生这种跨对象匹配，将字段映射为 nested 类型：
PUT logs { &amp;quot;mappings&amp;quot;: { &amp;quot;properties&amp;quot;: { &amp;quot;pages&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;nested&amp;quot;, &amp;quot;properties&amp;quot;: { &amp;quot;page&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot; }, &amp;quot;load_time&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;double&amp;quot; } } } } } } 嵌套文档允许你索引相同的 JSON 文档，但会保持你的页面在不同的 Lucene 文档中，使得只有 pages=landing 和 load_time=200 这样的搜索能返回预期结果。内部上，嵌套对象将数组中的每个对象索引为一个单独的隐藏文档，这意味着每个嵌套对象都可以独立于其他对象进行查询。</description></item><item><title>日期直方图聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/date-histogram/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/date-histogram/</guid><description>日期直方图聚合 # date_histogram 日期直方图聚合使用日期计算来为时间序列数据生成直方图。
例如，您可以找到您的网站每月有多少次访问：
GET sample_data_logs/_search { &amp;quot;size&amp;quot;: 0, &amp;quot;aggs&amp;quot;: { &amp;quot;logs_per_month&amp;quot;: { &amp;quot;date_histogram&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;@timestamp&amp;quot;, &amp;quot;interval&amp;quot;: &amp;quot;month&amp;quot; } } } } 返回内容
... &amp;quot;aggregations&amp;quot; : { &amp;quot;logs_per_month&amp;quot; : { &amp;quot;buckets&amp;quot; : [ { &amp;quot;key_as_string&amp;quot; : &amp;quot;2020-10-01T00:00:00.000Z&amp;quot;, &amp;quot;key&amp;quot; : 1601510400000, &amp;quot;doc_count&amp;quot; : 1635 }, { &amp;quot;key_as_string&amp;quot; : &amp;quot;2020-11-01T00:00:00.000Z&amp;quot;, &amp;quot;key&amp;quot; : 1604188800000, &amp;quot;doc_count&amp;quot; : 6844 }, { &amp;quot;key_as_string&amp;quot; : &amp;quot;2020-12-01T00:00:00.000Z&amp;quot;, &amp;quot;key&amp;quot; : 1606780800000, &amp;quot;doc_count&amp;quot; : 5595 } ] } } 返回内容包含三个月的日志。如果你绘制这些值，你可以看到你的网站每月请求流量的峰值和低谷。</description></item><item><title>日期范围聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/date-range/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/date-range/</guid><description>日期范围聚合 # date_range 日期范围聚合在概念上与 range 聚合相同，只是它允许执行日期计算。例如，你可以获取过去 10 天内的所有文档。为了使日期更易读，可以使用 format 参数包含格式：
GET sample_data_logs/_search { &amp;quot;size&amp;quot;: 0, &amp;quot;aggs&amp;quot;: { &amp;quot;number_of_bytes&amp;quot;: { &amp;quot;date_range&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;@timestamp&amp;quot;, &amp;quot;format&amp;quot;: &amp;quot;MM-yyyy&amp;quot;, &amp;quot;ranges&amp;quot;: [ { &amp;quot;from&amp;quot;: &amp;quot;now-10d/d&amp;quot;, &amp;quot;to&amp;quot;: &amp;quot;now&amp;quot; } ] } } } } 返回内容
... &amp;quot;aggregations&amp;quot; : { &amp;quot;number_of_bytes&amp;quot; : { &amp;quot;buckets&amp;quot; : [ { &amp;quot;key&amp;quot; : &amp;quot;03-2021-03-2021&amp;quot;, &amp;quot;from&amp;quot; : 1.6145568E12, &amp;quot;from_as_string&amp;quot; : &amp;quot;03-2021&amp;quot;, &amp;quot;to&amp;quot; : 1.615451329043E12, &amp;quot;to_as_string&amp;quot; : &amp;quot;03-2021&amp;quot;, &amp;quot;doc_count&amp;quot; : 0 } ] } } }</description></item><item><title>父级聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/parent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/parent/</guid><description>父级聚合 # parent 父级聚合是一个分组聚合，根据您索引中定义的父子关系创建一个包含父级文档的分组。此聚合使您能够对具有相同匹配子级文档的父级文档执行分析，从而实现强大的层次结构数据分析。
parent 聚合与 join 字段类型一起工作，该字段类型在同一个索引中的文档内建立父子关系。
parent 聚合识别具有匹配子文档的父文档，而 children 聚合识别匹配特定子关系的子文档。这两种聚合都使用子关系名称作为输入。
参数说明 # parent 聚合具有以下参数：
参数 必需/可选 数据类型 描述 type 必填 String join 字段中的子类型名称。 参考样例 # 以下示例构建了一个包含三名员工的小公司数据库。每个员工记录都与一个父部门记录存在 join 子关系。
首先，创建一个 company 索引，其中包含一个 join 字段，该字段将部门（父级）映射到员工（子级）：
PUT /company { &amp;quot;mappings&amp;quot;: { &amp;quot;properties&amp;quot;: { &amp;quot;join_field&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;join&amp;quot;, &amp;quot;relations&amp;quot;: { &amp;quot;department&amp;quot;: &amp;quot;employee&amp;quot; } }, &amp;quot;department_name&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;keyword&amp;quot; }, &amp;quot;employee_name&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;keyword&amp;quot; }, &amp;quot;salary&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;double&amp;quot; }, &amp;quot;hire_date&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;date&amp;quot; } } } } 接下来，用三个部门和三个员工填充数据。父子关系在以下表格中展示。</description></item><item><title>直方图聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/histogram/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/histogram/</guid><description>直方图聚合 # histogram 直方图聚合根据指定的间隔对文档进行分组。
使用 histogram 聚合，您可以非常轻松地可视化给定范围内文档中值的分布。
以下示例将 number_of_bytes 字段按 10,000 个间隔进行分组：
GET sample_data_logs/_search { &amp;quot;size&amp;quot;: 0, &amp;quot;aggs&amp;quot;: { &amp;quot;number_of_bytes&amp;quot;: { &amp;quot;histogram&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;bytes&amp;quot;, &amp;quot;interval&amp;quot;: 10000 } } } } 返回内容
... &amp;quot;aggregations&amp;quot; : { &amp;quot;number_of_bytes&amp;quot; : { &amp;quot;buckets&amp;quot; : [ { &amp;quot;key&amp;quot; : 0.0, &amp;quot;doc_count&amp;quot; : 13372 }, { &amp;quot;key&amp;quot; : 10000.0, &amp;quot;doc_count&amp;quot; : 702 } ] } } 参数说明 # histogram 聚合支持以下参数。
参数 必需/可选 数据类型 描述 interval 必填 Numeric 构造每个分组所使用的字段值宽度。</description></item><item><title>稀有分组聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/rare-terms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/rare-terms/</guid><description>稀有分组聚合 # rare_terms 稀有分组聚合是一个分组聚合，用于识别数据集中的不常见词项。与 terms 聚合（查找最常见的词项）不同， rare_terms 聚合查找出现频率最低的词项。 rare_terms 聚合适用于异常检测、长尾分析和异常报告等应用。
可以使用 terms 通过按升序计数排序（ &amp;ldquo;order&amp;rdquo;: {&amp;ldquo;count&amp;rdquo;: &amp;ldquo;asc&amp;rdquo;} ）来搜索不常见的值。然而，我们强烈不建议这种做法，因为在涉及多个分片时，它可能导致不准确的结果。一个全局上不常见的词项可能不会在每个单个分片上显得不常见，或者可能完全不在某些分片返回的最不常见结果中。相反，一个在某个分片上出现频率较低的词项可能在另一个分片上很常见。在这两种情况下，分片级别的聚合可能会遗漏稀有词项，导致整体结果不正确。我们建议使用 rare_terms 聚合代替 terms 聚合，它专门设计用于更准确地处理这些情况。
近似结果 # 计算 rare_terms 聚合的精确结果需要编译所有分片上的值完整映射，这需要过多的运行时内存。因此， rare_terms 聚合结果被近似处理。
rare_terms 计算中的大多数错误是假阴性或“遗漏”的值，这些值定义了聚合检测测试的灵敏度。 rare_terms 聚合使用 CuckooFilter 算法以实现适当的灵敏度和可接受的内存使用平衡。有关 CuckooFilter 算法的描述，请参阅这篇论文。
控制灵敏度 # rare_terms 聚合算法中的灵敏度误差被衡量为被遗漏的稀有值的比例，或 false negatives/target values 。例如，如果聚合在包含 5,000 个稀有值的数据集中遗漏了 100 个稀有值，灵敏度误差为 100/5000 = 0.02 ，或 2%。
您可以调整 precision 参数在 rare_terms 聚合中来控制灵敏度和内存使用之间的权衡。
这些因素也会影响灵敏度和内存的权衡：
唯一值的总数 数据集中稀有项的比例 以下指南可以帮助你决定使用哪个 precision 值。</description></item><item><title>缺省聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/missing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/missing/</guid><description>缺省聚合 # 如果你的索引中的文档完全不包含聚合字段，或者聚合字段的值为 NULL，请使用 missing 参数指定这些文档应该放入的分组的名称。
以下示例将任何缺失的值添加到名为“N/A”的分组中：
GET sample_data_logs/_search { &amp;quot;size&amp;quot;: 0, &amp;quot;aggs&amp;quot;: { &amp;quot;response_codes&amp;quot;: { &amp;quot;terms&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;response.keyword&amp;quot;, &amp;quot;size&amp;quot;: 10, &amp;quot;missing&amp;quot;: &amp;quot;N/A&amp;quot; } } } } 由于 min_doc_count 参数的默认值为 1， missing 参数在其响应中不会返回任何分组。将 min_doc_count 参数设置为 0 以在响应中查看“N/A”分组：
GET sample_data_logs/_search { &amp;quot;size&amp;quot;: 0, &amp;quot;aggs&amp;quot;: { &amp;quot;response_codes&amp;quot;: { &amp;quot;terms&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;response.keyword&amp;quot;, &amp;quot;size&amp;quot;: 10, &amp;quot;missing&amp;quot;: &amp;quot;N/A&amp;quot;, &amp;quot;min_doc_count&amp;quot;: 0 } } } } 返回内容
... &amp;quot;aggregations&amp;quot; : { &amp;quot;response_codes&amp;quot; : { &amp;quot;doc_count_error_upper_bound&amp;quot; : 0, &amp;quot;sum_other_doc_count&amp;quot; : 0, &amp;quot;buckets&amp;quot; : [ { &amp;quot;key&amp;quot; : &amp;quot;200&amp;quot;, &amp;quot;doc_count&amp;quot; : 12832 }, { &amp;quot;key&amp;quot; : &amp;quot;404&amp;quot;, &amp;quot;doc_count&amp;quot; : 801 }, { &amp;quot;key&amp;quot; : &amp;quot;503&amp;quot;, &amp;quot;doc_count&amp;quot; : 441 }, { &amp;quot;key&amp;quot; : &amp;quot;N/A&amp;quot;, &amp;quot;doc_count&amp;quot; : 0 } ] } } }</description></item><item><title>范围聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/range/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/range/</guid><description>范围聚合 # range 范围聚合允许你为每个分组定义范围。
例如，你可以找到在 1000 和 2000 之间、2000 和 3000 之间以及 3000 和 4000 之间的字节数。在 range 参数中，你可以将范围定义为数组对象。
GET sample_data_logs/_search { &amp;quot;size&amp;quot;: 0, &amp;quot;aggs&amp;quot;: { &amp;quot;number_of_bytes_distribution&amp;quot;: { &amp;quot;range&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;bytes&amp;quot;, &amp;quot;ranges&amp;quot;: [ { &amp;quot;from&amp;quot;: 1000, &amp;quot;to&amp;quot;: 2000 }, { &amp;quot;from&amp;quot;: 2000, &amp;quot;to&amp;quot;: 3000 }, { &amp;quot;from&amp;quot;: 3000, &amp;quot;to&amp;quot;: 4000 } ] } } } } 响应包含 from 键值，并排除 to 键值：
... &amp;quot;aggregations&amp;quot; : { &amp;quot;number_of_bytes_distribution&amp;quot; : { &amp;quot;buckets&amp;quot; : [ { &amp;quot;key&amp;quot; : &amp;quot;1000.</description></item><item><title>过滤聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/filter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/filter/</guid><description>过滤聚合 # 一个 filter 过滤聚合是一个查询子句，就像一个搜索查询一样 — match 或 term 或 range 。您可以使用 filter 聚合在创建分组之前将整个文档集缩小到特定的文档集。
以下示例展示了 avg 聚合在过滤上下文中运行的情况。 avg 聚合仅聚合与 range 查询匹配的文档：
GET sample_data_ecommerce/_search { &amp;quot;size&amp;quot;: 0, &amp;quot;aggs&amp;quot;: { &amp;quot;low_value&amp;quot;: { &amp;quot;filter&amp;quot;: { &amp;quot;range&amp;quot;: { &amp;quot;taxful_total_price&amp;quot;: { &amp;quot;lte&amp;quot;: 50 } } }, &amp;quot;aggs&amp;quot;: { &amp;quot;avg_amount&amp;quot;: { &amp;quot;avg&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;taxful_total_price&amp;quot; } } } } } } 返回内容
... &amp;quot;aggregations&amp;quot; : { &amp;quot;low_value&amp;quot; : { &amp;quot;doc_count&amp;quot; : 1633, &amp;quot;avg_amount&amp;quot; : { &amp;quot;value&amp;quot; : 38.</description></item><item><title>邻接矩阵聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/adjacency-matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/adjacency-matrix/</guid><description>邻接矩阵聚合 # adjacency_matrix 邻接矩阵聚合允许你定义过滤表达式，并返回一个交集矩阵，矩阵中的每个非空单元格代表一个分组。你可以找到落入任何过滤器组合中的文档数量。
使用 adjacency_matrix 聚合通过将数据可视化为图形来发现概念之间的关联。
例如，下面查询可以分析不同制造公司之间的关联关系：
GET sample_data_ecommerce/_search { &amp;quot;size&amp;quot;: 0, &amp;quot;aggs&amp;quot;: { &amp;quot;interactions&amp;quot;: { &amp;quot;adjacency_matrix&amp;quot;: { &amp;quot;filters&amp;quot;: { &amp;quot;grpA&amp;quot;: { &amp;quot;match&amp;quot;: { &amp;quot;manufacturer.keyword&amp;quot;: &amp;quot;Low Tide Media&amp;quot; } }, &amp;quot;grpB&amp;quot;: { &amp;quot;match&amp;quot;: { &amp;quot;manufacturer.keyword&amp;quot;: &amp;quot;Elitelligence&amp;quot; } }, &amp;quot;grpC&amp;quot;: { &amp;quot;match&amp;quot;: { &amp;quot;manufacturer.keyword&amp;quot;: &amp;quot;Oceanavigations&amp;quot; } } } } } } } 返回内容
{ ... &amp;quot;aggregations&amp;quot; : { &amp;quot;interactions&amp;quot; : { &amp;quot;buckets&amp;quot; : [ { &amp;quot;key&amp;quot; : &amp;quot;grpA&amp;quot;, &amp;quot;doc_count&amp;quot; : 1553 }, { &amp;quot;key&amp;quot; : &amp;quot;grpA&amp;amp;grpB&amp;quot;, &amp;quot;doc_count&amp;quot; : 590 }, { &amp;quot;key&amp;quot; : &amp;quot;grpA&amp;amp;grpC&amp;quot;, &amp;quot;doc_count&amp;quot; : 329 }, { &amp;quot;key&amp;quot; : &amp;quot;grpB&amp;quot;, &amp;quot;doc_count&amp;quot; : 1370 }, { &amp;quot;key&amp;quot; : &amp;quot;grpB&amp;amp;grpC&amp;quot;, &amp;quot;doc_count&amp;quot; : 299 }, { &amp;quot;key&amp;quot; : &amp;quot;grpC&amp;quot;, &amp;quot;doc_count&amp;quot; : 1218 } ] } } } 让我们更仔细地查看结果</description></item><item><title>采样聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/sampler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/sampler/</guid><description>采样聚合 # 如果你正在聚合大量文档，可以使用 sampler 聚合将范围缩小到一小部分文档，从而获得更快的响应。 sampler 聚合通过选择得分最高的文档来选取样本。
结果是大致的，但能很好地反映真实数据的分布。 sampler 聚合显著提高了查询性能，但估计的响应并不完全可靠。
基本语法是：
“aggs”: { &amp;quot;SAMPLE&amp;quot;: { &amp;quot;sampler&amp;quot;: { &amp;quot;shard_size&amp;quot;: 100 }, &amp;quot;aggs&amp;quot;: {...} } } 分片大小属性 # shard_size 属性告诉 Easysearch 每个分片最多收集多少文档。
以下示例将每个分片上收集的文档数量限制为 1,000，然后使用 terms 聚合对文档进行分组：
GET sample_data_logs/_search { &amp;quot;size&amp;quot;: 0, &amp;quot;aggs&amp;quot;: { &amp;quot;sample&amp;quot;: { &amp;quot;sampler&amp;quot;: { &amp;quot;shard_size&amp;quot;: 1000 }, &amp;quot;aggs&amp;quot;: { &amp;quot;terms&amp;quot;: { &amp;quot;terms&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;agent.keyword&amp;quot; } } } } } } 返回内容
... &amp;quot;aggregations&amp;quot; : { &amp;quot;sample&amp;quot; : { &amp;quot;doc_count&amp;quot; : 1000, &amp;quot;terms&amp;quot; : { &amp;quot;doc_count_error_upper_bound&amp;quot; : 0, &amp;quot;sum_other_doc_count&amp;quot; : 0, &amp;quot;buckets&amp;quot; : [ { &amp;quot;key&amp;quot; : &amp;quot;Mozilla/5.</description></item><item><title>重点分组聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/significant-terms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/significant-terms/</guid><description>重点分组聚合 # significant_terms 聚合功能可以帮助你在相对于索引中其他数据的过滤子集中识别不寻常或有趣的分组出现情况。
前景集是指你进行过滤的文档集合，背景集是指索引中所有文档的集合。 significant_terms 聚合会检查前景集中的所有文档，并与背景集中的文档进行对比，从而为重要出现情况找到相应的分数。
在示例网络日志数据中，每个文档都有一个包含访客 user-agent 的字段。此示例搜索来自 iOS 操作系统的所有请求。对这一前景集进行常规的 terms 聚合返回 Firefox，因为它在这个分组内有最多的文档数量。另一方面， significant_terms 聚合返回 Internet Explorer（IE），因为 IE 在前景集中的出现频率显著高于背景集。
GET sample_data_logs/_search { &amp;quot;size&amp;quot;: 0, &amp;quot;query&amp;quot;: { &amp;quot;terms&amp;quot;: { &amp;quot;machine.os.keyword&amp;quot;: [ &amp;quot;ios&amp;quot; ] } }, &amp;quot;aggs&amp;quot;: { &amp;quot;significant_response_codes&amp;quot;: { &amp;quot;significant_terms&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;agent.keyword&amp;quot; } } } } 返回内容
... &amp;quot;aggregations&amp;quot; : { &amp;quot;significant_response_codes&amp;quot; : { &amp;quot;doc_count&amp;quot; : 2737, &amp;quot;bg_count&amp;quot; : 14074, &amp;quot;buckets&amp;quot; : [ { &amp;quot;key&amp;quot; : &amp;quot;Mozilla/4.0 (compatible; MSIE 6.</description></item><item><title>重点文本聚合</title><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/significant-text/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/significant-text/</guid><description>重点文本聚合 # significant_text 聚合与 significant_terms 聚合类似，但它适用于原始文本字段。重要文本通过统计分析测量前景集和背景集之间流行度的变化。例如，当你搜索其股票缩写 TSLA 时，它可能会建议 Tesla。
significant_text 聚合会动态重新分析源文本，过滤掉重复段落、模板化的页眉和页脚等噪声数据，这些数据可能会扭曲结果。
重新分析高基数数据集可能是一项非常耗费 CPU 的操作。我们建议在采样聚合中使用 significant_text 聚合来将分析限制在少量最匹配文档中，例如 200。
您可以设置以下参数：
min_doc_count - 返回匹配超过配置数量顶部命中结果。我们不建议将 min_doc_count 设置为 1，因为它倾向于返回拼写错误或错别字。找到一个以上的词项实例有助于加强显著性不是偶然事件的结果。默认值 3 用于提供最小证据权重。 shard_size - 设置高值会增加稳定性（和准确性），但会牺牲计算性能。 shard_min_doc_count - 如果你的文本包含许多低频词，而你又不关心这些词（例如拼写错误），那么你可以将 shard_min_doc_count 参数设置为在分片级别上过滤候选词，以合理地确保即使合并本地显著文本频率也不会达到所需的 min_doc_count 。默认值为 1，直到你显式设置它之前没有影响。我们建议将此值设置得远低于 min_doc_count 值。 假设你在一个 Easysearch 集群中索引了莎士比亚的全部作品。你可以在 text_entry 字段中找到与“breathe”相关的显著文本：
GET shakespeare/_search { &amp;quot;query&amp;quot;: { &amp;quot;match&amp;quot;: { &amp;quot;text_entry&amp;quot;: &amp;quot;breathe&amp;quot; } }, &amp;quot;aggregations&amp;quot;: { &amp;quot;my_sample&amp;quot;: { &amp;quot;sampler&amp;quot;: { &amp;quot;shard_size&amp;quot;: 100 }, &amp;quot;aggregations&amp;quot;: { &amp;quot;keywords&amp;quot;: { &amp;quot;significant_text&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;text_entry&amp;quot;, &amp;quot;min_doc_count&amp;quot;: 4 } } } } } } 返回内容</description></item><item><title/><link>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/auto-interval-date-histogram/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/easysearch/v2.0.1/docs/references/aggregation/bucket-aggregations/auto-interval-date-histogram/</guid><description>自动间隔日期直方图 # 与日期直方图聚合类似，其中你必须指定一个间隔， auto_date_histogram 是一个多分组聚合，根据你提供的分组数量和数据的时范围自动创建日期直方图分组。返回的实际分组数量总是小于或等于你指定的分组数量。当你在处理时间序列数据并希望在不同时间间隔上可视化或分析数据，而不需要手动指定间隔大小时，这种聚合特别有用。
间隔参数 # 分组间隔是根据收集的数据选择的，以确保返回的分组数量小于或等于请求的数量。
下表列出了每个时间单位可能的返回间隔。
单位 间隔参数 Seconds 1、5、10 和 30 的倍数 Minutes 1、5、10 和 30 的倍数 Hours 1、3 和 12 的倍数 Days 1 和 7 的倍数 Months 1 和 3 的倍数 Years 1、5、10、20、50 和 100 的倍数 如果一个聚合返回的分组太多（例如，每天一个分组），Easysearch 会自动减少分组的数量以确保结果可管理。它不会返回请求的确切数量的每日分组，而是会减少大约 1/7。例如，如果你请求 70 个分组，但数据中包含太多的每日间隔，Easysearch 可能只会返回 10 个分组，将数据分组到更大的间隔（如周）中，以避免结果数量过多。这有助于优化聚合，并在数据过多时防止过多细节。</description></item></channel></rss>